{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _lodashArrayPull = require(\"lodash/array/pull\");\n\nvar _lodashArrayPull2 = _interopRequireDefault(_lodashArrayPull);\n\nexports[\"default\"] = function (_ref) {\n  var Plugin = _ref.Plugin;\n  var t = _ref.types;\n\n  function isProtoKey(node) {\n    return t.isLiteral(t.toComputedKey(node, node.key), { value: \"__proto__\" });\n  }\n\n  function isProtoAssignmentExpression(node) {\n    var left = node.left;\n    return t.isMemberExpression(left) && t.isLiteral(t.toComputedKey(left, left.property), { value: \"__proto__\" });\n  }\n\n  function buildDefaultsCallExpression(expr, ref, file) {\n    return t.expressionStatement(t.callExpression(file.addHelper(\"defaults\"), [ref, expr.right]));\n  }\n\n  return new Plugin(\"proto-to-assign\", {\n    metadata: {\n      secondPass: true\n    },\n\n    visitor: {\n      AssignmentExpression: function AssignmentExpression(node, parent, scope, file) {\n        if (!isProtoAssignmentExpression(node)) return;\n\n        var nodes = [];\n        var left = node.left.object;\n        var temp = scope.maybeGenerateMemoised(left);\n\n        if (temp) nodes.push(t.expressionStatement(t.assignmentExpression(\"=\", temp, left)));\n        nodes.push(buildDefaultsCallExpression(node, temp || left, file));\n        if (temp) nodes.push(temp);\n\n        return nodes;\n      },\n\n      ExpressionStatement: function ExpressionStatement(node, parent, scope, file) {\n        var expr = node.expression;\n        if (!t.isAssignmentExpression(expr, { operator: \"=\" })) return;\n\n        if (isProtoAssignmentExpression(expr)) {\n          return buildDefaultsCallExpression(expr, expr.left.object, file);\n        }\n      },\n\n      ObjectExpression: function ObjectExpression(node, parent, scope, file) {\n        var proto;\n\n        for (var i = 0; i < node.properties.length; i++) {\n          var prop = node.properties[i];\n\n          if (isProtoKey(prop)) {\n            proto = prop.value;\n            (0, _lodashArrayPull2[\"default\"])(node.properties, prop);\n          }\n        }\n\n        if (proto) {\n          var args = [t.objectExpression([]), proto];\n          if (node.properties.length) args.push(node);\n          return t.callExpression(file.addHelper(\"extends\"), args);\n        }\n      }\n    }\n  });\n};\n\nmodule.exports = exports[\"default\"];"]}