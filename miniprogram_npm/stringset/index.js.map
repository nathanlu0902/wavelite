{"version":3,"sources":["stringset.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["// stringset.js\n// MIT licensed, see LICENSE file\n// Copyright (c) 2013 Olov Lassus <olov.lassus@gmail.com>\n\nvar StringSet = (function() {\n    \n\n    // to save us a few characters\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n    var create = (function() {\n        function hasOwnEnumerableProps(obj) {\n            for (var prop in obj) {\n                if (hasOwnProperty.call(obj, prop)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        // FF <= 3.6:\n        // o = {}; o.hasOwnProperty(\"__proto__\" or \"__count__\" or \"__parent__\") => true\n        // o = {\"__proto__\": null}; Object.prototype.hasOwnProperty.call(o, \"__proto__\" or \"__count__\" or \"__parent__\") => false\n        function hasOwnPollutedProps(obj) {\n            return hasOwnProperty.call(obj, \"__count__\") || hasOwnProperty.call(obj, \"__parent__\");\n        }\n\n        var useObjectCreate = false;\n        if (typeof Object.create === \"function\") {\n            if (!hasOwnEnumerableProps(Object.create(null))) {\n                useObjectCreate = true;\n            }\n        }\n        if (useObjectCreate === false) {\n            if (hasOwnEnumerableProps({})) {\n                throw new Error(\"StringSet environment error 0, please file a bug at https://github.com/olov/stringset/issues\");\n            }\n        }\n        // no throw yet means we can create objects without own enumerable props (safe-guard against VMs and shims)\n\n        var o = (useObjectCreate ? Object.create(null) : {});\n        var useProtoClear = false;\n        if (hasOwnPollutedProps(o)) {\n            o.__proto__ = null;\n            if (hasOwnEnumerableProps(o) || hasOwnPollutedProps(o)) {\n                throw new Error(\"StringSet environment error 1, please file a bug at https://github.com/olov/stringset/issues\");\n            }\n            useProtoClear = true;\n        }\n        // no throw yet means we can create objects without own polluted props (safe-guard against VMs and shims)\n\n        return function() {\n            var o = (useObjectCreate ? Object.create(null) : {});\n            if (useProtoClear) {\n                o.__proto__ = null;\n            }\n            return o;\n        };\n    })();\n\n    // stringset ctor\n    function stringset(optional_array) {\n        // use with or without new\n        if (!(this instanceof stringset)) {\n            return new stringset(optional_array);\n        }\n        this.obj = create();\n        this.hasProto = false; // false (no __proto__ item) or true (has __proto__ item)\n\n        if (optional_array) {\n            this.addMany(optional_array);\n        }\n    };\n\n    // primitive methods that deals with data representation\n    stringset.prototype.has = function(item) {\n        // The type-check of item in has, get, set and delete is important because otherwise an object\n        // {toString: function() { return \"__proto__\"; }} can avoid the item === \"__proto__\" test.\n        // The alternative to type-checking would be to force string conversion, i.e. item = String(item);\n        if (typeof item !== \"string\") {\n            throw new Error(\"StringSet expected string item\");\n        }\n        return (item === \"__proto__\" ?\n            this.hasProto :\n            hasOwnProperty.call(this.obj, item));\n    };\n\n    stringset.prototype.add = function(item) {\n        if (typeof item !== \"string\") {\n            throw new Error(\"StringSet expected string item\");\n        }\n        if (item === \"__proto__\") {\n            this.hasProto = true;\n        } else {\n            this.obj[item] = true;\n        }\n    };\n\n    stringset.prototype.remove = function(item) {\n        if (typeof item !== \"string\") {\n            throw new Error(\"StringSet expected string item\");\n        }\n        var didExist = this.has(item);\n        if (item === \"__proto__\") {\n            this.hasProto = false;\n        } else {\n            delete this.obj[item];\n        }\n        return didExist;\n    };\n\n    // alias remove to delete but beware:\n    // ss.delete(\"key\"); // OK in ES5 and later\n    // ss['delete'](\"key\"); // OK in all ES versions\n    // ss.remove(\"key\"); // OK in all ES versions\n    stringset.prototype['delete'] = stringset.prototype.remove;\n\n    stringset.prototype.isEmpty = function() {\n        for (var item in this.obj) {\n            if (hasOwnProperty.call(this.obj, item)) {\n                return false;\n            }\n        }\n        return !this.hasProto;\n    };\n\n    stringset.prototype.size = function() {\n        var len = 0;\n        for (var item in this.obj) {\n            if (hasOwnProperty.call(this.obj, item)) {\n                ++len;\n            }\n        }\n        return (this.hasProto ? len + 1 : len);\n    };\n\n    stringset.prototype.items = function() {\n        var items = [];\n        for (var item in this.obj) {\n            if (hasOwnProperty.call(this.obj, item)) {\n                items.push(item);\n            }\n        }\n        if (this.hasProto) {\n            items.push(\"__proto__\");\n        }\n        return items;\n    };\n\n\n    // methods that rely on the above primitives\n    stringset.prototype.addMany = function(items) {\n        if (!Array.isArray(items)) {\n            throw new Error(\"StringSet expected array\");\n        }\n        for (var i = 0; i < items.length; i++) {\n            this.add(items[i]);\n        }\n        return this;\n    };\n\n    stringset.prototype.merge = function(other) {\n        this.addMany(other.items());\n        return this;\n    };\n\n    stringset.prototype.clone = function() {\n        var other = stringset();\n        return other.merge(this);\n    };\n\n    stringset.prototype.toString = function() {\n        return \"{\" + this.items().map(JSON.stringify).join(\",\") + \"}\";\n    };\n\n    return stringset;\n})();\n\nif (typeof module !== \"undefined\" && typeof module.exports !== \"undefined\") {\n    module.exports = StringSet;\n}\n"]}