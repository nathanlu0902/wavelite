{"version":3,"sources":["defs-main.js","scope.js","error.js","options.js","stats.js","jshint_globals/vars.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ADGA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA;ADIA,AENA,ACHA,AFMA,AGTA;AJaA,AENA,ACHA,AFMA,AGTA;AJaA,AENA,ACHA,AFMA,AGTA;AJaA,AENA,AGTA,AFMA,AFMA,AGTA;AJaA,AENA,AGTA,AFMA,AFMA,AGTA;AJaA,AENA,AGTA,AFMA,AFMA,AGTA;AJaA,AENA,AGTA,AJYA,AGTA;AJaA,AENA,AGTA,AJYA,AGTA;AJaA,AENA,AGTA,AJYA,AGTA;AJaA,AENA,AGTA,AJYA,AGTA;AJaA,AENA,AGTA,AJYA,AGTA;AJaA,AENA,AGTA,AJYA,AGTA;AJaA,AENA,AGTA,AJYA,AGTA;AJaA,AENA,AGTA,AJYA,AGTA;AJaA,AENA,AGTA,AJYA,AGTA;AJaA,AENA,AGTA,AJYA,AGTA;AJaA,AENA,AGTA,AJYA,AGTA;AJaA,AENA,AGTA,AJYA,AGTA;AJaA,AENA,AGTA,AJYA,AGTA;AJaA,AENA,AGTA,AJYA,AGTA;AJaA,AENA,AGTA,AJYA,AGTA;AJaA,AENA,AGTA,AJYA,AGTA;AJaA,AENA,AGTA,AJYA,AGTA;AJaA,AKfA,AJYA,AGTA;AJaA,AKfA,AJYA,AGTA;AJaA,AKfA,AJYA,AGTA;AJaA,AKfA,AJYA,AGTA;AJaA,AKfA,AJYA,AGTA;AJaA,AKfA,AJYA,AGTA;AJaA,AKfA,AJYA,AGTA;AJaA,AKfA,AJYA,AGTA;AJaA,AKfA,AJYA,AGTA;AJaA,AKfA,AJYA,AGTA;AJaA,AKfA,AJYA,AGTA;AJaA,AKfA,AJYA,AGTA;AJaA,AKfA,AJYA,AGTA;AJaA,AKfA,AJYA,AGTA;AJaA,AKfA,AJYA,AGTA;AJaA,AKfA,AJYA,AGTA;AJaA,AKfA,AJYA,AGTA;AJaA,AKfA,AJYA,AGTA;AJaA,AKfA,AJYA,AGTA;AJaA,AKfA,AJYA,AGTA;AJaA,AKfA,AJYA,AGTA;AJaA,AKfA,AJYA,AGTA;AJaA,AKfA,AJYA,AGTA;AJaA,AKfA,AJYA,AGTA;AJaA,AKfA,AJYA,AGTA;AJaA,AKfA,AJYA,AGTA;AJaA,AKfA,AJYA,AGTA;AJaA,AKfA,AJYA,AGTA;AJaA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA,AJYA;ADIA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nvar assert = require(\"assert\");\nvar is = require(\"simple-is\");\nvar fmt = require(\"simple-fmt\");\nvar stringmap = require(\"stringmap\");\nvar stringset = require(\"stringset\");\nvar alter = require(\"alter\");\nvar traverse = require(\"ast-traverse\");\nvar breakable = require(\"breakable\");\nvar Scope = require(\"./scope\");\nvar error = require(\"./error\");\nvar getline = error.getline;\nvar options = require(\"./options\");\nvar Stats = require(\"./stats\");\nvar jshint_vars = require(\"./jshint_globals/vars.js\");\n\n\nfunction isConstLet(kind) {\n    return is.someof(kind, [\"const\", \"let\"]);\n}\n\nfunction isVarConstLet(kind) {\n    return is.someof(kind, [\"var\", \"const\", \"let\"]);\n}\n\nfunction isNonFunctionBlock(node) {\n    return node.type === \"BlockStatement\" && is.noneof(node.$parent.type, [\"FunctionDeclaration\", \"FunctionExpression\"]);\n}\n\nfunction isForWithConstLet(node) {\n    return node.type === \"ForStatement\" && node.init && node.init.type === \"VariableDeclaration\" && isConstLet(node.init.kind);\n}\n\nfunction isForInOfWithConstLet(node) {\n    return isForInOf(node) && node.left.type === \"VariableDeclaration\" && isConstLet(node.left.kind);\n}\n\nfunction isForInOf(node) {\n    return is.someof(node.type, [\"ForInStatement\", \"ForOfStatement\"]);\n}\n\nfunction isFunction(node) {\n    return is.someof(node.type, [\"FunctionDeclaration\", \"FunctionExpression\"]);\n}\n\nfunction isLoop(node) {\n    return is.someof(node.type, [\"ForStatement\", \"ForInStatement\", \"ForOfStatement\", \"WhileStatement\", \"DoWhileStatement\"]);\n}\n\nfunction isReference(node) {\n    var parent = node.$parent;\n    return node.$refToScope ||\n        node.type === \"Identifier\" &&\n        !(parent.type === \"VariableDeclarator\" && parent.id === node) && // var|let|const $\n        !(parent.type === \"MemberExpression\" && parent.computed === false && parent.property === node) && // obj.$\n        !(parent.type === \"Property\" && parent.key === node) && // {$: ...}\n        !(parent.type === \"LabeledStatement\" && parent.label === node) && // $: ...\n        !(parent.type === \"CatchClause\" && parent.param === node) && // catch($)\n        !(isFunction(parent) && parent.id === node) && // function $(..\n        !(isFunction(parent) && is.someof(node, parent.params)) && // function f($)..\n        true;\n}\n\nfunction isLvalue(node) {\n    return isReference(node) &&\n        ((node.$parent.type === \"AssignmentExpression\" && node.$parent.left === node) ||\n            (node.$parent.type === \"UpdateExpression\" && node.$parent.argument === node));\n}\n\nfunction createScopes(node, parent) {\n    assert(!node.$scope);\n\n    node.$parent = parent;\n    node.$scope = node.$parent ? node.$parent.$scope : null; // may be overridden\n\n    if (node.type === \"Program\") {\n        // Top-level program is a scope\n        // There's no block-scope under it\n        node.$scope = new Scope({\n            kind: \"hoist\",\n            node: node,\n            parent: null,\n        });\n\n    } else if (isFunction(node)) {\n        // Function is a scope, with params in it\n        // There's no block-scope under it\n\n        node.$scope = new Scope({\n            kind: \"hoist\",\n            node: node,\n            parent: node.$parent.$scope,\n        });\n\n        // function has a name\n        if (node.id) {\n            assert(node.id.type === \"Identifier\");\n\n            if (node.type === \"FunctionDeclaration\") {\n                // Function name goes in parent scope for declared functions\n                node.$parent.$scope.add(node.id.name, \"fun\", node.id, null);\n            } else if (node.type === \"FunctionExpression\") {\n                // Function name goes in function's scope for named function expressions\n                node.$scope.add(node.id.name, \"fun\", node.id, null);\n            } else {\n                assert(false);\n            }\n        }\n\n        node.params.forEach(function(param) {\n            node.$scope.add(param.name, \"param\", param, null);\n        });\n\n    } else if (node.type === \"VariableDeclaration\") {\n        // Variable declarations names goes in current scope\n        assert(isVarConstLet(node.kind));\n        node.declarations.forEach(function(declarator) {\n            assert(declarator.type === \"VariableDeclarator\");\n            var name = declarator.id.name;\n            if (options.disallowVars && node.kind === \"var\") {\n                error(getline(declarator), \"var {0} is not allowed (use let or const)\", name);\n            }\n            node.$scope.add(name, node.kind, declarator.id, declarator.range[1]);\n        });\n\n    } else if (isForWithConstLet(node) || isForInOfWithConstLet(node)) {\n        // For(In/Of) loop with const|let declaration is a scope, with declaration in it\n        // There may be a block-scope under it\n        node.$scope = new Scope({\n            kind: \"block\",\n            node: node,\n            parent: node.$parent.$scope,\n        });\n\n    } else if (isNonFunctionBlock(node)) {\n        // A block node is a scope unless parent is a function\n        node.$scope = new Scope({\n            kind: \"block\",\n            node: node,\n            parent: node.$parent.$scope,\n        });\n\n    } else if (node.type === \"CatchClause\") {\n        var identifier = node.param;\n\n        node.$scope = new Scope({\n            kind: \"catch-block\",\n            node: node,\n            parent: node.$parent.$scope,\n        });\n        node.$scope.add(identifier.name, \"caught\", identifier, null);\n\n        // All hoist-scope keeps track of which variables that are propagated through,\n        // i.e. an reference inside the scope points to a declaration outside the scope.\n        // This is used to mark \"taint\" the name since adding a new variable in the scope,\n        // with a propagated name, would change the meaning of the existing references.\n        //\n        // catch(e) is special because even though e is a variable in its own scope,\n        // we want to make sure that catch(e){let e} is never transformed to\n        // catch(e){var e} (but rather var e$0). For that reason we taint the use of e\n        // in the closest hoist-scope, i.e. where var e$0 belongs.\n        node.$scope.closestHoistScope().markPropagates(identifier.name);\n    }\n}\n\nfunction createTopScope(programScope, environments, globals) {\n    function inject(obj) {\n        for (var name in obj) {\n            var writeable = obj[name];\n            var kind = (writeable ? \"var\" : \"const\");\n            if (topScope.hasOwn(name)) {\n                topScope.remove(name);\n            }\n            topScope.add(name, kind, {loc: {start: {line: -1}}}, -1);\n        }\n    }\n\n    var topScope = new Scope({\n        kind: \"hoist\",\n        node: {},\n        parent: null,\n    });\n\n    var complementary = {\n        undefined: false,\n        Infinity: false,\n        console: false,\n    };\n\n    inject(complementary);\n    inject(jshint_vars.reservedVars);\n    inject(jshint_vars.ecmaIdentifiers);\n    if (environments) {\n        environments.forEach(function(env) {\n            if (!jshint_vars[env]) {\n                error(-1, 'environment \"{0}\" not found', env);\n            } else {\n                inject(jshint_vars[env]);\n            }\n        });\n    }\n    if (globals) {\n        inject(globals);\n    }\n\n    // link it in\n    programScope.parent = topScope;\n    topScope.children.push(programScope);\n\n    return topScope;\n}\n\nfunction setupReferences(ast, allIdentifiers, opts) {\n    var analyze = (is.own(opts, \"analyze\") ? opts.analyze : true);\n\n    function visit(node) {\n        if (!isReference(node)) {\n            return;\n        }\n        allIdentifiers.add(node.name);\n\n        var scope = node.$scope.lookup(node.name);\n        if (analyze && !scope && options.disallowUnknownReferences) {\n            error(getline(node), \"reference to unknown global variable {0}\", node.name);\n        }\n        // check const and let for referenced-before-declaration\n        if (analyze && scope && is.someof(scope.getKind(node.name), [\"const\", \"let\"])) {\n            var allowedFromPos = scope.getFromPos(node.name);\n            var referencedAtPos = node.range[0];\n            assert(is.finitenumber(allowedFromPos));\n            assert(is.finitenumber(referencedAtPos));\n            if (referencedAtPos < allowedFromPos) {\n                if (!node.$scope.hasFunctionScopeBetween(scope)) {\n                    error(getline(node), \"{0} is referenced before its declaration\", node.name);\n                }\n            }\n        }\n        node.$refToScope = scope;\n    }\n\n    traverse(ast, {pre: visit});\n}\n\n// TODO for loops init and body props are parallel to each other but init scope is outer that of body\n// TODO is this a problem?\n\nfunction varify(ast, stats, allIdentifiers, changes) {\n    function unique(name) {\n        assert(allIdentifiers.has(name));\n        for (var cnt = 0; ; cnt++) {\n            var genName = name + \"$\" + String(cnt);\n            if (!allIdentifiers.has(genName)) {\n                return genName;\n            }\n        }\n    }\n\n    function renameDeclarations(node) {\n        if (node.type === \"VariableDeclaration\" && isConstLet(node.kind)) {\n            var hoistScope = node.$scope.closestHoistScope();\n            var origScope = node.$scope;\n\n            // text change const|let => var\n            changes.push({\n                start: node.range[0],\n                end: node.range[0] + node.kind.length,\n                str: \"var\",\n            });\n\n            node.declarations.forEach(function(declarator) {\n                assert(declarator.type === \"VariableDeclarator\");\n                var name = declarator.id.name;\n\n                stats.declarator(node.kind);\n\n                // rename if\n                // 1) name already exists in hoistScope, or\n                // 2) name is already propagated (passed) through hoistScope or manually tainted\n                var rename = (origScope !== hoistScope &&\n                    (hoistScope.hasOwn(name) || hoistScope.doesPropagate(name)));\n\n                var newName = (rename ? unique(name) : name);\n\n                origScope.remove(name);\n                hoistScope.add(newName, \"var\", declarator.id, declarator.range[1]);\n\n                origScope.moves = origScope.moves || stringmap();\n                origScope.moves.set(name, {\n                    name: newName,\n                    scope: hoistScope,\n                });\n\n                allIdentifiers.add(newName);\n\n                if (newName !== name) {\n                    stats.rename(name, newName, getline(declarator));\n\n                    declarator.id.originalName = name;\n                    declarator.id.name = newName;\n\n                    // textchange var x => var x$1\n                    changes.push({\n                        start: declarator.id.range[0],\n                        end: declarator.id.range[1],\n                        str: newName,\n                    });\n                }\n            });\n\n            // ast change const|let => var\n            node.kind = \"var\";\n        }\n    }\n\n    function renameReferences(node) {\n        if (!node.$refToScope) {\n            return;\n        }\n        var move = node.$refToScope.moves && node.$refToScope.moves.get(node.name);\n        if (!move) {\n            return;\n        }\n        node.$refToScope = move.scope;\n\n        if (node.name !== move.name) {\n            node.originalName = node.name;\n            node.name = move.name;\n\n            if (node.alterop) {\n                // node has no range because it is the result of another alter operation\n                var existingOp = null;\n                for (var i = 0; i < changes.length; i++) {\n                    var op = changes[i];\n                    if (op.node === node) {\n                        existingOp = op;\n                        break;\n                    }\n                }\n                assert(existingOp);\n\n                // modify op\n                existingOp.str = move.name;\n            } else {\n                changes.push({\n                    start: node.range[0],\n                    end: node.range[1],\n                    str: move.name,\n                });\n            }\n        }\n    }\n\n    traverse(ast, {pre: renameDeclarations});\n    traverse(ast, {pre: renameReferences});\n    ast.$scope.traverse({pre: function(scope) {\n        delete scope.moves;\n    }});\n}\n\n\nfunction detectLoopClosures(ast) {\n    traverse(ast, {pre: visit});\n\n    function detectIifyBodyBlockers(body, node) {\n        return breakable(function(brk) {\n            traverse(body, {pre: function(n) {\n                // if we hit an inner function of the loop body, don't traverse further\n                if (isFunction(n)) {\n                    return false;\n                }\n\n                var err = true; // reset to false in else-statement below\n                var msg = \"loop-variable {0} is captured by a loop-closure that can't be transformed due to use of {1} at line {2}\";\n                if (n.type === \"BreakStatement\") {\n                    error(getline(node), msg, node.name, \"break\", getline(n));\n                } else if (n.type === \"ContinueStatement\") {\n                    error(getline(node), msg, node.name, \"continue\", getline(n));\n                } else if (n.type === \"ReturnStatement\") {\n                    error(getline(node), msg, node.name, \"return\", getline(n));\n                } else if (n.type === \"YieldExpression\") {\n                    error(getline(node), msg, node.name, \"yield\", getline(n));\n                } else if (n.type === \"Identifier\" && n.name === \"arguments\") {\n                    error(getline(node), msg, node.name, \"arguments\", getline(n));\n                } else if (n.type === \"VariableDeclaration\" && n.kind === \"var\") {\n                    error(getline(node), msg, node.name, \"var\", getline(n));\n                } else {\n                    err = false;\n                }\n                if (err) {\n                    brk(true); // break traversal\n                }\n            }});\n            return false;\n        });\n    }\n\n    function visit(node) {\n        // forbidden pattern:\n        // <any>* <loop> <non-fn>* <constlet-def> <any>* <fn> <any>* <constlet-ref>\n        var loopNode = null;\n        if (isReference(node) && node.$refToScope && isConstLet(node.$refToScope.getKind(node.name))) {\n            // traverse nodes up towards root from constlet-def\n            // if we hit a function (before a loop) - ok!\n            // if we hit a loop - maybe-ouch\n            // if we reach root - ok!\n            for (var n = node.$refToScope.node; ; ) {\n                if (isFunction(n)) {\n                    // we're ok (function-local)\n                    return;\n                } else if (isLoop(n)) {\n                    loopNode = n;\n                    // maybe not ok (between loop and function)\n                    break;\n                }\n                n = n.$parent;\n                if (!n) {\n                    // ok (reached root)\n                    return;\n                }\n            }\n\n            assert(isLoop(loopNode));\n\n            // traverse scopes from reference-scope up towards definition-scope\n            // if we hit a function, ouch!\n            var defScope = node.$refToScope;\n            var generateIIFE = (options.loopClosures === \"iife\");\n\n            for (var s = node.$scope; s; s = s.parent) {\n                if (s === defScope) {\n                    // we're ok\n                    return;\n                } else if (isFunction(s.node)) {\n                    // not ok (there's a function between the reference and definition)\n                    // may be transformable via IIFE\n\n                    if (!generateIIFE) {\n                        var msg = \"loop-variable {0} is captured by a loop-closure. Tried \\\"loopClosures\\\": \\\"iife\\\" in defs-config.json?\";\n                        return error(getline(node), msg, node.name);\n                    }\n\n                    // here be dragons\n                    // for (let x = ..; .. ; ..) { (function(){x})() } is forbidden because of current\n                    // spec and VM status\n                    if (loopNode.type === \"ForStatement\" && defScope.node === loopNode) {\n                        var declarationNode = defScope.getNode(node.name);\n                        return error(getline(declarationNode), \"Not yet specced ES6 feature. {0} is declared in for-loop header and then captured in loop closure\", declarationNode.name);\n                    }\n\n                    // speak now or forever hold your peace\n                    if (detectIifyBodyBlockers(loopNode.body, node)) {\n                        // error already generated\n                        return;\n                    }\n\n                    // mark loop for IIFE-insertion\n                    loopNode.$iify = true;\n                }\n            }\n        }\n    }\n}\n\nfunction transformLoopClosures(root, ops, options) {\n    function insertOp(pos, str, node) {\n        var op = {\n            start: pos,\n            end: pos,\n            str: str,\n        }\n        if (node) {\n            op.node = node;\n        }\n        ops.push(op);\n    }\n\n    traverse(root, {pre: function(node) {\n        if (!node.$iify) {\n            return;\n        }\n\n        var hasBlock = (node.body.type === \"BlockStatement\");\n\n        var insertHead = (hasBlock ?\n            node.body.range[0] + 1 : // just after body {\n            node.body.range[0]); // just before existing expression\n        var insertFoot = (hasBlock ?\n            node.body.range[1] - 1 : // just before body }\n            node.body.range[1]);  // just after existing expression\n\n        var forInName = (isForInOf(node) && node.left.declarations[0].id.name);;\n        var iifeHead = fmt(\"(function({0}){\", forInName ? forInName : \"\");\n        var iifeTail = fmt(\"}).call(this{0});\", forInName ? \", \" + forInName : \"\");\n\n        // modify AST\n        var iifeFragment = options.parse(iifeHead + iifeTail);\n        var iifeExpressionStatement = iifeFragment.body[0];\n        var iifeBlockStatement = iifeExpressionStatement.expression.callee.object.body;\n\n        if (hasBlock) {\n            var forBlockStatement = node.body;\n            var tmp = forBlockStatement.body;\n            forBlockStatement.body = [iifeExpressionStatement];\n            iifeBlockStatement.body = tmp;\n        } else {\n            var tmp$0 = node.body;\n            node.body = iifeExpressionStatement;\n            iifeBlockStatement.body[0] = tmp$0;\n        }\n\n        // create ops\n        insertOp(insertHead, iifeHead);\n\n        if (forInName) {\n            insertOp(insertFoot, \"}).call(this, \");\n\n            var args = iifeExpressionStatement.expression.arguments;\n            var iifeArgumentIdentifier = args[1];\n            iifeArgumentIdentifier.alterop = true;\n            insertOp(insertFoot, forInName, iifeArgumentIdentifier);\n\n            insertOp(insertFoot, \");\");\n        } else {\n            insertOp(insertFoot, iifeTail);\n        }\n    }});\n}\n\nfunction detectConstAssignment(ast) {\n    traverse(ast, {pre: function(node) {\n        if (isLvalue(node)) {\n            var scope = node.$scope.lookup(node.name);\n            if (scope && scope.getKind(node.name) === \"const\") {\n                error(getline(node), \"can't assign to const variable {0}\", node.name);\n            }\n        }\n    }});\n}\n\nfunction detectConstantLets(ast) {\n    traverse(ast, {pre: function(node) {\n        if (isLvalue(node)) {\n            var scope = node.$scope.lookup(node.name);\n            if (scope) {\n                scope.markWrite(node.name);\n            }\n        }\n    }});\n\n    ast.$scope.detectUnmodifiedLets();\n}\n\nfunction setupScopeAndReferences(root, opts) {\n    // setup scopes\n    traverse(root, {pre: createScopes});\n    var topScope = createTopScope(root.$scope, options.environments, options.globals);\n\n    // allIdentifiers contains all declared and referenced vars\n    // collect all declaration names (including those in topScope)\n    var allIdentifiers = stringset();\n    topScope.traverse({pre: function(scope) {\n        allIdentifiers.addMany(scope.decls.keys());\n    }});\n\n    // setup node.$refToScope, check for errors.\n    // also collects all referenced names to allIdentifiers\n    setupReferences(root, allIdentifiers, opts);\n    return allIdentifiers;\n}\n\nfunction cleanupTree(root) {\n    traverse(root, {pre: function(node) {\n        for (var prop in node) {\n            if (prop[0] === \"$\") {\n                delete node[prop];\n            }\n        }\n    }});\n}\n\nfunction run(src, config) {\n    // alter the options singleton with user configuration\n    for (var key in config) {\n        options[key] = config[key];\n    }\n\n    var parsed;\n\n    if (is.object(src)) {\n        if (!options.ast) {\n            return {\n                errors: [\n                    \"Can't produce string output when input is an AST. \" +\n                    \"Did you forget to set options.ast = true?\"\n                ],\n            };\n        }\n\n        // Received an AST object as src, so no need to parse it.\n        parsed = src;\n\n    } else if (is.string(src)) {\n        try {\n            parsed = options.parse(src, {\n                loc: true,\n                range: true,\n            });\n        } catch (e) {\n            return {\n                errors: [\n                    fmt(\"line {0} column {1}: Error during input file parsing\\n{2}\\n{3}\",\n                        e.lineNumber,\n                        e.column,\n                        src.split(\"\\n\")[e.lineNumber - 1],\n                        fmt.repeat(\" \", e.column - 1) + \"^\")\n                ],\n            };\n        }\n\n    } else {\n        return {\n            errors: [\"Input was neither an AST object nor a string.\"],\n        };\n    }\n\n    var ast = parsed;\n\n    // TODO detect unused variables (never read)\n    error.reset();\n\n    var allIdentifiers = setupScopeAndReferences(ast, {});\n\n    // static analysis passes\n    detectLoopClosures(ast);\n    detectConstAssignment(ast);\n    //detectConstantLets(ast);\n\n    var changes = [];\n    transformLoopClosures(ast, changes, options);\n\n    //ast.$scope.print(); process.exit(-1);\n\n    if (error.errors.length >= 1) {\n        return {\n            errors: error.errors,\n        };\n    }\n\n    if (changes.length > 0) {\n        cleanupTree(ast);\n        allIdentifiers = setupScopeAndReferences(ast, {analyze: false});\n    }\n    assert(error.errors.length === 0);\n\n    // change constlet declarations to var, renamed if needed\n    // varify modifies the scopes and AST accordingly and\n    // returns a list of change fragments (to use with alter)\n    var stats = new Stats();\n    varify(ast, stats, allIdentifiers, changes);\n\n    if (options.ast) {\n        // return the modified AST instead of src code\n        // get rid of all added $ properties first, such as $parent and $scope\n        cleanupTree(ast);\n        return {\n            stats: stats,\n            ast: ast,\n        };\n    } else {\n        // apply changes produced by varify and return the transformed src\n        var transformedSrc = alter(src, changes);\n        return {\n            stats: stats,\n            src: transformedSrc,\n        };\n    }\n}\n\nmodule.exports = run;\n","\n\nvar assert = require(\"assert\");\nvar stringmap = require(\"stringmap\");\nvar stringset = require(\"stringset\");\nvar is = require(\"simple-is\");\nvar fmt = require(\"simple-fmt\");\nvar error = require(\"./error\");\nvar getline = error.getline;\nvar options = require(\"./options\");\n\nfunction Scope(args) {\n    assert(is.someof(args.kind, [\"hoist\", \"block\", \"catch-block\"]));\n    assert(is.object(args.node));\n    assert(args.parent === null || is.object(args.parent));\n\n    // kind === \"hoist\": function scopes, program scope, injected globals\n    // kind === \"block\": ES6 block scopes\n    // kind === \"catch-block\": catch block scopes\n    this.kind = args.kind;\n\n    // the AST node the block corresponds to\n    this.node = args.node;\n\n    // parent scope\n    this.parent = args.parent;\n\n    // children scopes for easier traversal (populated internally)\n    this.children = [];\n\n    // scope declarations. decls[variable_name] = {\n    //     kind: \"fun\" for functions,\n    //           \"param\" for function parameters,\n    //           \"caught\" for catch parameter\n    //           \"var\",\n    //           \"const\",\n    //           \"let\"\n    //     node: the AST node the declaration corresponds to\n    //     from: source code index from which it is visible at earliest\n    //           (only stored for \"const\", \"let\" [and \"var\"] nodes)\n    // }\n    this.decls = stringmap();\n\n    // names of all declarations within this scope that was ever written\n    // TODO move to decls.w?\n    // TODO create corresponding read?\n    this.written = stringset();\n\n    // names of all variables declared outside this hoist scope but\n    // referenced in this scope (immediately or in child).\n    // only stored on hoist scopes for efficiency\n    // (because we currently generate lots of empty block scopes)\n    this.propagates = (this.kind === \"hoist\" ? stringset() : null);\n\n    // scopes register themselves with their parents for easier traversal\n    if (this.parent) {\n        this.parent.children.push(this);\n    }\n}\n\nScope.prototype.print = function(indent) {\n    indent = indent || 0;\n    var scope = this;\n    var names = this.decls.keys().map(function(name) {\n        return fmt(\"{0} [{1}]\", name, scope.decls.get(name).kind);\n    }).join(\", \");\n    var propagates = this.propagates ? this.propagates.items().join(\", \") : \"\";\n    console.log(fmt(\"{0}{1}: {2}. propagates: {3}\", fmt.repeat(\" \", indent), this.node.type, names, propagates));\n    this.children.forEach(function(c) {\n        c.print(indent + 2);\n    });\n};\n\nScope.prototype.add = function(name, kind, node, referableFromPos) {\n    assert(is.someof(kind, [\"fun\", \"param\", \"var\", \"caught\", \"const\", \"let\"]));\n\n    function isConstLet(kind) {\n        return is.someof(kind, [\"const\", \"let\"]);\n    }\n\n    var scope = this;\n\n    // search nearest hoist-scope for fun, param and var's\n    // const, let and caught variables go directly in the scope (which may be hoist, block or catch-block)\n    if (is.someof(kind, [\"fun\", \"param\", \"var\"])) {\n        while (scope.kind !== \"hoist\") {\n            if (scope.decls.has(name) && isConstLet(scope.decls.get(name).kind)) { // could be caught\n                return error(getline(node), \"{0} is already declared\", name);\n            }\n            scope = scope.parent;\n        }\n    }\n    // name exists in scope and either new or existing kind is const|let => error\n    if (scope.decls.has(name) && (options.disallowDuplicated || isConstLet(scope.decls.get(name).kind) || isConstLet(kind))) {\n        return error(getline(node), \"{0} is already declared\", name);\n    }\n\n    var declaration = {\n        kind: kind,\n        node: node,\n    };\n    if (referableFromPos) {\n        assert(is.someof(kind, [\"var\", \"const\", \"let\"]));\n        declaration.from = referableFromPos;\n    }\n    scope.decls.set(name, declaration);\n};\n\nScope.prototype.getKind = function(name) {\n    assert(is.string(name));\n    var decl = this.decls.get(name);\n    return decl ? decl.kind : null;\n};\n\nScope.prototype.getNode = function(name) {\n    assert(is.string(name));\n    var decl = this.decls.get(name);\n    return decl ? decl.node : null;\n};\n\nScope.prototype.getFromPos = function(name) {\n    assert(is.string(name));\n    var decl = this.decls.get(name);\n    return decl ? decl.from : null;\n};\n\nScope.prototype.hasOwn = function(name) {\n    return this.decls.has(name);\n};\n\nScope.prototype.remove = function(name) {\n    return this.decls.remove(name);\n};\n\nScope.prototype.doesPropagate = function(name) {\n    return this.propagates.has(name);\n};\n\nScope.prototype.markPropagates = function(name) {\n    this.propagates.add(name);\n};\n\nScope.prototype.closestHoistScope = function() {\n    var scope = this;\n    while (scope.kind !== \"hoist\") {\n        scope = scope.parent;\n    }\n    return scope;\n};\n\nScope.prototype.hasFunctionScopeBetween = function(outer) {\n    function isFunction(node) {\n        return is.someof(node.type, [\"FunctionDeclaration\", \"FunctionExpression\"]);\n    }\n\n    for (var scope = this; scope; scope = scope.parent) {\n        if (scope === outer) {\n            return false;\n        }\n        if (isFunction(scope.node)) {\n            return true;\n        }\n    }\n\n    throw new Error(\"wasn't inner scope of outer\");\n};\n\nScope.prototype.lookup = function(name) {\n    for (var scope = this; scope; scope = scope.parent) {\n        if (scope.decls.has(name)) {\n            return scope;\n        } else if (scope.kind === \"hoist\") {\n            scope.propagates.add(name);\n        }\n    }\n    return null;\n};\n\nScope.prototype.markWrite = function(name) {\n    assert(is.string(name));\n    this.written.add(name);\n};\n\n// detects let variables that are never modified (ignores top-level)\nScope.prototype.detectUnmodifiedLets = function() {\n    var outmost = this;\n\n    function detect(scope) {\n        if (scope !== outmost) {\n            scope.decls.keys().forEach(function(name) {\n                if (scope.getKind(name) === \"let\" && !scope.written.has(name)) {\n                    return error(getline(scope.getNode(name)), \"{0} is declared as let but never modified so could be const\", name);\n                }\n            });\n        }\n\n        scope.children.forEach(function(childScope) {\n            detect(childScope);\n        });\n    }\n    detect(this);\n};\n\nScope.prototype.traverse = function(options) {\n    options = options || {};\n    var pre = options.pre;\n    var post = options.post;\n\n    function visit(scope) {\n        if (pre) {\n            pre(scope);\n        }\n        scope.children.forEach(function(childScope) {\n            visit(childScope);\n        });\n        if (post) {\n            post(scope);\n        }\n    }\n\n    visit(this);\n};\n\nmodule.exports = Scope;\n","\n\nvar fmt = require(\"simple-fmt\");\nvar assert = require(\"assert\");\n\nfunction error(line, var_args) {\n    assert(arguments.length >= 2);\n\n    var msg = (arguments.length === 2 ?\n        String(var_args) : fmt.apply(fmt, Array.prototype.slice.call(arguments, 1)));\n\n    error.errors.push(line === -1 ? msg : fmt(\"line {0}: {1}\", line, msg));\n}\n\nerror.reset = function() {\n    error.errors = [];\n};\n\nerror.getline = function(node) {\n    if (node && node.loc && node.loc.start) {\n        return node.loc.start.line;\n    }\n    return -1;\n};\n\nerror.reset();\n\nmodule.exports = error;\n","// default configuration\n\nmodule.exports = {\n    disallowVars: false,\n    disallowDuplicated: true,\n    disallowUnknownReferences: true,\n    parse: require(\"esprima-fb\").parse,\n};\n","var fmt = require(\"simple-fmt\");\nvar is = require(\"simple-is\");\nvar assert = require(\"assert\");\n\nfunction Stats() {\n    this.lets = 0;\n    this.consts = 0;\n    this.renames = [];\n}\n\nStats.prototype.declarator = function(kind) {\n    assert(is.someof(kind, [\"const\", \"let\"]));\n    if (kind === \"const\") {\n        this.consts++;\n    } else {\n        this.lets++;\n    }\n};\n\nStats.prototype.rename = function(oldName, newName, line) {\n    this.renames.push({\n        oldName: oldName,\n        newName: newName,\n        line: line,\n    });\n};\n\nStats.prototype.toString = function() {\n//    console.log(\"defs.js stats for file {0}:\", filename)\n\n    var renames = this.renames.map(function(r) {\n        return r;\n    }).sort(function(a, b) {\n            return a.line - b.line;\n        }); // sort a copy of renames\n\n    var renameStr = renames.map(function(rename) {\n        return fmt(\"\\nline {0}: {1} => {2}\", rename.line, rename.oldName, rename.newName);\n    }).join(\"\");\n\n    var sum = this.consts + this.lets;\n    var constlets = (sum === 0 ?\n        \"can't calculate const coverage (0 consts, 0 lets)\" :\n        fmt(\"{0}% const coverage ({1} consts, {2} lets)\",\n            Math.floor(100 * this.consts / sum), this.consts, this.lets));\n\n    return constlets + renameStr + \"\\n\";\n};\n\nmodule.exports = Stats;\n","// jshint -W001\n\n\n\n// Identifiers provided by the ECMAScript standard.\n\nexports.reservedVars = {\n\targuments : false,\n\tNaN       : false\n};\n\nexports.ecmaIdentifiers = {\n\tArray              : false,\n\tBoolean            : false,\n\tDate               : false,\n\tdecodeURI          : false,\n\tdecodeURIComponent : false,\n\tencodeURI          : false,\n\tencodeURIComponent : false,\n\tError              : false,\n\t\"eval\"             : false,\n\tEvalError          : false,\n\tFunction           : false,\n\thasOwnProperty     : false,\n\tisFinite           : false,\n\tisNaN              : false,\n\tJSON               : false,\n\tMath               : false,\n\tMap                : false,\n\tNumber             : false,\n\tObject             : false,\n\tparseInt           : false,\n\tparseFloat         : false,\n\tRangeError         : false,\n\tReferenceError     : false,\n\tRegExp             : false,\n\tSet                : false,\n\tString             : false,\n\tSyntaxError        : false,\n\tTypeError          : false,\n\tURIError           : false,\n\tWeakMap            : false\n};\n\n// Global variables commonly provided by a web browser environment.\n\nexports.browser = {\n\tArrayBuffer          : false,\n\tArrayBufferView      : false,\n\tAudio                : false,\n\tBlob                 : false,\n\taddEventListener     : false,\n\tapplicationCache     : false,\n\tatob                 : false,\n\tblur                 : false,\n\tbtoa                 : false,\n\tclearInterval        : false,\n\tclearTimeout         : false,\n\tclose                : false,\n\tclosed               : false,\n\tDataView             : false,\n\tDOMParser            : false,\n\tdefaultStatus        : false,\n\tdocument             : false,\n\tElement              : false,\n\tevent                : false,\n\tFileReader           : false,\n\tFloat32Array         : false,\n\tFloat64Array         : false,\n\tFormData             : false,\n\tfocus                : false,\n\tframes               : false,\n\tgetComputedStyle     : false,\n\tHTMLElement          : false,\n\tHTMLAnchorElement    : false,\n\tHTMLBaseElement      : false,\n\tHTMLBlockquoteElement: false,\n\tHTMLBodyElement      : false,\n\tHTMLBRElement        : false,\n\tHTMLButtonElement    : false,\n\tHTMLCanvasElement    : false,\n\tHTMLDirectoryElement : false,\n\tHTMLDivElement       : false,\n\tHTMLDListElement     : false,\n\tHTMLFieldSetElement  : false,\n\tHTMLFontElement      : false,\n\tHTMLFormElement      : false,\n\tHTMLFrameElement     : false,\n\tHTMLFrameSetElement  : false,\n\tHTMLHeadElement      : false,\n\tHTMLHeadingElement   : false,\n\tHTMLHRElement        : false,\n\tHTMLHtmlElement      : false,\n\tHTMLIFrameElement    : false,\n\tHTMLImageElement     : false,\n\tHTMLInputElement     : false,\n\tHTMLIsIndexElement   : false,\n\tHTMLLabelElement     : false,\n\tHTMLLayerElement     : false,\n\tHTMLLegendElement    : false,\n\tHTMLLIElement        : false,\n\tHTMLLinkElement      : false,\n\tHTMLMapElement       : false,\n\tHTMLMenuElement      : false,\n\tHTMLMetaElement      : false,\n\tHTMLModElement       : false,\n\tHTMLObjectElement    : false,\n\tHTMLOListElement     : false,\n\tHTMLOptGroupElement  : false,\n\tHTMLOptionElement    : false,\n\tHTMLParagraphElement : false,\n\tHTMLParamElement     : false,\n\tHTMLPreElement       : false,\n\tHTMLQuoteElement     : false,\n\tHTMLScriptElement    : false,\n\tHTMLSelectElement    : false,\n\tHTMLStyleElement     : false,\n\tHTMLTableCaptionElement: false,\n\tHTMLTableCellElement : false,\n\tHTMLTableColElement  : false,\n\tHTMLTableElement     : false,\n\tHTMLTableRowElement  : false,\n\tHTMLTableSectionElement: false,\n\tHTMLTextAreaElement  : false,\n\tHTMLTitleElement     : false,\n\tHTMLUListElement     : false,\n\tHTMLVideoElement     : false,\n\thistory              : false,\n\tInt16Array           : false,\n\tInt32Array           : false,\n\tInt8Array            : false,\n\tImage                : false,\n\tlength               : false,\n\tlocalStorage         : false,\n\tlocation             : false,\n\tMessageChannel       : false,\n\tMessageEvent         : false,\n\tMessagePort          : false,\n\tmoveBy               : false,\n\tmoveTo               : false,\n\tMutationObserver     : false,\n\tname                 : false,\n\tNode                 : false,\n\tNodeFilter           : false,\n\tnavigator            : false,\n\tonbeforeunload       : true,\n\tonblur               : true,\n\tonerror              : true,\n\tonfocus              : true,\n\tonload               : true,\n\tonresize             : true,\n\tonunload             : true,\n\topen                 : false,\n\topenDatabase         : false,\n\topener               : false,\n\tOption               : false,\n\tparent               : false,\n\tprint                : false,\n\tremoveEventListener  : false,\n\tresizeBy             : false,\n\tresizeTo             : false,\n\tscreen               : false,\n\tscroll               : false,\n\tscrollBy             : false,\n\tscrollTo             : false,\n\tsessionStorage       : false,\n\tsetInterval          : false,\n\tsetTimeout           : false,\n\tSharedWorker         : false,\n\tstatus               : false,\n\ttop                  : false,\n\tUint16Array          : false,\n\tUint32Array          : false,\n\tUint8Array           : false,\n\tUint8ClampedArray    : false,\n\tWebSocket            : false,\n\twindow               : false,\n\tWorker               : false,\n\tXMLHttpRequest       : false,\n\tXMLSerializer        : false,\n\tXPathEvaluator       : false,\n\tXPathException       : false,\n\tXPathExpression      : false,\n\tXPathNamespace       : false,\n\tXPathNSResolver      : false,\n\tXPathResult          : false\n};\n\nexports.devel = {\n\talert  : false,\n\tconfirm: false,\n\tconsole: false,\n\tDebug  : false,\n\topera  : false,\n\tprompt : false\n};\n\nexports.worker = {\n\timportScripts: true,\n\tpostMessage  : true,\n\tself         : true\n};\n\n// Widely adopted global names that are not part of ECMAScript standard\nexports.nonstandard = {\n\tescape  : false,\n\tunescape: false\n};\n\n// Globals provided by popular JavaScript environments.\n\nexports.couch = {\n\t\"require\" : false,\n\trespond   : false,\n\tgetRow    : false,\n\temit      : false,\n\tsend      : false,\n\tstart     : false,\n\tsum       : false,\n\tlog       : false,\n\texports   : false,\n\tmodule    : false,\n\tprovides  : false\n};\n\nexports.node = {\n\t__filename   : false,\n\t__dirname    : false,\n\tBuffer       : false,\n\tDataView     : false,\n\tconsole      : false,\n\texports      : true,  // In Node it is ok to exports = module.exports = foo();\n\tGLOBAL       : false,\n\tglobal       : false,\n\tmodule       : false,\n\tprocess      : false,\n\trequire      : false,\n\tsetTimeout   : false,\n\tclearTimeout : false,\n\tsetInterval  : false,\n\tclearInterval: false\n};\n\nexports.phantom = {\n\tphantom      : true,\n\trequire      : true,\n\tWebPage      : true\n};\n\nexports.rhino = {\n\tdefineClass  : false,\n\tdeserialize  : false,\n\tgc           : false,\n\thelp         : false,\n\timportPackage: false,\n\t\"java\"       : false,\n\tload         : false,\n\tloadClass    : false,\n\tprint        : false,\n\tquit         : false,\n\treadFile     : false,\n\treadUrl      : false,\n\trunCommand   : false,\n\tseal         : false,\n\tserialize    : false,\n\tspawn        : false,\n\tsync         : false,\n\ttoint32      : false,\n\tversion      : false\n};\n\nexports.wsh = {\n\tActiveXObject            : true,\n\tEnumerator               : true,\n\tGetObject                : true,\n\tScriptEngine             : true,\n\tScriptEngineBuildVersion : true,\n\tScriptEngineMajorVersion : true,\n\tScriptEngineMinorVersion : true,\n\tVBArray                  : true,\n\tWSH                      : true,\n\tWScript                  : true,\n\tXDomainRequest           : true\n};\n\n// Globals provided by popular JavaScript libraries.\n\nexports.dojo = {\n\tdojo     : false,\n\tdijit    : false,\n\tdojox    : false,\n\tdefine\t : false,\n\t\"require\": false\n};\n\nexports.jquery = {\n\t\"$\"    : false,\n\tjQuery : false\n};\n\nexports.mootools = {\n\t\"$\"           : false,\n\t\"$$\"          : false,\n\tAsset         : false,\n\tBrowser       : false,\n\tChain         : false,\n\tClass         : false,\n\tColor         : false,\n\tCookie        : false,\n\tCore          : false,\n\tDocument      : false,\n\tDomReady      : false,\n\tDOMEvent      : false,\n\tDOMReady      : false,\n\tDrag          : false,\n\tElement       : false,\n\tElements      : false,\n\tEvent         : false,\n\tEvents        : false,\n\tFx            : false,\n\tGroup         : false,\n\tHash          : false,\n\tHtmlTable     : false,\n\tIframe        : false,\n\tIframeShim    : false,\n\tInputValidator: false,\n\tinstanceOf    : false,\n\tKeyboard      : false,\n\tLocale        : false,\n\tMask          : false,\n\tMooTools      : false,\n\tNative        : false,\n\tOptions       : false,\n\tOverText      : false,\n\tRequest       : false,\n\tScroller      : false,\n\tSlick         : false,\n\tSlider        : false,\n\tSortables     : false,\n\tSpinner       : false,\n\tSwiff         : false,\n\tTips          : false,\n\tType          : false,\n\ttypeOf        : false,\n\tURI           : false,\n\tWindow        : false\n};\n\nexports.prototypejs = {\n\t\"$\"               : false,\n\t\"$$\"              : false,\n\t\"$A\"              : false,\n\t\"$F\"              : false,\n\t\"$H\"              : false,\n\t\"$R\"              : false,\n\t\"$break\"          : false,\n\t\"$continue\"       : false,\n\t\"$w\"              : false,\n\tAbstract          : false,\n\tAjax              : false,\n\tClass             : false,\n\tEnumerable        : false,\n\tElement           : false,\n\tEvent             : false,\n\tField             : false,\n\tForm              : false,\n\tHash              : false,\n\tInsertion         : false,\n\tObjectRange       : false,\n\tPeriodicalExecuter: false,\n\tPosition          : false,\n\tPrototype         : false,\n\tSelector          : false,\n\tTemplate          : false,\n\tToggle            : false,\n\tTry               : false,\n\tAutocompleter     : false,\n\tBuilder           : false,\n\tControl           : false,\n\tDraggable         : false,\n\tDraggables        : false,\n\tDroppables        : false,\n\tEffect            : false,\n\tSortable          : false,\n\tSortableObserver  : false,\n\tSound             : false,\n\tScriptaculous     : false\n};\n\nexports.yui = {\n\tYUI       : false,\n\tY         : false,\n\tYUI_config: false\n};\n\n"]}