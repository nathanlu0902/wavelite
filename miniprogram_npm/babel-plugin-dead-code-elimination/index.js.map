{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports[\"default\"] = function (_ref) {\n  var Plugin = _ref.Plugin;\n  var t = _ref.types;\n\n  function toStatements(node) {\n    if (t.isBlockStatement(node)) {\n      var hasBlockScoped = false;\n\n      for (var i = 0; i < node.body.length; i++) {\n        var bodyNode = node.body[i];\n        if (t.isBlockScoped(bodyNode)) hasBlockScoped = true;\n      }\n\n      if (!hasBlockScoped) {\n        return node.body;\n      }\n    }\n\n    return node;\n  }\n\n  var visitor = {\n    ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope) {\n      var binding = scope.getBinding(node.name);\n      if (!binding || binding.references > 1 || !binding.constant) return;\n      if (binding.kind === \"param\" || binding.kind === \"module\") return;\n\n      var replacement = binding.path.node;\n      if (t.isVariableDeclarator(replacement)) {\n        replacement = replacement.init;\n      }\n      if (!replacement) return;\n\n      // ensure it's a \"pure\" type\n      if (!scope.isPure(replacement, true)) return;\n\n      if (t.isClass(replacement) || t.isFunction(replacement)) {\n        // don't change this if it's in a different scope, this can be bad\n        // for performance since it may be inside a loop or deeply nested in\n        // hot code\n        if (binding.path.scope.parent !== scope) return;\n      }\n\n      if (this.findParent(function (path) {\n        return path.node === replacement;\n      })) {\n        return;\n      }\n\n      t.toExpression(replacement);\n      scope.removeBinding(node.name);\n      binding.path.dangerouslyRemove();\n      return replacement;\n    },\n\n    \"ClassDeclaration|FunctionDeclaration\": function ClassDeclarationFunctionDeclaration(node, parent, scope) {\n      var binding = scope.getBinding(node.id.name);\n      if (binding && !binding.referenced) {\n        this.dangerouslyRemove();\n      }\n    },\n\n    VariableDeclarator: function VariableDeclarator(node, parent, scope) {\n      if (!t.isIdentifier(node.id) || !scope.isPure(node.init, true)) return;\n      visitor[\"ClassDeclaration|FunctionDeclaration\"].apply(this, arguments);\n    },\n\n    ConditionalExpression: function ConditionalExpression(node) {\n      var evaluateTest = this.get(\"test\").evaluateTruthy();\n      if (evaluateTest === true) {\n        return node.consequent;\n      } else if (evaluateTest === false) {\n        return node.alternate;\n      }\n    },\n\n    BlockStatement: function BlockStatement() {\n      var paths = this.get(\"body\");\n\n      var purge = false;\n\n      for (var i = 0; i < paths.length; i++) {\n        var path = paths[i];\n\n        if (!purge && path.isCompletionStatement()) {\n          purge = true;\n          continue;\n        }\n\n        if (purge && !path.isFunctionDeclaration()) {\n          path.dangerouslyRemove();\n        }\n      }\n    },\n\n    IfStatement: {\n      exit: function exit(node) {\n        var consequent = node.consequent;\n        var alternate = node.alternate;\n        var test = node.test;\n\n        var evaluateTest = this.get(\"test\").evaluateTruthy();\n\n        // we can check if a test will be truthy 100% and if so then we can inline\n        // the consequent and completely ignore the alternate\n        //\n        //   if (true) { foo; } -> { foo; }\n        //   if (\"foo\") { foo; } -> { foo; }\n        //\n\n        if (evaluateTest === true) {\n          return toStatements(consequent);\n        }\n\n        // we can check if a test will be falsy 100% and if so we can inline the\n        // alternate if there is one and completely remove the consequent\n        //\n        //   if (\"\") { bar; } else { foo; } -> { foo; }\n        //   if (\"\") { bar; } ->\n        //\n\n        if (evaluateTest === false) {\n          if (alternate) {\n            return toStatements(alternate);\n          } else {\n            return this.dangerouslyRemove();\n          }\n        }\n\n        // remove alternate blocks that are empty\n        //\n        //   if (foo) { foo; } else {} -> if (foo) { foo; }\n        //\n\n        if (t.isBlockStatement(alternate) && !alternate.body.length) {\n          alternate = node.alternate = null;\n        }\n\n        // if the consequent block is empty turn alternate blocks into a consequent\n        // and flip the test\n        //\n        //   if (foo) {} else { bar; } -> if (!foo) { bar; }\n        //\n\n        if (t.isBlockStatement(consequent) && !consequent.body.length && t.isBlockStatement(alternate) && alternate.body.length) {\n          node.consequent = node.alternate;\n          node.alternate = null;\n          node.test = t.unaryExpression(\"!\", test, true);\n        }\n      }\n    }\n  };\n\n  return new Plugin(\"dead-code-elimination\", {\n    metadata: {\n      group: \"builtin-pre\",\n      experimental: true\n    },\n\n    visitor: visitor\n  });\n};\n\nmodule.exports = exports[\"default\"];"]}