{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports[\"default\"] = function (_ref) {\n  var Plugin = _ref.Plugin;\n  var t = _ref.types;\n\n  return new Plugin(\"constant-folding\", {\n    metadata: {\n      group: \"builtin-prepass\",\n      experimental: true\n    },\n\n    visitor: {\n      AssignmentExpression: function AssignmentExpression() {\n        var left = this.get(\"left\");\n        if (!left.isIdentifier()) return;\n\n        var binding = this.scope.getBinding(left.node.name);\n        if (!binding || binding.hasDeoptValue) return;\n\n        var evaluated = this.get(\"right\").evaluate();\n        if (evaluated.confident) {\n          binding.setValue(evaluated.value);\n        } else {\n          binding.deoptValue();\n        }\n      },\n\n      IfStatement: function IfStatement() {\n        var evaluated = this.get(\"test\").evaluate();\n        if (!evaluated.confident) {\n          // todo: deopt binding values for constant violations inside\n          return this.skip();\n        }\n\n        if (evaluated.value) {\n          this.skipKey(\"alternate\");\n        } else {\n          this.skipKey(\"consequent\");\n        }\n      },\n\n      Scopable: {\n        enter: function enter() {\n          var funcScope = this.scope.getFunctionParent();\n\n          for (var name in this.scope.bindings) {\n            var binding = this.scope.bindings[name];\n            var deopt = false;\n\n            var _iteratorNormalCompletion = true;\n            var _didIteratorError = false;\n            var _iteratorError = undefined;\n\n            try {\n              for (var _iterator = binding.constantViolations[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                var path = _step.value;\n\n                var funcViolationScope = path.scope.getFunctionParent();\n                if (funcViolationScope !== funcScope) {\n                  deopt = true;\n                  break;\n                }\n              }\n            } catch (err) {\n              _didIteratorError = true;\n              _iteratorError = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion && _iterator[\"return\"]) {\n                  _iterator[\"return\"]();\n                }\n              } finally {\n                if (_didIteratorError) {\n                  throw _iteratorError;\n                }\n              }\n            }\n\n            if (deopt) binding.deoptValue();\n          }\n        },\n\n        exit: function exit() {\n          for (var name in this.scope.bindings) {\n            var binding = this.scope.bindings[name];\n            binding.clearValue();\n          }\n        }\n      },\n\n      Expression: {\n        exit: function exit() {\n          var res = this.evaluate();\n          if (res.confident) return t.valueToNode(res.value);\n        }\n      }\n    }\n  });\n};\n\nmodule.exports = exports[\"default\"];"]}