{"version":3,"sources":["index.js","lib/api/node.js","lib/transformation/index.js","lib/transformation/pipeline.js","lib/transformation/file/plugin-manager.js","lib/transformation/transformer.js","lib/transformation/plugin.js","lib/transformation/plugin-pass.js","lib/traversal/index.js","lib/traversal/context.js","lib/traversal/path/index.js","lib/traversal/path/lib/virtual-types.js","lib/transformation/helpers/react.js","lib/types/index.js","lib/types/definitions/init.js","lib/types/definitions/index.js","lib/types/definitions/core.js","lib/types/definitions/es2015.js","lib/types/definitions/flow.js","lib/types/definitions/jsx.js","lib/types/definitions/misc.js","lib/types/definitions/experimental.js","lib/types/retrievers.js","lib/types/validators.js","lib/types/converters.js","lib/types/flow.js","lib/traversal/scope/index.js","lib/messages.js","lib/util.js","lib/helpers/parse.js","templates.json","lib/traversal/scope/binding.js","lib/helpers/object.js","lib/traversal/path/ancestry.js","lib/traversal/path/inference/index.js","lib/traversal/path/inference/inferers.js","lib/traversal/path/inference/inferer-reference.js","lib/traversal/path/replacement.js","lib/helpers/code-frame.js","lib/traversal/path/evaluation.js","lib/traversal/path/conversion.js","lib/traversal/path/introspection.js","lib/traversal/path/context.js","lib/traversal/path/removal.js","lib/traversal/path/lib/removal-hooks.js","lib/traversal/path/modification.js","lib/traversal/path/lib/hoister.js","lib/traversal/path/family.js","lib/traversal/path/comments.js","lib/traversal/visitors.js","lib/transformation/file/index.js","lib/transformation/modules/index.js","lib/transformation/modules/common-strict.js","lib/transformation/modules/common.js","lib/transformation/modules/_default.js","lib/transformation/modules/lib/metadata.js","lib/transformation/modules/lib/remaps.js","lib/transformation/modules/_strict.js","lib/transformation/modules/amd-strict.js","lib/transformation/modules/amd.js","lib/transformation/modules/umd-strict.js","lib/transformation/modules/umd.js","lib/transformation/modules/system.js","lib/transformation/modules/ignore.js","lib/transformation/file/options/option-manager.js","lib/transformation/file/options/index.js","lib/transformation/file/options/parsers.js","lib/helpers/merge.js","lib/generation/index.js","lib/generation/whitespace.js","lib/generation/node/printer.js","lib/generation/source-map.js","lib/generation/position.js","lib/generation/buffer.js","lib/generation/node/index.js","lib/generation/node/whitespace.js","lib/generation/node/parentheses.js","lib/generation/generators/template-literals.js","lib/generation/generators/comprehensions.js","lib/generation/generators/expressions.js","lib/generation/generators/statements.js","lib/generation/generators/classes.js","lib/generation/generators/methods.js","lib/generation/generators/modules.js","lib/generation/generators/types.js","lib/generation/generators/flow.js","lib/generation/generators/base.js","lib/generation/generators/jsx.js","lib/transformation/file/logger.js","lib/traversal/hub.js","lib/helpers/normalize-ast.js","lib/transformation/transformers/index.js","lib/transformation/transformers/other/strict.js","lib/transformation/transformers/internal/validation.js","lib/transformation/transformers/internal/hoist-directives.js","lib/transformation/transformers/internal/modules.js","lib/transformation/transformers/es6/spec.modules.js","lib/transformation/transformers/es6/spec.arrow-functions.js","lib/transformation/transformers/es6/spec.template-literals.js","lib/transformation/transformers/es6/template-literals.js","lib/transformation/transformers/es6/literals.js","lib/transformation/transformers/spec/function-name.js","lib/transformation/helpers/name-method.js","lib/transformation/helpers/get-function-arity.js","lib/transformation/transformers/es7/class-properties.js","lib/transformation/transformers/es7/trailing-function-commas.js","lib/transformation/transformers/es7/async-functions.js","lib/transformation/transformers/es7/decorators.js","lib/transformation/helpers/memoise-decorators.js","lib/transformation/helpers/define-map.js","lib/transformation/transformers/validation/react.js","lib/transformation/transformers/es6/arrow-functions.js","lib/transformation/transformers/spec/block-scoped-functions.js","lib/transformation/transformers/optimisation/react.inline-elements.js","lib/transformation/transformers/es7/comprehensions.js","lib/transformation/helpers/build-comprehension.js","lib/transformation/transformers/es6/classes/index.js","lib/transformation/transformers/es6/classes/loose.js","lib/transformation/transformers/es6/classes/vanilla.js","lib/transformation/helpers/replace-supers.js","lib/transformation/transformers/other/async-to-generator.js","lib/transformation/helpers/remap-async-to-generator.js","lib/transformation/transformers/other/bluebird-coroutines.js","lib/transformation/transformers/es6/object-super.js","lib/transformation/transformers/es7/object-rest-spread.js","lib/transformation/transformers/es7/exponentiation-operator.js","lib/transformation/helpers/build-binary-assignment-operator-transformer.js","lib/transformation/helpers/explode-assignable-expression.js","lib/transformation/transformers/es5/properties.mutators.js","lib/transformation/transformers/es6/properties.shorthand.js","lib/transformation/transformers/es6/properties.computed.js","lib/transformation/transformers/optimisation/flow.for-of.js","lib/transformation/transformers/es6/for-of.js","lib/transformation/transformers/es6/regex.sticky.js","lib/transformation/helpers/regex.js","lib/transformation/transformers/es6/regex.unicode.js","lib/transformation/transformers/es6/constants.js","lib/transformation/transformers/es7/export-extensions.js","lib/transformation/transformers/es7/do-expressions.js","lib/transformation/transformers/es6/spec.symbols.js","lib/transformation/transformers/es7/function-bind.js","lib/transformation/transformers/es6/spread.js","lib/transformation/transformers/es6/parameters/index.js","lib/transformation/transformers/es6/parameters/default.js","lib/transformation/helpers/call-delegate.js","lib/transformation/transformers/es6/parameters/rest.js","lib/transformation/transformers/es6/destructuring.js","lib/transformation/transformers/es6/block-scoping.js","lib/transformation/transformers/es6/spec.block-scoping.js","lib/transformation/transformers/other/react-compat.js","lib/transformation/helpers/build-react-transformer.js","lib/transformation/transformers/other/react.js","lib/transformation/transformers/other/regenerator.js","lib/transformation/transformers/es6/modules.js","lib/transformation/transformers/internal/module-formatter.js","lib/transformation/transformers/es6/tail-call.js","lib/transformation/transformers/internal/shadow-functions.js","lib/transformation/transformers/es3/property-literals.js","lib/transformation/transformers/es3/member-expression-literals.js","lib/transformation/transformers/internal/block-hoist.js","lib/transformation/transformers/other/flow.js","lib/transformation/transformers/optimisation/modules.system.js","lib/transformation/transformers/filters.js","lib/tools/build-external-helpers.js","lib/api/register/node-polyfill.js","lib/polyfill.js","lib/api/register/node.js","lib/api/register/cache.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;;ACDA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA,AENA;AJaA,AGTA,AFMA,ACHA,AENA;AJaA,AGTA,AFMA,ACHA,AENA;AJaA,AGTA,AFMA,ACHA,AGTA,ADGA;AJaA,AGTA,AFMA,ACHA,AGTA,ADGA;AJaA,AGTA,AFMA,ACHA,AGTA,ADGA;AJaA,AGTA,AFMA,ACHA,AIZA,ADGA,ADGA;AJaA,AGTA,AFMA,ACHA,AIZA,ADGA,ADGA;AJaA,AGTA,AFMA,ACHA,AIZA,ADGA,ADGA;AJaA,AGTA,AFMA,ACHA,AIZA,ADGA,ADGA,AGTA;APsBA,AGTA,AFMA,ACHA,AIZA,ADGA,ADGA,AGTA;APsBA,AGTA,AFMA,ACHA,AIZA,ADGA,ADGA,AGTA;APsBA,AGTA,AFMA,ACHA,AIZA,ADGA,ADGA,AIZA,ADGA;APsBA,AGTA,AFMA,ACHA,AIZA,ADGA,ADGA,AIZA,ADGA;APsBA,AGTA,AFMA,ACHA,AIZA,ADGA,ADGA,AIZA,ADGA;APsBA,AGTA,AFMA,ACHA,AIZA,ADGA,ADGA,AIZA,ADGA,AENA;AT4BA,AGTA,AFMA,ACHA,AIZA,ADGA,ADGA,AIZA,ADGA,AENA;AT4BA,AGTA,AFMA,ACHA,AIZA,ADGA,ADGA,AIZA,ADGA,AENA;AT4BA,AGTA,AFMA,ACHA,AIZA,ADGA,ADGA,AIZA,ADGA,AENA,ACHA;AV+BA,AGTA,AFMA,ACHA,AIZA,ADGA,ADGA,AIZA,ADGA,AENA,ACHA;AV+BA,AGTA,AFMA,ACHA,AIZA,ADGA,ADGA,AIZA,ADGA,AENA,ACHA;AV+BA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,ADGA,AIZA,ADGA,AENA,ACHA;AV+BA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,ADGA,AIZA,ADGA,AENA,ACHA;AV+BA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,ADGA,AIZA,ADGA,AENA,ACHA;AV+BA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,ADGA,AIZA,ADGA,AENA,ACHA,AENA;AZqCA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,ADGA,AIZA,ADGA,AENA,ACHA,AENA;AZqCA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,ADGA,AIZA,ADGA,AENA,ACHA,AENA;AZqCA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,ADGA,AIZA,ADGA,AENA,ACHA,AGTA,ADGA;AZqCA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,ADGA,AIZA,ADGA,AENA,ACHA,AGTA,ADGA;AZqCA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,ADGA,AIZA,ADGA,AENA,ACHA,AGTA,ADGA;AZqCA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,ADGA,AIZA,ADGA,AENA,ACHA,AIZA,ADGA,ADGA;AZqCA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,ADGA,AIZA,ADGA,AENA,ACHA,AIZA,ADGA,ADGA;AZqCA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,ADGA,AIZA,ADGA,AENA,ACHA,AIZA,ADGA,ADGA;AZqCA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,ADGA,AIZA,ADGA,AENA,ACHA,AKfA,ADGA,ADGA,ADGA;AZqCA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,AGTA,ADGA,AENA,ACHA,AKfA,ADGA,ADGA,ADGA;AZqCA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,AGTA,ADGA,AENA,ACHA,AKfA,ADGA,ADGA,ADGA;AZqCA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,AGTA,ADGA,AENA,ACHA,AKfA,ACHA,AFMA,ADGA,ADGA;AZqCA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,AGTA,ADGA,AENA,ACHA,AKfA,ACHA,AFMA,ADGA,ADGA;AZqCA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,AGTA,ADGA,AENA,ACHA,AKfA,ACHA,AFMA,ADGA,ADGA;AZqCA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,AGTA,ADGA,AENA,ACHA,AKfA,ACHA,ACHA,AHSA,ADGA,ADGA;AZqCA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,AGTA,ADGA,AENA,ACHA,AKfA,ACHA,ACHA,AHSA,ADGA,ADGA;AZqCA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,AGTA,ADGA,AENA,ACHA,AKfA,ACHA,ACHA,AHSA,ADGA,ADGA;AZqCA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,AGTA,ADGA,AENA,ACHA,AKfA,ACHA,ACHA,AHSA,AIZA,ANkBA;AZqCA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,AGTA,ADGA,AENA,ACHA,AKfA,ACHA,ACHA,AHSA,AIZA,ANkBA;AZqCA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,AGTA,ADGA,AENA,ACHA,AKfA,ACHA,ACHA,AHSA,AIZA,ANkBA;AZqCA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,AGTA,ADGA,AENA,ACHA,AKfA,ACHA,ACHA,AHSA,AIZA,ACHA,APqBA;AZqCA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,AGTA,ADGA,AENA,ACHA,AKfA,ACHA,ACHA,AHSA,AIZA,ACHA,APqBA;AZqCA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,AGTA,ADGA,AENA,ACHA,AKfA,ACHA,ACHA,AHSA,AIZA,ACHA,APqBA;AZqCA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,AGTA,ADGA,AENA,ACHA,AKfA,ACHA,AIZA,AHSA,AHSA,AIZA,ACHA,APqBA;AZqCA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,AGTA,ADGA,AENA,ACHA,AKfA,ACHA,AIZA,AHSA,AHSA,AIZA,ACHA,APqBA;AZqCA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,AGTA,ADGA,AENA,ACHA,AKfA,ACHA,AIZA,AHSA,AHSA,AIZA,ACHA,APqBA;AZqCA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,AGTA,ADGA,AENA,ACHA,AKfA,ACHA,AIZA,AHSA,AHSA,AIZA,ACHA,APqBA,AS3BA;ArBgEA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,AGTA,ADGA,AENA,ACHA,AKfA,ACHA,AIZA,AHSA,AHSA,AIZA,ACHA,APqBA,AS3BA;ArBgEA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,AGTA,ADGA,AENA,ACHA,AKfA,ACHA,AIZA,AHSA,AHSA,AIZA,ACHA,APqBA,AS3BA;ArBgEA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,AGTA,ADGA,AENA,ACHA,AKfA,ACHA,AIZA,AHSA,AHSA,AIZA,ACHA,APqBA,AS3BA,ACHA;AtBmEA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,AGTA,ADGA,AENA,ACHA,AKfA,ACHA,AIZA,AHSA,AHSA,AIZA,ACHA,APqBA,AS3BA,ACHA;AtBmEA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,AGTA,ADGA,AENA,ACHA,AKfA,ACHA,AIZA,AHSA,AHSA,AIZA,ACHA,APqBA,AS3BA,ACHA;AtBmEA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,AGTA,ADGA,AENA,ACHA,AavCA,ARwBA,ACHA,AIZA,AHSA,AHSA,AIZA,ACHA,APqBA,AS3BA,ACHA;AtBmEA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,AGTA,ADGA,AENA,ACHA,AavCA,ARwBA,ACHA,AIZA,AHSA,AHSA,AIZA,ACHA,APqBA,AS3BA,ACHA;AtBmEA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,AGTA,ADGA,AENA,ACHA,AavCA,ARwBA,ACHA,AIZA,AHSA,AHSA,AIZA,ACHA,APqBA,AS3BA,ACHA;AtBmEA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,AGTA,ADGA,AENA,ACHA,AavCA,ARwBA,ACHA,AIZA,AHSA,AHSA,AIZA,ACHA,AKfA,AZoCA,AS3BA,ACHA;AtBmEA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,AGTA,ADGA,AENA,ACHA,AavCA,ARwBA,ACHA,AIZA,AHSA,AHSA,AIZA,ACHA,AKfA,AZoCA,AS3BA,ACHA;AtBmEA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,AGTA,ADGA,AENA,ACHA,AavCA,ARwBA,ACHA,AIZA,AHSA,ACHA,ACHA,AKfA,AZoCA,AS3BA,ACHA;AtBmEA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,AGTA,ADGA,AENA,ACHA,Ae7CA,AFMA,ARwBA,ACHA,AIZA,AHSA,ACHA,AMlBA,AZoCA,AS3BA,ACHA;AtBmEA,AGTA,AQxBA,AV8BA,ACHA,AIZA,ADGA,AGTA,ADGA,AENA,ACHA,Ae7CA,AFMA,ARwBA,ACHA,AIZA,AHSA,ACHA,AMlBA,AZoCA,AS3BA,ACHA;AtBmEA,AGTA,AQxBA,AV8BA,ACHA,AGTA,AGTA,ADGA,AENA,ACHA,Ae7CA,AFMA,ARwBA,ACHA,AIZA,AHSA,ACHA,AMlBA,AZoCA,AS3BA,ACHA;AtBmEA,A0B9EA,AvBqEA,AQxBA,AV8BA,ACHA,AGTA,AGTA,ADGA,AENA,ACHA,Ae7CA,AFMA,ARwBA,ACHA,AIZA,AHSA,ACHA,AMlBA,AZoCA,AS3BA,ACHA;AtBmEA,A0B9EA,AvBqEA,AQxBA,AV8BA,ACHA,AGTA,AGTA,ADGA,AENA,ACHA,Ae7CA,AFMA,ARwBA,ACHA,AIZA,AHSA,ACHA,AMlBA,AZoCA,AS3BA,ACHA;AtBmEA,A0B9EA,AvBqEA,AQxBA,AV8BA,ACHA,AGTA,AGTA,ADGA,AENA,ACHA,Ae7CA,AFMA,ARwBA,ACHA,AIZA,AHSA,ACHA,AMlBA,AZoCA,AS3BA,ACHA;AtBmEA,A0B9EA,AvBqEA,AQxBA,AV8BA,ACHA,AGTA,AGTA,ADGA,AENA,ACHA,Ae7CA,AFMA,ARwBA,ACHA,AIZA,AHSA,ACHA,AMlBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,A0B9EA,AvBqEA,AQxBA,AV8BA,ACHA,AGTA,AGTA,ADGA,AENA,ACHA,Ae7CA,AFMA,ARwBA,ACHA,AIZA,AHSA,ACHA,AMlBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,A0B9EA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AENA,ACHA,Ae7CA,AFMA,ARwBA,ACHA,AIZA,AHSA,ACHA,AMlBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,A4BpFA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AENA,ACHA,Ae7CA,AFMA,ARwBA,ACHA,AIZA,AHSA,ACHA,AMlBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,A4BpFA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AENA,ACHA,Ae7CA,AFMA,ARwBA,ACHA,AIZA,AHSA,ACHA,AMlBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,A4BpFA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AENA,ACHA,Ae7CA,AFMA,ARwBA,ACHA,AIZA,AHSA,ACHA,AMlBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,A4BpFA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AENA,ACHA,Ae7CA,AFMA,ARwBA,ACHA,AIZA,AHSA,ACHA,AMlBA,AZoCA,AS3BA,ACHA,AKfA,AENA;A7BwFA,A4BpFA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AENA,ACHA,Ae7CA,AFMA,ARwBA,ACHA,AIZA,AHSA,ACHA,AMlBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,A4BpFA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AENA,ACHA,Ae7CA,AFMA,ARwBA,ACHA,AIZA,AHSA,ACHA,AMlBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,A4BpFA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AENA,ACHA,AoB5DA,ALeA,AFMA,ARwBA,ACHA,AIZA,AHSA,ACHA,AMlBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,A4BpFA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AENA,ACHA,AoB5DA,ALeA,AFMA,ARwBA,ACHA,AIZA,AHSA,ACHA,AMlBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,A4BpFA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AENA,ACHA,AoB5DA,ALeA,AFMA,ARwBA,ACHA,AIZA,AHSA,ACHA,AMlBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,A+B7FA,AHSA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AENA,ACHA,AoB5DA,ALeA,AFMA,ARwBA,ACHA,AIZA,AHSA,ACHA,AMlBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,A+B7FA,AHSA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AENA,ACHA,AoB5DA,ALeA,AFMA,ARwBA,ACHA,AIZA,AHSA,ACHA,AMlBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,A+B7FA,AHSA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AENA,ACHA,AoB5DA,ALeA,AFMA,ARwBA,ACHA,AIZA,AHSA,ACHA,AMlBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,A+B7FA,AHSA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AyB3EA,AvBqEA,ACHA,AoB5DA,ALeA,AFMA,ARwBA,ACHA,AIZA,AHSA,ACHA,AMlBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,A+B7FA,AHSA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AyB3EA,AvBqEA,ACHA,AoB5DA,ALeA,AFMA,ARwBA,ACHA,AIZA,AHSA,ACHA,AMlBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,A+B7FA,AHSA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AyB3EA,AvBqEA,ACHA,AoB5DA,ALeA,AFMA,ARwBA,ACHA,AIZA,AHSA,ACHA,AMlBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,A+B7FA,AHSA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AyB3EA,AvBqEA,AwBxEA,AvBqEA,AoB5DA,ALeA,AFMA,ARwBA,ACHA,AIZA,AHSA,ACHA,AMlBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,A+B7FA,AHSA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AyB3EA,AvBqEA,AwBxEA,AvBqEA,AoB5DA,ALeA,AFMA,ARwBA,ACHA,AIZA,AHSA,ACHA,AMlBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,A+B7FA,AHSA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AyB3EA,AvBqEA,AwBxEA,AvBqEA,AoB5DA,ALeA,AFMA,ARwBA,ACHA,AIZA,AHSA,ACHA,AMlBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,A+B7FA,AHSA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AyB3EA,AvBqEA,AwBxEA,ACHA,AxBwEA,AoB5DA,ALeA,AFMA,ARwBA,ACHA,ACHA,ACHA,AMlBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,A+B7FA,AHSA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AyB3EA,AvBqEA,AwBxEA,ACHA,AxBwEA,AoB5DA,ALeA,AFMA,ARwBA,ACHA,ACHA,ACHA,AMlBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,A+B7FA,AHSA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AyB3EA,AvBqEA,AwBxEA,ACHA,AxBwEA,AoB5DA,ALeA,AFMA,ARwBA,ACHA,ACHA,ACHA,AMlBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,A+B7FA,AHSA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AyB3EA,AvBqEA,AwBxEA,AENA,ADGA,AxBwEA,AoB5DA,ALeA,AFMA,ARwBA,ACHA,ACHA,ACHA,AMlBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,A4BpFA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AyB3EA,AvBqEA,AwBxEA,AENA,ADGA,AxBwEA,AoB5DA,ALeA,AFMA,ARwBA,ACHA,ACHA,ACHA,AMlBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,A4BpFA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AyB3EA,AvBqEA,AwBxEA,AENA,ADGA,AxBwEA,AoB5DA,ALeA,AFMA,ARwBA,ACHA,ACHA,ACHA,AMlBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,A4BpFA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AyB3EA,AvBqEA,AwBxEA,AENA,ADGA,AxBwEA,A0B9EA,ANkBA,ALeA,AFMA,ARwBA,ACHA,ACHA,ACHA,AMlBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,A4BpFA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AyB3EA,AvBqEA,AwBxEA,AENA,ADGA,AxBwEA,A0B9EA,ANkBA,ALeA,AFMA,ARwBA,ACHA,ACHA,ACHA,AMlBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,A4BpFA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AyB3EA,AvBqEA,AwBxEA,AENA,ADGA,AxBwEA,A0B9EA,ANkBA,ALeA,AFMA,ARwBA,ACHA,ACHA,ACHA,AMlBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AT2BA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AyB3EA,AvBqEA,AwBxEA,AENA,ADGA,AxBwEA,A0B9EA,ANkBA,ALeA,AFMA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AT2BA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AyB3EA,AvBqEA,AwBxEA,AENA,ADGA,AxBwEA,A0B9EA,ANkBA,ALeA,AFMA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AT2BA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AyB3EA,AvBqEA,AwBxEA,AENA,ADGA,AxBwEA,A0B9EA,ANkBA,ALeA,AFMA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AT2BA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AyB3EA,AMlBA,A7BuFA,AwBxEA,AENA,ADGA,AxBwEA,A0B9EA,ANkBA,ALeA,AFMA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AT2BA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AyB3EA,AMlBA,A7BuFA,AwBxEA,AENA,ADGA,AxBwEA,A0B9EA,ANkBA,ALeA,AFMA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AT2BA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AyB3EA,AMlBA,A7BuFA,AwBxEA,AENA,ADGA,AxBwEA,A0B9EA,ANkBA,ALeA,AFMA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AT2BA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AyB3EA,AOrBA,ADGA,A7BuFA,AwBxEA,AENA,ADGA,AxBwEA,A0B9EA,ANkBA,ALeA,AFMA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AT2BA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AyB3EA,AOrBA,ADGA,A7BuFA,AwBxEA,AENA,ADGA,AxBwEA,A0B9EA,ANkBA,ALeA,AFMA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AT2BA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AyB3EA,AOrBA,ADGA,A7BuFA,AwBxEA,AENA,ADGA,AxBwEA,A0B9EA,ANkBA,ALeA,AFMA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AT2BA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AyB3EA,AOrBA,ADGA,A7BuFA,AwBxEA,AENA,ADGA,AMlBA,A9B0FA,A0B9EA,ANkBA,ALeA,AFMA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AT2BA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AyB3EA,AOrBA,ADGA,A7BuFA,AwBxEA,AENA,ADGA,AMlBA,A9B0FA,A0B9EA,ANkBA,ALeA,AFMA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AT2BA,AFMA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AyB3EA,AOrBA,ADGA,A7BuFA,AwBxEA,AENA,ADGA,AMlBA,A9B0FA,A0B9EA,ANkBA,ALeA,AFMA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AXiCA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AyB3EA,AS3BA,AFMA,ADGA,A7BuFA,AwBxEA,AENA,ADGA,AMlBA,A9B0FA,A0B9EA,ANkBA,ALeA,AFMA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AXiCA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AyB3EA,AS3BA,AFMA,ADGA,A7BuFA,AwBxEA,AENA,ADGA,AMlBA,A9B0FA,A0B9EA,ANkBA,ALeA,AFMA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AXiCA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AyB3EA,AS3BA,AFMA,ADGA,A7BuFA,AwBxEA,AENA,ADGA,AMlBA,A9B0FA,A0B9EA,ANkBA,ALeA,AFMA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AXiCA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AyB3EA,AS3BA,AFMA,ADGA,A7BuFA,AwBxEA,AENA,ADGA,AMlBA,A9B0FA,AgChGA,ANkBA,ANkBA,ALeA,AFMA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AXiCA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AyB3EA,AS3BA,AFMA,ADGA,A7BuFA,AwBxEA,AENA,ADGA,AMlBA,A9B0FA,AgChGA,ANkBA,ANkBA,ALeA,AFMA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AXiCA,AvBqEA,AQxBA,AT2BA,AGTA,AGTA,ADGA,AyB3EA,AS3BA,AFMA,ADGA,A7BuFA,AwBxEA,AENA,ADGA,AMlBA,A9B0FA,AgChGA,ANkBA,ANkBA,ALeA,AFMA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AXiCA,AvBqEA,ADGA,AGTA,AGTA,ADGA,AyB3EA,AS3BA,AFMA,ADGA,A7BuFA,AwBxEA,AENA,ADGA,AMlBA,AGTA,AjCmGA,AgChGA,ANkBA,ANkBA,ALeA,AFMA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AXiCA,AvBqEA,ADGA,AGTA,AGTA,ADGA,AyB3EA,AS3BA,AFMA,ADGA,A7BuFA,AwBxEA,AENA,ADGA,AMlBA,AGTA,AjCmGA,AgChGA,ANkBA,ANkBA,ALeA,AFMA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AXiCA,AvBqEA,ADGA,AGTA,AGTA,ADGA,AyB3EA,AS3BA,AFMA,ADGA,A7BuFA,AwBxEA,AENA,ADGA,AMlBA,AGTA,AjCmGA,AgChGA,ANkBA,ANkBA,ALeA,AFMA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AXiCA,AvBqEA,ADGA,AGTA,AGTA,ADGA,AyB3EA,AS3BA,AFMA,ADGA,A7BuFA,AwBxEA,AENA,ADGA,AMlBA,AGTA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AFMA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AXiCA,AvBqEA,ADGA,AGTA,AGTA,ADGA,AyB3EA,AS3BA,AFMA,ADGA,A7BuFA,AwBxEA,AENA,ADGA,AMlBA,AGTA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AFMA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AXiCA,AvBqEA,ADGA,AGTA,AGTA,ADGA,AyB3EA,AS3BA,AFMA,ADGA,A7BuFA,AwBxEA,AENA,ADGA,AMlBA,AGTA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AFMA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AXiCA,AvBqEA,ADGA,AGTA,AGTA,ADGA,AyB3EA,AS3BA,AFMA,ADGA,A7BuFA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AFMA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AXiCA,AvBqEA,ADGA,AGTA,AGTA,ADGA,AyB3EA,AS3BA,AFMA,ADGA,A7BuFA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AFMA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AXiCA,AvBqEA,ADGA,AGTA,AGTA,ADGA,AyB3EA,AS3BA,AFMA,ADGA,A7BuFA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AFMA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AXiCA,AvBqEA,ADGA,AGTA,AGTA,ADGA,AyB3EA,AS3BA,AFMA,ADGA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AFMA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AXiCA,AvBqEA,ADGA,AGTA,AGTA,ADGA,AyB3EA,AS3BA,AFMA,ADGA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AFMA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AXiCA,AvBqEA,ADGA,AGTA,AGTA,ADGA,AyB3EA,AS3BA,AFMA,ADGA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AFMA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AXiCA,AvBqEA,ADGA,AGTA,AGTA,ADGA,AyB3EA,Ae7CA,ANkBA,AFMA,ADGA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AFMA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AXiCA,AvBqEA,ADGA,AGTA,AGTA,ADGA,AyB3EA,Ae7CA,ANkBA,AFMA,ADGA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AFMA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AXiCA,AvBqEA,ADGA,AGTA,AGTA,ADGA,AyB3EA,Ae7CA,ANkBA,AFMA,ADGA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AFMA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AXiCA,AvBqEA,ADGA,AGTA,AGTA,ADGA,AyB3EA,Ae7CA,ANkBA,AFMA,ADGA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AXiCA,AvBqEA,ADGA,AGTA,AGTA,ADGA,AyB3EA,Ae7CA,ANkBA,AFMA,ADGA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AXiCA,AvBqEA,ADGA,AMlBA,ADGA,AyB3EA,Ae7CA,ANkBA,AFMA,ADGA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AXiCA,AuBrEA,A9C0IA,ADGA,AMlBA,ADGA,AyB3EA,Ae7CA,ANkBA,AFMA,ADGA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AXiCA,AuBrEA,A9C0IA,ADGA,AMlBA,ADGA,AyB3EA,Ae7CA,ANkBA,AFMA,ADGA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AXiCA,AuBrEA,A9C0IA,ADGA,AMlBA,ADGA,AyB3EA,Ae7CA,ANkBA,AFMA,ADGA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AXiCA,AuBrEA,A9C0IA,A+C7IA,AhDgJA,AMlBA,ADGA,AyB3EA,Ae7CA,ANkBA,AFMA,ADGA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AXiCA,AuBrEA,A9C0IA,A+C7IA,AhDgJA,AMlBA,ADGA,AyB3EA,Ae7CA,ANkBA,AFMA,ADGA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AXiCA,AuBrEA,A9C0IA,A+C7IA,AhDgJA,AMlBA,ADGA,AyB3EA,Ae7CA,ANkBA,AFMA,ADGA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AXiCA,AuBrEA,A9C0IA,AgDhJA,ADGA,AhDgJA,AMlBA,ADGA,AyB3EA,Ae7CA,ANkBA,AFMA,ADGA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AXiCA,AuBrEA,A9C0IA,AgDhJA,ADGA,AhDgJA,AMlBA,ADGA,AyB3EA,Ae7CA,ANkBA,AFMA,ADGA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AXiCA,AuBrEA,A9C0IA,AgDhJA,ADGA,AhDgJA,AMlBA,ADGA,AyB3EA,Ae7CA,ANkBA,AFMA,ADGA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AXiCA,AuBrEA,A9C0IA,AgDhJA,ACHA,AFMA,AhDgJA,AMlBA,ADGA,AyB3EA,Ae7CA,ANkBA,AFMA,ADGA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AS3BA,ACHA,AKfA;A3BkFA,AqC/GA,AXiCA,AuBrEA,A9C0IA,AgDhJA,ACHA,AFMA,AhDgJA,AMlBA,ADGA,AyB3EA,Ae7CA,ANkBA,AFMA,ADGA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AU9BA,AKfA;A3BkFA,AqC/GA,AXiCA,AuBrEA,A9C0IA,AgDhJA,ACHA,AFMA,AhDgJA,AMlBA,ADGA,AyB3EA,Ae7CA,ANkBA,AFMA,ADGA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AU9BA,AKfA;A3BkFA,AqC/GA,AXiCA,AuBrEA,A9C0IA,AkDtJA,AFMA,ACHA,AFMA,AhDgJA,AMlBA,ADGA,AyB3EA,Ae7CA,ANkBA,AFMA,ADGA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AU9BA,AKfA;A3BkFA,AqC/GA,AXiCA,AuBrEA,A9C0IA,AkDtJA,AFMA,ACHA,AFMA,AhDgJA,AMlBA,ADGA,AyB3EA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AU9BA,AKfA;A3BkFA,AqC/GA,AXiCA,AuBrEA,A9C0IA,AkDtJA,AFMA,ACHA,AFMA,AhDgJA,AMlBA,ADGA,AyB3EA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AU9BA,AKfA;A3BkFA,AqC/GA,AXiCA,AuBrEA,A9C0IA,AkDtJA,AFMA,ACHA,AFMA,AIZA,ApD4JA,AMlBA,ADGA,AyB3EA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AU9BA,AKfA;A3BkFA,AqC/GA,AXiCA,AuBrEA,A9C0IA,AkDtJA,AFMA,ACHA,AFMA,AIZA,ApD4JA,AMlBA,ADGA,AyB3EA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AU9BA,AKfA;A3BkFA,AqC/GA,AXiCA,AuBrEA,A9C0IA,AkDtJA,AFMA,ACHA,AFMA,AIZA,ApD4JA,AMlBA,ADGA,AyB3EA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AU9BA,AKfA;A3BkFA,AqC/GA,AXiCA,AuBrEA,A9C0IA,AkDtJA,AFMA,ACHA,AFMA,AIZA,ACHA,ArD+JA,AMlBA,ADGA,AyB3EA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AU9BA,AKfA;A3BkFA,AqC/GA,AXiCA,AuBrEA,A9C0IA,AkDtJA,AFMA,ACHA,AFMA,AIZA,ACHA,ArD+JA,AMlBA,ADGA,AyB3EA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AU9BA,AKfA;A3BkFA,AqC/GA,AXiCA,AuBrEA,A9C0IA,AkDtJA,AFMA,ACHA,AFMA,AIZA,ACHA,ArD+JA,AMlBA,ADGA,AyB3EA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AU9BA,AKfA;A3BkFA,AqC/GA,AXiCA,AuBrEA,A9C0IA,AkDtJA,AGTA,ALeA,ACHA,AENA,ACHA,ArD+JA,AMlBA,ADGA,AyB3EA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AU9BA,AKfA;A3BkFA,AqC/GA,AXiCA,AuBrEA,A9C0IA,AkDtJA,AGTA,ALeA,ACHA,AENA,ACHA,ArD+JA,AMlBA,ADGA,AyB3EA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AU9BA,AKfA;A3BkFA,AqC/GA,AXiCA,AuBrEA,A9C0IA,AkDtJA,AGTA,ALeA,ACHA,AENA,ACHA,ArD+JA,AMlBA,ADGA,AyB3EA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AU9BA,AKfA;A3BkFA,AqC/GA,AXiCA,AuBrEA,A9C0IA,AkDtJA,AGTA,ACHA,ANkBA,ACHA,AENA,ACHA,ArD+JA,AMlBA,ADGA,AyB3EA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AU9BA,AKfA;A3BkFA,AqC/GA,AXiCA,AuBrEA,A9C0IA,AkDtJA,AGTA,ACHA,ANkBA,ACHA,AENA,ACHA,ArD+JA,AMlBA,AwBxEA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AU9BA,AKfA;A3BkFA,AqC/GA,AXiCA,AuBrEA,A9C0IA,AkDtJA,AGTA,ACHA,ANkBA,ACHA,AENA,ACHA,ArD+JA,AMlBA,AwBxEA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AU9BA,AKfA;A3BkFA,AqC/GA,AXiCA,AuBrEA,A9C0IA,AkDtJA,AGTA,ACHA,ACHA,ANkBA,AENA,ACHA,ArD+JA,AMlBA,AwBxEA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AU9BA,AKfA;A3BkFA,AqC/GA,AXiCA,AuBrEA,A9C0IA,AkDtJA,AGTA,ACHA,ACHA,ANkBA,AENA,ACHA,ArD+JA,AMlBA,AwBxEA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AU9BA,AKfA;A3BkFA,AqC/GA,AXiCA,AuBrEA,A9C0IA,AkDtJA,AGTA,ACHA,ACHA,ANkBA,AENA,ACHA,ArD+JA,AMlBA,AwBxEA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AU9BA,AKfA;A3BkFA,AqC/GA,AXiCA,AuBrEA,A9C0IA,AkDtJA,AGTA,ACHA,ACHA,ANkBA,AENA,ACHA,AIZA,AzD2KA,AMlBA,AwBxEA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AU9BA,AKfA;A3BkFA,AqC/GA,AYpCA,A9C0IA,AkDtJA,AGTA,ACHA,ACHA,ANkBA,AENA,ACHA,AIZA,AzD2KA,AMlBA,AwBxEA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AU9BA,AKfA;AU7BA,AYpCA,A9C0IA,AkDtJA,AGTA,ACHA,ACHA,ANkBA,AENA,ACHA,AIZA,AzD2KA,AMlBA,AwBxEA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AU9BA,AKfA;AU7BA,AYpCA,A9C0IA,AkDtJA,AGTA,ACHA,ACHA,ANkBA,AENA,ACHA,AIZA,ACHA,A1D8KA,A8B1FA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AU9BA,AKfA;AU7BA,AYpCA,A9C0IA,AkDtJA,AGTA,ACHA,ACHA,ANkBA,AENA,ACHA,AIZA,ACHA,A1D8KA,A8B1FA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AU9BA,AKfA;AU7BA,AYpCA,A9C0IA,AkDtJA,AGTA,ACHA,ACHA,ANkBA,AENA,ACHA,AIZA,ACHA,A1D8KA,A8B1FA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AU9BA,AKfA;AU7BA,AYpCA,A9C0IA,AkDtJA,AGTA,ACHA,ACHA,ANkBA,AENA,ACHA,AMlBA,AFMA,ACHA,A1D8KA,A8B1FA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AU9BA,AKfA;AU7BA,AYpCA,A9C0IA,AkDtJA,AGTA,ACHA,ACHA,ANkBA,AENA,ACHA,AMlBA,AFMA,ACHA,A1D8KA,A8B1FA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AU9BA,AKfA;AU7BA,AYpCA,A9C0IA,AkDtJA,AGTA,ACHA,ACHA,ANkBA,AENA,ACHA,AMlBA,AFMA,ACHA,A1D8KA,A8B1FA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AU9BA,AKfA;AU7BA,AYpCA,A9C0IA,AkDtJA,AGTA,ACHA,ACHA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,AFMA,ACHA,A1D8KA,A8B1FA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AU9BA,AKfA;AU7BA,AYpCA,A9C0IA,AkDtJA,AGTA,ACHA,ACHA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,AFMA,ACHA,A1D8KA,A8B1FA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AU9BA,AKfA;AU7BA,AYpCA,A9C0IA,AkDtJA,AGTA,ACHA,ACHA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,AFMA,ACHA,A1D8KA,A8B1FA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AU9BA,AKfA;AU7BA,AYpCA,Ac1CA,A5DoLA,AkDtJA,AGTA,ACHA,ACHA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,AFMA,ACHA,A1D8KA,A8B1FA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,ACHA,ACHA,AOrBA,AZoCA,AU9BA,AKfA;AU7BA,AYpCA,Ac1CA,A5DoLA,AkDtJA,AGTA,ACHA,ACHA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,AFMA,ACHA,A1D8KA,A8B1FA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,AENA,AOrBA,AZoCA,AU9BA,AKfA;AU7BA,AYpCA,Ac1CA,A5DoLA,AkDtJA,AGTA,ACHA,ACHA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,AFMA,ACHA,A1D8KA,A8B1FA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,AENA,AOrBA,AZoCA,AU9BA,AKfA;AU7BA,AYpCA,Ae7CA,ADGA,A5DoLA,AkDtJA,AGTA,AENA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,AFMA,ACHA,A1D8KA,A8B1FA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,AENA,AOrBA,AZoCA,AU9BA,AKfA;AU7BA,AYpCA,Ae7CA,ADGA,A5DoLA,AkDtJA,AGTA,AENA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,AFMA,ACHA,A1D8KA,A8B1FA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,AENA,AOrBA,AZoCA,AU9BA,AKfA;AU7BA,AYpCA,Ae7CA,ADGA,A5DoLA,AkDtJA,AGTA,AENA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,AFMA,ACHA,A1D8KA,A8B1FA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,AENA,AOrBA,AZoCA,AU9BA,AKfA;AU7BA,AYpCA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AGTA,AENA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,AFMA,ACHA,A1D8KA,A8B1FA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,AENA,AOrBA,AZoCA,AU9BA,AKfA;AU7BA,AYpCA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,AFMA,ACHA,A1D8KA,A8B1FA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,AENA,AOrBA,AZoCA,AU9BA,AKfA;AU7BA,AYpCA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,AFMA,ACHA,A1D8KA,A8B1FA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,AENA,AOrBA,AZoCA,AU9BA,AKfA;AU7BA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A1D8KA,A8B1FA,Ae7CA,ANkBA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,AENA,AOrBA,AZoCA,AU9BA,AKfA;AU7BA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A1D8KA,A8B1FA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,AENA,AOrBA,AZoCA,AU9BA,AKfA;AU7BA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A1D8KA,A8B1FA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,ANkBA,ALeA,AuBrEA,AzB2EA,ARwBA,AENA,AOrBA,AZoCA,AU9BA,AKfA;AwCvHA,A9B0FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A1D8KA,A8B1FA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,AOrBA,AZoCA,AU9BA,AKfA;AwCvHA,A9B0FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A1D8KA,A8B1FA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;AwCvHA,A9B0FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A1D8KA,A8B1FA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;AwCvHA,ACHA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A1D8KA,A8B1FA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;AwCvHA,ACHA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A1D8KA,A8B1FA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;AwCvHA,ACHA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A1D8KA,A8B1FA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;AwCvHA,AENA,ADGA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A1D8KA,A8B1FA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;AwCvHA,AENA,ADGA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A1D8KA,A8B1FA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;AwCvHA,AENA,ADGA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A1D8KA,A8B1FA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;AwCvHA,AENA,ACHA,AFMA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A1D8KA,A8B1FA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;AwCvHA,AENA,ACHA,AFMA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A1D8KA,A8B1FA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;AwCvHA,AENA,ACHA,AFMA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A1D8KA,A8B1FA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;AwCvHA,AENA,AENA,ADGA,AFMA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A1D8KA,A8B1FA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;AwCvHA,AENA,AENA,ADGA,AFMA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A1D8KA,A8B1FA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;AwCvHA,AENA,AENA,ADGA,AFMA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A1D8KA,A8B1FA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;A6CtIA,ALeA,AENA,AENA,ADGA,AFMA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A1D8KA,A8B1FA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;A6CtIA,ALeA,AENA,AENA,ADGA,AFMA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A1D8KA,A8B1FA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;A6CtIA,ALeA,AENA,AENA,ADGA,AFMA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A1D8KA,A8B1FA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;A6CtIA,ALeA,AMlBA,AJYA,AENA,ADGA,AFMA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A1D8KA,A8B1FA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,AFMA,ANkBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;A6CtIA,ALeA,AMlBA,AJYA,AENA,ADGA,AFMA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A1D8KA,A8B1FA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;A6CtIA,ALeA,AMlBA,AJYA,AENA,ADGA,AFMA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A1D8KA,A8B1FA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;A6CtIA,ALeA,AMlBA,AJYA,AKfA,AHSA,ADGA,AFMA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A1D8KA,A8B1FA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;A6CtIA,ALeA,AMlBA,AJYA,AKfA,AHSA,ADGA,AFMA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A1D8KA,A8B1FA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;A6CtIA,ALeA,AMlBA,AJYA,AKfA,AHSA,ADGA,AFMA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A1D8KA,A8B1FA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;A6CtIA,ALeA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A1D8KA,A8B1FA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;A6CtIA,ALeA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A1D8KA,A8B1FA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;A6CtIA,ALeA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A1D8KA,A8B1FA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;A6CtIA,AIZA,AT2BA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A1D8KA,A8B1FA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;A6CtIA,AIZA,AT2BA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A5BoFA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;A6CtIA,AIZA,AT2BA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A5BoFA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;A6CtIA,AKfA,ADGA,AT2BA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A5BoFA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;A6CtIA,AKfA,ADGA,AT2BA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A5BoFA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;A6CtIA,AKfA,ADGA,AT2BA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A5BoFA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;A6CtIA,AKfA,ACHA,AFMA,AT2BA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A5BoFA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;A6CtIA,AKfA,ACHA,AFMA,AT2BA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,A9D0LA,AkDtJA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A5BoFA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;A6CtIA,AKfA,ACHA,AFMA,AT2BA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,AZoCA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A5BoFA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;A6CtIA,AKfA,ACHA,ACHA,AHSA,AT2BA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,AZoCA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A5BoFA,AS3BA,AHSA,AQxBA,ArC+GA,AwBxEA,AENA,ADGA,AMlBA,AKfA,AFMA,AjCmGA,AkCtGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;A6CtIA,AKfA,ACHA,ACHA,AHSA,AT2BA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,AZoCA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A5BoFA,AS3BA,AHSA,AQxBA,AbuCA,AENA,ADGA,AMlBA,AKfA,AFMA,ACHA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;A6CtIA,AKfA,ACHA,ACHA,AHSA,AT2BA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,AZoCA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A5BoFA,AS3BA,AHSA,AQxBA,AbuCA,AENA,ADGA,AMlBA,AKfA,AFMA,ACHA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;A6CtIA,AQxBA,AHSA,ACHA,ACHA,AHSA,AT2BA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,AZoCA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A5BoFA,AS3BA,AHSA,AQxBA,AbuCA,AENA,ADGA,AMlBA,AKfA,AFMA,ACHA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;A6CtIA,AQxBA,AHSA,ACHA,ACHA,AHSA,AT2BA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,AZoCA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A5BoFA,AS3BA,AHSA,AQxBA,AbuCA,AENA,ADGA,AMlBA,AKfA,AFMA,ACHA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;A6CtIA,AQxBA,AHSA,ACHA,ACHA,AHSA,AT2BA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,A/B6FA,A6BvFA,AjBmDA,Ae7CA,ADGA,AENA,AZoCA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A5BoFA,AS3BA,AHSA,AQxBA,AbuCA,AENA,ADGA,AMlBA,AKfA,AFMA,ACHA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;A6CtIA,AQxBA,AHSA,ACHA,AGTA,AFMA,AHSA,AT2BA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,A/B6FA,AYpCA,Ae7CA,ADGA,AENA,AZoCA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A5BoFA,AS3BA,AHSA,AQxBA,AbuCA,AENA,ADGA,AMlBA,AKfA,AFMA,ACHA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;A6CtIA,AQxBA,AHSA,ACHA,AGTA,AFMA,AHSA,AT2BA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,A/B6FA,AYpCA,Ae7CA,ADGA,AENA,AZoCA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A5BoFA,AS3BA,AHSA,AQxBA,AbuCA,AENA,ADGA,AMlBA,AKfA,AFMA,ACHA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;A6CtIA,AQxBA,AHSA,ACHA,AGTA,AFMA,AHSA,AT2BA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,A/B6FA,AYpCA,Ae7CA,ADGA,AENA,AZoCA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A5BoFA,AS3BA,AHSA,AQxBA,AbuCA,AENA,ADGA,AMlBA,AKfA,AFMA,ACHA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;A6CtIA,AQxBA,AHSA,ACHA,AGTA,ACHA,AHSA,AHSA,AT2BA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,A/B6FA,AYpCA,Ae7CA,ADGA,AENA,AZoCA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A5BoFA,AS3BA,AHSA,AQxBA,AbuCA,AENA,ADGA,AMlBA,AKfA,AFMA,ACHA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;A6CtIA,AQxBA,AHSA,ACHA,AGTA,ACHA,AHSA,AHSA,AT2BA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,A/B6FA,AYpCA,Ae7CA,ADGA,AENA,AZoCA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A5BoFA,AS3BA,AHSA,AQxBA,AbuCA,AENA,ADGA,AMlBA,AKfA,AFMA,ACHA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;A6CtIA,AQxBA,AHSA,ACHA,AGTA,ACHA,AHSA,AHSA,AT2BA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,A/B6FA,AYpCA,Ae7CA,ADGA,AENA,AZoCA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A5BoFA,AS3BA,AHSA,AQxBA,AbuCA,AENA,ADGA,AMlBA,AKfA,AFMA,ACHA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AENA,ALeA,AU9BA,AKfA;A6CtIA,AQxBA,AHSA,ACHA,AGTA,ACHA,AHSA,AHSA,AOrBA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,A/B6FA,AYpCA,Ae7CA,ADGA,AENA,AZoCA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A5BoFA,AS3BA,AHSA,AQxBA,AbuCA,AENA,ADGA,AMlBA,AKfA,AFMA,ACHA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AQxBA,AHSA,ACHA,AGTA,ACHA,AHSA,AHSA,AOrBA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,A/B6FA,AYpCA,Ae7CA,ADGA,AENA,AZoCA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A5BoFA,AS3BA,AHSA,AQxBA,AbuCA,AENA,ADGA,AMlBA,AKfA,AFMA,ACHA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AQxBA,AHSA,ACHA,AGTA,ACHA,AHSA,AHSA,AOrBA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,A/B6FA,AYpCA,Ac1CA,AENA,AZoCA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A5BoFA,AS3BA,AHSA,AQxBA,AbuCA,AENA,ADGA,AMlBA,AKfA,AFMA,ACHA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AQxBA,AHSA,ACHA,AMlBA,AHSA,ACHA,AHSA,AHSA,AOrBA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,A/B6FA,AYpCA,Ac1CA,AENA,AZoCA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A5BoFA,AS3BA,AHSA,AQxBA,AbuCA,AENA,ADGA,AMlBA,AKfA,AFMA,ACHA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AQxBA,AHSA,ACHA,AMlBA,AHSA,ACHA,AHSA,AHSA,AOrBA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,A/B6FA,AYpCA,Ac1CA,AENA,AZoCA,AKfA,ANkBA,AU9BA,ARwBA,ACHA,AMlBA,ADGA,A5BoFA,AS3BA,AHSA,AQxBA,AbuCA,AENA,ADGA,AMlBA,AKfA,AFMA,ACHA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AQxBA,AHSA,ACHA,AMlBA,AHSA,ACHA,AHSA,AHSA,AOrBA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,A/B6FA,AYpCA,Ac1CA,AENA,AZoCA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,A5BoFA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,AFMA,ACHA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AHSA,ACHA,AMlBA,AHSA,ACHA,AHSA,AHSA,AOrBA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,A/B6FA,AYpCA,Ac1CA,AENA,AZoCA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,A5BoFA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,AFMA,ACHA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AHSA,ACHA,AMlBA,AHSA,ACHA,AHSA,AHSA,AOrBA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,A/B6FA,AYpCA,Ac1CA,AENA,AZoCA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,A5BoFA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,AFMA,ACHA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AHSA,ACHA,AMlBA,AHSA,ACHA,AHSA,AHSA,AOrBA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,A/B6FA,AYpCA,Ac1CA,AENA,AZoCA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,A5BoFA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,AFMA,ACHA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AHSA,ACHA,AMlBA,AENA,ALeA,ACHA,AHSA,AHSA,AOrBA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,AnByDA,Ac1CA,AENA,AZoCA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,A5BoFA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,AFMA,ACHA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AHSA,ACHA,AMlBA,AENA,ALeA,ACHA,AHSA,AHSA,AOrBA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,AnByDA,Ac1CA,AENA,AZoCA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,A5BoFA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,AFMA,ACHA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AHSA,ACHA,AMlBA,AENA,ALeA,ACHA,AHSA,AHSA,AOrBA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,AnByDA,Ac1CA,AENA,AZoCA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,A5BoFA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,AFMA,ACHA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AHSA,ACHA,AMlBA,AENA,ALeA,ACHA,AHSA,AHSA,AOrBA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,AnByDA,AsClHA,AxBwEA,AENA,AZoCA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,A5BoFA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,AFMA,ACHA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AHSA,ACHA,AMlBA,AENA,ALeA,ACHA,AHSA,AHSA,AOrBA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,AnByDA,AsClHA,AxBwEA,AENA,AZoCA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,A5BoFA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,AFMA,ACHA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AHSA,ACHA,AMlBA,AENA,ALeA,ACHA,AHSA,AHSA,AOrBA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,AnByDA,AsClHA,AxBwEA,AENA,AZoCA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,A5BoFA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AHSA,ACHA,AMlBA,AENA,ALeA,ACHA,AHSA,AHSA,AOrBA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,AnByDA,AsClHA,AxBwEA,AENA,AZoCA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,A4BpFA,AxDwKA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AHSA,ACHA,AMlBA,AENA,ALeA,ACHA,AHSA,AHSA,AOrBA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AHSA,ADGA,AFMA,AnByDA,AsClHA,AxBwEA,AENA,AZoCA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,A4BpFA,AxDwKA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AHSA,ACHA,AMlBA,AENA,ALeA,ACHA,AHSA,AHSA,AOrBA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AJYA,AFMA,AnByDA,AsClHA,AxBwEA,AENA,AZoCA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,A4BpFA,AxDwKA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AHSA,ACHA,AMlBA,AENA,ALeA,ACHA,AHSA,AHSA,AOrBA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AJYA,AFMA,AqB/DA,AxCwHA,AsClHA,AxBwEA,AENA,AZoCA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,A4BpFA,AxDwKA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AHSA,ACHA,AMlBA,AENA,ALeA,ACHA,AHSA,AHSA,AOrBA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AJYA,AFMA,AqB/DA,AxCwHA,AsClHA,AxBwEA,AENA,AZoCA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,A4BpFA,AxDwKA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AHSA,ACHA,AMlBA,AENA,ALeA,ACHA,AHSA,AHSA,AOrBA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AJYA,AFMA,AqB/DA,AxCwHA,AsClHA,AxBwEA,AENA,AZoCA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,A4BpFA,AxDwKA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AHSA,ACHA,AMlBA,AENA,ALeA,ACHA,AHSA,AHSA,AOrBA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AJYA,AFMA,AqB/DA,AxCwHA,AsClHA,AxBwEA,AENA,AZoCA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,A8B1FA,AFMA,AxDwKA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AHSA,ACHA,AMlBA,AENA,ALeA,ACHA,AHSA,AHSA,AOrBA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AJYA,AFMA,AqB/DA,AxCwHA,AsClHA,AxBwEA,AENA,AZoCA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,A8B1FA,AFMA,AxDwKA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AHSA,AOrBA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AJYA,AFMA,AqB/DA,AxCwHA,AsClHA,AxBwEA,AENA,AZoCA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,A8B1FA,AFMA,AxDwKA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AHSA,AOrBA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AJYA,AFMA,AqB/DA,AxCwHA,AsClHA,AxBwEA,AENA,AZoCA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,A8B1FA,ACHA,AHSA,AxDwKA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AJYA,AFMA,AqB/DA,AxCwHA,AsClHA,AxBwEA,AENA,AZoCA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,A8B1FA,ACHA,AHSA,AxDwKA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AJYA,AFMA,AqB/DA,AxCwHA,AsClHA,AxBwEA,AENA,AZoCA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,A8B1FA,ACHA,AHSA,AxDwKA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AJYA,AFMA,AqB/DA,AxCwHA,AsClHA,AxBwEA,AENA,AZoCA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,A8B1FA,AENA,ADGA,AHSA,AxDwKA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AJYA,AFMA,AqB/DA,AxCwHA,AsClHA,AxBwEA,AV8BA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,A8B1FA,AENA,ADGA,AHSA,AxDwKA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AJYA,AFMA,AqB/DA,AxCwHA,AsClHA,AxBwEA,AV8BA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,A8B1FA,AENA,ADGA,AHSA,AxDwKA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AJYA,AFMA,AqB/DA,AxCwHA,AsClHA,AxBwEA,AV8BA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,A8B1FA,AGTA,ADGA,ADGA,AHSA,AxDwKA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AJYA,AFMA,AqB/DA,AxCwHA,AsClHA,AxBwEA,AV8BA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,A8B1FA,AGTA,ADGA,ADGA,AHSA,AxDwKA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AJYA,AFMA,AqB/DA,AxCwHA,AsClHA,AxBwEA,AV8BA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,A8B1FA,AGTA,ADGA,ADGA,AHSA,AxDwKA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AJYA,AFMA,AqB/DA,AxCwHA,AsClHA,AxBwEA,AV8BA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,A8B1FA,AGTA,ACHA,AFMA,ADGA,AHSA,AxDwKA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AJYA,AFMA,AqB/DA,AxCwHA,AsClHA,AxBwEA,AV8BA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,A8B1FA,AGTA,ACHA,AFMA,ADGA,A3DiLA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AJYA,AFMA,AqB/DA,AxCwHA,AsClHA,AxBwEA,AV8BA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,A8B1FA,AGTA,ACHA,AFMA,ADGA,A3DiLA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AJYA,AFMA,AqB/DA,AxCwHA,AsClHA,AxBwEA,AV8BA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,AmCzGA,ALeA,AGTA,ACHA,AFMA,ADGA,A3DiLA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AJYA,AFMA,AqB/DA,AxCwHA,AsClHA,AxBwEA,AV8BA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,AmCzGA,ALeA,AGTA,ACHA,AFMA,ADGA,A3DiLA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AJYA,AFMA,AqB/DA,AxCwHA,AsClHA,AxBwEA,AV8BA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,AmCzGA,ALeA,AGTA,ACHA,AFMA,ADGA,A3DiLA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AJYA,AFMA,AqB/DA,AxCwHA,AsClHA,AxBwEA,AV8BA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,AoC5GA,ADGA,ALeA,AGTA,ACHA,AFMA,ADGA,A3DiLA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AJYA,AFMA,AqB/DA,AxCwHA,AsClHA,AxBwEA,AV8BA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,AoC5GA,ADGA,ALeA,AGTA,ACHA,AFMA,ADGA,A3DiLA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AJYA,AFMA,AqB/DA,AxCwHA,AsClHA,AxBwEA,AV8BA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,AoC5GA,ADGA,ALeA,AGTA,ACHA,AFMA,ADGA,A3DiLA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AJYA,AFMA,AqB/DA,AxCwHA,AsClHA,AxBwEA,AV8BA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,AoC5GA,ADGA,AENA,APqBA,AGTA,ACHA,AFMA,ADGA,A3DiLA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AJYA,AFMA,AqB/DA,AxCwHA,AsClHA,AxBwEA,AV8BA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,AoC5GA,ADGA,AENA,APqBA,AGTA,ACHA,AFMA,ADGA,A3DiLA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AJYA,AFMA,AnByDA,AsClHA,AxBwEA,AV8BA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,AoC5GA,ADGA,AENA,APqBA,AGTA,ACHA,AFMA,ADGA,A3DiLA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AJYA,AFMA,AnByDA,AsClHA,AxBwEA,AV8BA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,AoC5GA,ADGA,AENA,ACHA,ARwBA,AGTA,ACHA,AFMA,ADGA,A3DiLA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AJYA,AFMA,AnByDA,AsClHA,AxBwEA,AV8BA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,AoC5GA,ADGA,AENA,ACHA,ARwBA,AGTA,ACHA,AFMA,ADGA,A3DiLA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AJYA,AFMA,AnByDA,AsClHA,AxBwEA,AV8BA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,AoC5GA,ADGA,AENA,ACHA,ARwBA,AGTA,ACHA,AFMA,ADGA,A3DiLA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AJYA,AFMA,AnByDA,AsClHA,AxBwEA,AV8BA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,AuCrHA,AHSA,ADGA,AENA,ACHA,ARwBA,AGTA,ACHA,AFMA,ADGA,A3DiLA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AJYA,AFMA,AnByDA,AsClHA,AxBwEA,AV8BA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,AuCrHA,AHSA,ADGA,AENA,ACHA,ARwBA,AGTA,ACHA,AFMA,ADGA,A3DiLA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,ARwBA,AHSA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AJYA,AFMA,AnByDA,AsClHA,AxBwEA,AV8BA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,AuCrHA,AHSA,ADGA,AENA,ACHA,ARwBA,AGTA,ACHA,AFMA,ADGA,A3DiLA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ANkBA,AKfA,AJYA,AFMA,AnByDA,AsClHA,AxBwEA,AV8BA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,AuCrHA,AHSA,ADGA,AENA,ACHA,ARwBA,AGTA,ACHA,AFMA,ADGA,AS3BA,ApE4MA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AJYA,AFMA,AnByDA,AsClHA,AxBwEA,AV8BA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,AuCrHA,AHSA,ADGA,AENA,ACHA,ARwBA,AGTA,ACHA,AFMA,ADGA,AS3BA,ApE4MA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AJYA,AFMA,AnByDA,AsClHA,AxBwEA,AV8BA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,AuCrHA,AHSA,ADGA,AENA,ACHA,ARwBA,AGTA,ACHA,AFMA,ADGA,AS3BA,ApE4MA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,AU9BA,AKfA;A6CtIA,AavCA,ALeA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,AsClHA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,AuCrHA,AHSA,ADGA,AENA,ACHA,ARwBA,AGTA,ACHA,AFMA,ADGA,AS3BA,ApE4MA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,AU9BA,AKfA;A6CtIA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,AsClHA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,AuCrHA,AHSA,ADGA,AENA,ACHA,ARwBA,AGTA,ACHA,AFMA,ADGA,AS3BA,ApE4MA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,AU9BA,AKfA;A6CtIA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,AsClHA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,AuCrHA,AHSA,ADGA,AENA,ACHA,ARwBA,AGTA,ACHA,AFMA,ADGA,AS3BA,ApE4MA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,AU9BA,AKfA;A6CtIA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,AuCrHA,ADGA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,AuCrHA,AHSA,ADGA,AENA,ACHA,ARwBA,AGTA,ACHA,AFMA,ADGA,AS3BA,ApE4MA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,AU9BA,AKfA;A6CtIA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,AuCrHA,ADGA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,AuCrHA,AHSA,ADGA,AENA,ACHA,ARwBA,AGTA,ACHA,AFMA,ADGA,AS3BA,ApE4MA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,AU9BA,AKfA;A6CtIA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,AuCrHA,ADGA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,AuCrHA,AHSA,ADGA,AENA,ACHA,ARwBA,AGTA,ACHA,AFMA,ADGA,AS3BA,ApE4MA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,AU9BA,AKfA;A6CtIA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,AuCrHA,ADGA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,AuCrHA,AHSA,ACHA,ACHA,AKfA,AbuCA,AGTA,ACHA,AFMA,ADGA,AS3BA,ApE4MA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,AU9BA,AKfA;A6CtIA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,AuCrHA,ADGA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,AuCrHA,AHSA,ACHA,ACHA,AKfA,AbuCA,AGTA,ACHA,AFMA,ADGA,AS3BA,ApE4MA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,AU9BA,AKfA;A6CtIA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,AuCrHA,ADGA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,AuCrHA,AHSA,ACHA,ACHA,AKfA,AbuCA,AGTA,ACHA,AFMA,ADGA,AS3BA,ApE4MA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,AU9BA,AKfA;A6CtIA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,AuCrHA,ADGA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,AuCrHA,AHSA,ACHA,ACHA,AKfA,ACHA,Ad0CA,AGTA,ACHA,AFMA,ADGA,AS3BA,ApE4MA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,AU9BA,AKfA;A6CtIA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,AuCrHA,ADGA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,AuCrHA,AHSA,ACHA,ACHA,AKfA,ACHA,Ad0CA,AGTA,ACHA,AFMA,ADGA,AS3BA,ApE4MA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,AU9BA,AKfA;A6CtIA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,AuCrHA,ADGA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,AuCrHA,AHSA,ACHA,ACHA,AKfA,ACHA,Ad0CA,AGTA,ACHA,AFMA,ADGA,AS3BA,ApE4MA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,AU9BA,AKfA;A6CtIA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,AuCrHA,ADGA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,AuCrHA,AHSA,ACHA,ACHA,AOrBA,AFMA,ACHA,Ad0CA,AGTA,ACHA,AFMA,ADGA,AS3BA,ApE4MA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,AU9BA,AKfA;A6CtIA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,AuCrHA,ADGA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,AuCrHA,AHSA,ACHA,ACHA,AOrBA,AFMA,ACHA,Ad0CA,AGTA,ACHA,AFMA,ADGA,AS3BA,ApE4MA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,AU9BA,AKfA;A6CtIA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,AuCrHA,ADGA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,ADGA,AuCrHA,AHSA,ACHA,ACHA,AOrBA,ADGA,Ad0CA,AGTA,ACHA,AFMA,ADGA,AS3BA,ApE4MA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,AU9BA,AKfA;A6CtIA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,AuCrHA,ADGA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,AsClHA,AHSA,ACHA,ACHA,AOrBA,ACHA,AFMA,Ad0CA,AGTA,ACHA,AFMA,ADGA,AS3BA,ApE4MA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,AU9BA,AKfA;A6CtIA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,AuCrHA,ADGA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,AmCzGA,ACHA,ACHA,AOrBA,ACHA,AhBgDA,AIZA,AFMA,ADGA,AS3BA,ApE4MA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,AU9BA,AKfA;A6CtIA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,AuCrHA,ADGA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,AmCzGA,ACHA,ACHA,AOrBA,ACHA,AhBgDA,AIZA,AFMA,ADGA,AS3BA,ApE4MA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,AU9BA,AKfA;A6CtIA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,AuCrHA,AKfA,ANkBA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,AoC5GA,ACHA,AOrBA,ACHA,AhBgDA,AIZA,AFMA,ADGA,AS3BA,ApE4MA,AS3BA,AHSA,AQxBA,AXiCA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,AU9BA,AKfA;A6CtIA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,AuCrHA,AKfA,ANkBA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,AoC5GA,ACHA,AQxBA,AhBgDA,AIZA,AFMA,ADGA,AS3BA,ApE4MA,AS3BA,AHSA,AHSA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,AuCrHA,AKfA,ANkBA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,AoC5GA,ACHA,AQxBA,AhBgDA,AIZA,AFMA,ADGA,AS3BA,ApE4MA,AS3BA,AHSA,AHSA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,A6CvIA,ANkBA,AKfA,ANkBA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,AoC5GA,ACHA,AQxBA,AhBgDA,AIZA,AFMA,ADGA,AS3BA,ApE4MA,AS3BA,AHSA,AHSA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,A6CvIA,ANkBA,AKfA,ANkBA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,AoC5GA,ACHA,AQxBA,AhBgDA,AIZA,AFMA,ADGA,AS3BA,ApE4MA,AS3BA,AHSA,AHSA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,A6CvIA,ANkBA,AKfA,ANkBA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,AoC5GA,ACHA,AQxBA,AhBgDA,AIZA,AFMA,ADGA,AS3BA,ApE4MA,AS3BA,AHSA,AHSA,ADGA,AMlBA,AKfA,ADGA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,A6CvIA,ANkBA,AKfA,ANkBA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,AqC/GA,AQxBA,AhBgDA,AIZA,AFMA,ADGA,AS3BA,AS3BA,A7EuOA,AS3BA,AHSA,AHSA,ADGA,AMlBA,AIZA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,A6CvIA,ANkBA,AKfA,ANkBA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,AqC/GA,AQxBA,AhBgDA,AIZA,AHSA,AS3BA,AS3BA,A7EuOA,AS3BA,AHSA,AHSA,ADGA,AMlBA,AIZA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,A6CvIA,ANkBA,AKfA,ANkBA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,AqC/GA,AQxBA,AhBgDA,AIZA,AHSA,AS3BA,AS3BA,A7EuOA,AS3BA,AHSA,AHSA,ADGA,AMlBA,AIZA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,A6CvIA,ANkBA,AKfA,ANkBA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,AiDnJA,AZoCA,AQxBA,AhBgDA,AIZA,AHSA,AS3BA,AS3BA,A7EuOA,AS3BA,AHSA,AHSA,ADGA,AMlBA,AIZA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,A6CvIA,ANkBA,AKfA,ANkBA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,AiDnJA,AZoCA,AQxBA,AhBgDA,AIZA,AHSA,AS3BA,AS3BA,A7EuOA,AS3BA,AHSA,AHSA,ADGA,AMlBA,AIZA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,A6CvIA,ANkBA,AKfA,ANkBA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,AiDnJA,AZoCA,AQxBA,AhBgDA,AIZA,AHSA,AS3BA,AS3BA,A7EuOA,AS3BA,AHSA,AJYA,AMlBA,AIZA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,A6CvIA,ADGA,ANkBA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,AiDnJA,AZoCA,AQxBA,AhBgDA,AIZA,AHSA,AoB5DA,AXiCA,AS3BA,A7EuOA,AS3BA,AHSA,AJYA,AMlBA,AIZA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,A6CvIA,ADGA,ANkBA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,AiDnJA,AZoCA,AQxBA,AhBgDA,AIZA,AHSA,AoB5DA,AXiCA,AS3BA,A7EuOA,AS3BA,AHSA,AJYA,AMlBA,AIZA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,A6CvIA,ADGA,ANkBA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,AiDnJA,AZoCA,AQxBA,AhBgDA,AIZA,AHSA,AoB5DA,AXiCA,AS3BA,A7EuOA,AS3BA,AHSA,AJYA,AMlBA,AIZA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AQxBA,AFMA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,A6CvIA,ADGA,ANkBA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,AiDnJA,AZoCA,AQxBA,AhBgDA,AIZA,AkBtDA,ArB+DA,AoB5DA,AXiCA,AS3BA,A7EuOA,AS3BA,AHSA,AJYA,AMlBA,AIZA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,A6CvIA,ADGA,ANkBA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,AiDnJA,AZoCA,AQxBA,AhBgDA,AIZA,AkBtDA,ArB+DA,AoB5DA,AXiCA,AS3BA,A7EuOA,AS3BA,AHSA,AJYA,AMlBA,AIZA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,A6CvIA,ADGA,ANkBA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,AiDnJA,AZoCA,AQxBA,AhBgDA,AIZA,AkBtDA,ArB+DA,AoB5DA,AXiCA,AS3BA,A7EuOA,AS3BA,AHSA,AJYA,AMlBA,AIZA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,A6CvIA,ADGA,ANkBA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,AiDnJA,AZoCA,Ae7CA,APqBA,AhBgDA,AIZA,AkBtDA,ArB+DA,AoB5DA,AXiCA,AS3BA,A7EuOA,AS3BA,AHSA,AJYA,AMlBA,AIZA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,A6CvIA,ADGA,ANkBA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,AiDnJA,AZoCA,Ae7CA,APqBA,AhBgDA,AIZA,AkBtDA,ArB+DA,AoB5DA,AXiCA,AS3BA,ApE4MA,AHSA,AJYA,AMlBA,AIZA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,A6CvIA,ADGA,ANkBA,AhDgJA,AKfA,ANkBA,AENA,ACHA,AMlBA,AiDnJA,AZoCA,Ae7CA,APqBA,AhBgDA,AIZA,AkBtDA,ArB+DA,AoB5DA,AXiCA,AS3BA,ApE4MA,AHSA,AJYA,AMlBA,AIZA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,AmDzJA,ANkBA,ADGA,ANkBA,AhDgJA,AKfA,AJYA,ACHA,AMlBA,AiDnJA,AZoCA,Ae7CA,APqBA,AhBgDA,AIZA,AkBtDA,ArB+DA,AoB5DA,AXiCA,AS3BA,ApE4MA,AHSA,AJYA,AMlBA,AIZA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,ANkBA,AnByDA,AsClHA,AxBwEA,AmDzJA,ANkBA,ADGA,ANkBA,AhDgJA,AKfA,AJYA,ACHA,AMlBA,AiDnJA,AZoCA,Ae7CA,APqBA,AhBgDA,AIZA,AkBtDA,ADGA,AXiCA,AS3BA,ApE4MA,AHSA,AJYA,AMlBA,AIZA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,AsClHA,AxBwEA,AmDzJA,ANkBA,ADGA,ANkBA,AhDgJA,AKfA,AJYA,ACHA,AMlBA,AiDnJA,AZoCA,Ae7CA,APqBA,AhBgDA,AIZA,AkBtDA,ADGA,AXiCA,AS3BA,ApE4MA,AHSA,AJYA,AMlBA,AIZA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,AsClHA,AxBwEA,AmDzJA,ANkBA,ADGA,ANkBA,AhDgJA,AKfA,AJYA,ACHA,AMlBA,AiDnJA,AKfA,AjBmDA,Ae7CA,APqBA,AhBgDA,AIZA,AkBtDA,ADGA,AXiCA,AS3BA,ApE4MA,AHSA,AJYA,AMlBA,AIZA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,AsClHA,AxBwEA,AmDzJA,ANkBA,ADGA,ANkBA,AhDgJA,AKfA,AJYA,ACHA,AMlBA,AiDnJA,AKfA,AjBmDA,Ae7CA,APqBA,AhBgDA,AIZA,AkBtDA,ADGA,AXiCA,AS3BA,ApE4MA,AHSA,AJYA,AMlBA,AIZA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,AsClHA,AxBwEA,AmDzJA,ANkBA,ADGA,ANkBA,AhDgJA,AKfA,AJYA,ACHA,AMlBA,AiDnJA,AKfA,AjBmDA,Ae7CA,APqBA,AhBgDA,AIZA,AkBtDA,ADGA,AXiCA,AS3BA,ApE4MA,AHSA,AJYA,AMlBA,AIZA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,AsClHA,AxBwEA,AmDzJA,ANkBA,ADGA,ANkBA,AhDgJA,AKfA,AJYA,ACHA,AMlBA,AiDnJA,AKfA,ACHA,AlBsDA,Ae7CA,APqBA,AhBgDA,AIZA,AkBtDA,ADGA,AXiCA,AS3BA,ApE4MA,AHSA,AJYA,AMlBA,AIZA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,AsClHA,AxBwEA,AmDzJA,ANkBA,ADGA,ANkBA,AhDgJA,AKfA,AJYA,ACHA,AMlBA,AiDnJA,AKfA,ACHA,AlBsDA,Ae7CA,APqBA,AhBgDA,AIZA,AkBtDA,ADGA,AFMA,ApE4MA,AHSA,AJYA,AMlBA,AIZA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,AsClHA,AxBwEA,AmDzJA,ANkBA,ADGA,ANkBA,AhDgJA,AKfA,AJYA,ACHA,AMlBA,AiDnJA,AKfA,ACHA,AlBsDA,Ae7CA,APqBA,AhBgDA,AIZA,AkBtDA,ADGA,AFMA,ApE4MA,AHSA,AJYA,AMlBA,AIZA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,AsClHA,AxBwEA,AmDzJA,ANkBA,ADGA,ANkBA,AhDgJA,AKfA,AJYA,ACHA,AMlBA,AiDnJA,AKfA,ACHA,ACHA,AnByDA,Ae7CA,APqBA,AhBgDA,AIZA,AkBtDA,ADGA,AFMA,ApE4MA,AHSA,AJYA,AMlBA,AIZA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,AsClHA,AxBwEA,AmDzJA,ANkBA,ADGA,ANkBA,AhDgJA,AKfA,AJYA,ACHA,AMlBA,AiDnJA,AKfA,ACHA,ACHA,AnByDA,Ae7CA,APqBA,AhBgDA,AIZA,AkBtDA,ADGA,AFMA,ApE4MA,AHSA,AJYA,AMlBA,AIZA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,AsClHA,AxBwEA,AmDzJA,ANkBA,ADGA,ANkBA,AhDgJA,AKfA,AJYA,ACHA,AMlBA,AiDnJA,AKfA,ACHA,ACHA,AnByDA,Ae7CA,APqBA,AhBgDA,AIZA,AkBtDA,ADGA,AFMA,ApE4MA,AHSA,AJYA,AMlBA,AIZA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,AsClHA,AxBwEA,AmDzJA,ANkBA,ADGA,ANkBA,AiBnDA,AjEmMA,AKfA,AJYA,ACHA,AMlBA,AiDnJA,AKfA,ACHA,ACHA,AnByDA,Ae7CA,APqBA,AhBgDA,AIZA,AkBtDA,ADGA,AFMA,ApE4MA,AHSA,AJYA,AMlBA,AIZA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,AsClHA,AxBwEA,AmDzJA,ANkBA,ADGA,ANkBA,AiBnDA,AjEmMA,AKfA,AJYA,ACHA,AMlBA,AiDnJA,AKfA,ACHA,ACHA,AnByDA,Ae7CA,APqBA,AhBgDA,AIZA,AkBtDA,ADGA,AFMA,ApE4MA,AHSA,AJYA,AMlBA,AIZA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,AsClHA,AxBwEA,AmDzJA,ANkBA,ADGA,ANkBA,AiBnDA,AjEmMA,AKfA,AJYA,ACHA,AMlBA,AiDnJA,AKfA,ACHA,ACHA,AnByDA,Ae7CA,APqBA,AhBgDA,AIZA,AkBtDA,ADGA,AFMA,ApE4MA,AHSA,AJYA,AMlBA,AIZA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,AsClHA,AxBwEA,AmDzJA,ANkBA,ADGA,ANkBA,AiBnDA,AjEmMA,AKfA,AJYA,ACHA,AMlBA,AiDnJA,AKfA,ACHA,ACHA,AnByDA,Ae7CA,APqBA,AhBgDA,AIZA,AkBtDA,AOrBA,ARwBA,AFMA,ApE4MA,AHSA,AJYA,AMlBA,AIZA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,AsClHA,AxBwEA,AmDzJA,ANkBA,ADGA,ANkBA,AiBnDA,AjEmMA,AKfA,AJYA,ACHA,AMlBA,AiDnJA,AKfA,ACHA,ACHA,AnByDA,Ae7CA,APqBA,AhBgDA,AIZA,AkBtDA,AOrBA,ARwBA,AFMA,ApE4MA,AHSA,AJYA,AMlBA,AIZA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,AsClHA,AxBwEA,AmDzJA,ANkBA,ADGA,ANkBA,AiBnDA,AjEmMA,AKfA,AJYA,ACHA,AMlBA,AiDnJA,AKfA,ACHA,ACHA,AnByDA,Ae7CA,APqBA,AhBgDA,AIZA,AkBtDA,AOrBA,ARwBA,AFMA,ApE4MA,AHSA,AENA,AIZA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,AsClHA,AxBwEA,AmDzJA,ANkBA,ADGA,ANkBA,AmBzDA,AFMA,AjEmMA,AKfA,AJYA,ACHA,AMlBA,AiDnJA,AKfA,ACHA,ACHA,AnByDA,Ae7CA,APqBA,AhBgDA,AIZA,AkBtDA,AOrBA,ARwBA,AFMA,ApE4MA,AHSA,AENA,AIZA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,AsClHA,AxBwEA,AmDzJA,ANkBA,ADGA,ANkBA,AmBzDA,AFMA,AjEmMA,AKfA,AJYA,ACHA,AMlBA,AiDnJA,AKfA,ACHA,ACHA,AnByDA,Ae7CA,APqBA,AhBgDA,AIZA,AkBtDA,AOrBA,ARwBA,AFMA,ApE4MA,AHSA,AENA,AIZA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,AsClHA,AxBwEA,AmDzJA,ANkBA,ADGA,ANkBA,AmBzDA,AFMA,AjEmMA,AKfA,AHSA,AMlBA,AiDnJA,AKfA,ACHA,ACHA,AnByDA,Ae7CA,APqBA,AhBgDA,AIZA,AkBtDA,AOrBA,ARwBA,AFMA,ApE4MA,AHSA,AENA,AIZA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,AsClHA,AxBwEA,AmDzJA,ANkBA,ADGA,ANkBA,AmBzDA,AFMA,AjEmMA,AKfA,AGTA,AiDnJA,AKfA,ACHA,ACHA,AnByDA,Ae7CA,APqBA,AhBgDA,AIZA,AkBtDA,AOrBA,AENA,AV8BA,AFMA,ApE4MA,AHSA,AENA,AIZA,ARwBA,AXiCA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,AsClHA,AxBwEA,AmDzJA,ANkBA,ADGA,ANkBA,AmBzDA,AFMA,AjEmMA,AKfA,AGTA,AiDnJA,AKfA,ACHA,ACHA,AnByDA,Ae7CA,APqBA,AZoCA,AkBtDA,AOrBA,AENA,AV8BA,AFMA,ApE4MA,AHSA,AENA,AIZA,AnByDA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,AsClHA,AxBwEA,AmDzJA,ANkBA,ADGA,ANkBA,AmBzDA,AFMA,AjEmMA,AKfA,AGTA,AiDnJA,AKfA,ACHA,ACHA,AnByDA,Ae7CA,APqBA,AZoCA,AkBtDA,AOrBA,AENA,AV8BA,AFMA,ApE4MA,AHSA,AENA,AIZA,AnByDA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,AsClHA,AxBwEA,AmDzJA,ANkBA,ADGA,ANkBA,AmBzDA,AFMA,AjEmMA,AKfA,AGTA,AiDnJA,AKfA,ACHA,ACHA,AKfA,AxBwEA,Ae7CA,APqBA,AZoCA,AkBtDA,AOrBA,AENA,AV8BA,AFMA,ApE4MA,AHSA,AENA,AIZA,AnByDA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,AsClHA,AxBwEA,AmDzJA,ANkBA,APqBA,AmBzDA,AFMA,AjEmMA,AKfA,AGTA,AsDlKA,ACHA,ACHA,AKfA,AxBwEA,Ae7CA,APqBA,AZoCA,AkBtDA,AOrBA,AENA,AV8BA,AFMA,ApE4MA,AHSA,AENA,AIZA,AnByDA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,Ac1CA,AmDzJA,ANkBA,APqBA,AmBzDA,AFMA,AjEmMA,AKfA,AGTA,AsDlKA,ACHA,ACHA,AKfA,AxBwEA,Ae7CA,APqBA,AZoCA,AkBtDA,AOrBA,AENA,AV8BA,AFMA,ApE4MA,AHSA,AENA,AIZA,AnByDA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,Ac1CA,AmDzJA,ANkBA,APqBA,AmBzDA,AFMA,AjEmMA,AKfA,AGTA,AsDlKA,ACHA,ACHA,AKfA,AxBwEA,Ae7CA,APqBA,AiBnDA,A7BuFA,AkBtDA,AOrBA,AENA,AV8BA,AFMA,ApE4MA,AHSA,AENA,AIZA,AnByDA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,ALeA,ACHA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,Ac1CA,AmDzJA,ANkBA,APqBA,AmBzDA,AFMA,AjEmMA,AKfA,AGTA,AsDlKA,ACHA,ACHA,AKfA,AxBwEA,Ae7CA,APqBA,AiBnDA,A7BuFA,AkBtDA,AOrBA,AENA,AV8BA,AFMA,ApE4MA,AHSA,AENA,AIZA,AnByDA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,AJYA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,Ac1CA,AmDzJA,ANkBA,APqBA,AmBzDA,AFMA,AjEmMA,AKfA,AGTA,AsDlKA,ACHA,ACHA,AKfA,AxBwEA,Ae7CA,APqBA,AiBnDA,A7BuFA,AkBtDA,AOrBA,AENA,AV8BA,AFMA,ApE4MA,AHSA,AENA,AIZA,AnByDA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,AJYA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,Ac1CA,AmDzJA,ANkBA,APqBA,AmBzDA,AFMA,AjEmMA,AKfA,AGTA,AsDlKA,ACHA,ACHA,AKfA,AxBwEA,Ae7CA,APqBA,AkBtDA,ADGA,A7BuFA,AkBtDA,AOrBA,AENA,AV8BA,AFMA,ApE4MA,AHSA,AENA,AIZA,AnByDA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,AJYA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,Ac1CA,AmDzJA,ANkBA,APqBA,AmBzDA,AFMA,AjEmMA,AKfA,AGTA,AsDlKA,ACHA,ACHA,AKfA,AxBwEA,Ae7CA,APqBA,AkBtDA,ADGA,A7BuFA,AkBtDA,AOrBA,AENA,AV8BA,AFMA,ApE4MA,AHSA,AENA,AIZA,AnByDA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,AJYA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,Ac1CA,AmDzJA,ANkBA,APqBA,AmBzDA,AFMA,AjEmMA,AKfA,AGTA,AsDlKA,ACHA,ACHA,AKfA,AxBwEA,Ae7CA,APqBA,AkBtDA,ADGA,A7BuFA,AkBtDA,AOrBA,AENA,AV8BA,AFMA,ApE4MA,AHSA,AENA,AIZA,AnByDA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,AJYA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,Ac1CA,A8D1LA,AXiCA,ANkBA,APqBA,AmBzDA,AFMA,AjEmMA,AKfA,AGTA,AsDlKA,ACHA,ACHA,AKfA,AxBwEA,Ae7CA,APqBA,AkBtDA,ADGA,A7BuFA,AkBtDA,AOrBA,AENA,AV8BA,AFMA,ApE4MA,AHSA,AENA,AIZA,AnByDA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,AJYA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,Ac1CA,A8D1LA,AXiCA,ANkBA,APqBA,AmBzDA,AFMA,AjEmMA,AKfA,AGTA,AsDlKA,ACHA,ACHA,AKfA,AxBwEA,Ae7CA,APqBA,AkBtDA,ADGA,A7BuFA,AkBtDA,AOrBA,AENA,AV8BA,AFMA,ApE4MA,AHSA,AENA,AIZA,AnByDA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,AJYA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,APqBA,AmBzDA,AFMA,AjEmMA,AKfA,AGTA,AsDlKA,ACHA,ACHA,AKfA,AxBwEA,Ae7CA,APqBA,AkBtDA,ADGA,A7BuFA,AkBtDA,AOrBA,AENA,AV8BA,AFMA,ApE4MA,AHSA,AENA,AIZA,AnByDA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,AJYA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AKfA,AGTA,AsDlKA,ACHA,ACHA,AKfA,AxBwEA,Ae7CA,APqBA,AkBtDA,ADGA,A7BuFA,AkBtDA,AOrBA,AENA,AV8BA,AFMA,ApE4MA,AHSA,AENA,AIZA,AnByDA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,AJYA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AKfA,AGTA,AsDlKA,ACHA,ACHA,AKfA,AxBwEA,Ae7CA,APqBA,AkBtDA,ADGA,A7BuFA,AkBtDA,AOrBA,AENA,AV8BA,AtEkNA,AHSA,AENA,AIZA,AnByDA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,AJYA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AKfA,AGTA,AsDlKA,ACHA,ACHA,AKfA,AxBwEA,Ae7CA,APqBA,AkBtDA,ADGA,A7BuFA,AkBtDA,AOrBA,AENA,AV8BA,AtEkNA,AHSA,AENA,AIZA,AnByDA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,AJYA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AKfA,AGTA,AkEtMA,AZoCA,ACHA,ACHA,AKfA,AxBwEA,Ae7CA,APqBA,AkBtDA,ADGA,A7BuFA,AkBtDA,AOrBA,AENA,AV8BA,AtEkNA,ADGA,AIZA,AnByDA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,AJYA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AKfA,AGTA,AkEtMA,AZoCA,ACHA,ACHA,AKfA,AxBwEA,Ae7CA,APqBA,AkBtDA,ADGA,A7BuFA,AkBtDA,AOrBA,AENA,AV8BA,AtEkNA,ADGA,AIZA,AnByDA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,AJYA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AKfA,AGTA,AkEtMA,AZoCA,ACHA,ACHA,AKfA,AxBwEA,Ae7CA,APqBA,AkBtDA,ADGA,A7BuFA,AkBtDA,AOrBA,AENA,AV8BA,AtEkNA,ADGA,AIZA,AnByDA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,AJYA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AKfA,AGTA,AkEtMA,AZoCA,ACHA,ACHA,AKfA,AMlBA,A9B0FA,Ae7CA,APqBA,AkBtDA,ADGA,A7BuFA,AkBtDA,AOrBA,AENA,AV8BA,AtEkNA,ADGA,AIZA,AnByDA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,AJYA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AKfA,AGTA,AkEtMA,AZoCA,ACHA,ACHA,AKfA,AMlBA,A9B0FA,Ae7CA,APqBA,AkBtDA,ADGA,A7BuFA,AkBtDA,AOrBA,AENA,AV8BA,AtEkNA,ADGA,AIZA,AnByDA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,AJYA,AHSA,AIZA,AhBgDA,AMlBA,AENA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AKfA,AGTA,AkEtMA,AZoCA,ACHA,ACHA,AKfA,AMlBA,A9B0FA,Ae7CA,APqBA,AkBtDA,ADGA,A7BuFA,AkBtDA,AOrBA,AENA,AV8BA,AtEkNA,ADGA,AIZA,AnByDA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,AJYA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AKfA,AGTA,AkEtMA,AZoCA,ACHA,ACHA,AKfA,AOrBA,ADGA,A9B0FA,Ae7CA,APqBA,AkBtDA,ADGA,A7BuFA,AkBtDA,AOrBA,AENA,AV8BA,AtEkNA,ADGA,Af6CA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,AJYA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AKfA,AGTA,AkEtMA,AZoCA,ACHA,ACHA,AKfA,AOrBA,ADGA,A9B0FA,Ae7CA,APqBA,AkBtDA,ADGA,A7BuFA,AkBtDA,AOrBA,AENA,AV8BA,AtEkNA,ADGA,Af6CA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,AJYA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AKfA,AGTA,AkEtMA,AZoCA,ACHA,ACHA,AKfA,AOrBA,ADGA,A9B0FA,Ae7CA,AWjCA,ADGA,A7BuFA,AkBtDA,AOrBA,AENA,AV8BA,AtEkNA,ADGA,Af6CA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,AJYA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AKfA,AGTA,AkEtMA,AZoCA,ACHA,ACHA,AKfA,AOrBA,ADGA,A9B0FA,Ae7CA,AWjCA,ADGA,A7BuFA,AoC5GA,AlBsDA,AOrBA,AENA,AV8BA,AtEkNA,ADGA,Af6CA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AENA,AJYA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AKfA,AGTA,AkEtMA,AZoCA,ACHA,ACHA,AKfA,AOrBA,ADGA,A9B0FA,Ae7CA,AWjCA,ADGA,A7BuFA,AoC5GA,AlBsDA,AOrBA,AENA,AV8BA,AtEkNA,ADGA,Af6CA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AKfA,AGTA,AkEtMA,AZoCA,ACHA,ACHA,AKfA,AOrBA,ADGA,A9B0FA,Ae7CA,AWjCA,ADGA,A7BuFA,AoC5GA,AlBsDA,AOrBA,AENA,AV8BA,AtEkNA,ADGA,Af6CA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AKfA,AGTA,AkEtMA,AZoCA,ACHA,ACHA,Ac1CA,AT2BA,AOrBA,ADGA,A9B0FA,Ae7CA,AWjCA,ADGA,A7BuFA,AoC5GA,AlBsDA,AOrBA,AENA,AV8BA,AtEkNA,ADGA,Af6CA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AKfA,AGTA,AkEtMA,AZoCA,ACHA,ACHA,Ac1CA,AT2BA,AOrBA,ADGA,A9B0FA,Ae7CA,AWjCA,ADGA,A7BuFA,AoC5GA,AlBsDA,AS3BA,AV8BA,AtEkNA,ADGA,Af6CA,AuBrEA,AzB2EA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AKfA,AGTA,AkEtMA,AZoCA,ACHA,ACHA,Ac1CA,AT2BA,AOrBA,ADGA,A9B0FA,Ae7CA,AWjCA,ADGA,A7BuFA,AoC5GA,AlBsDA,AS3BA,AV8BA,AtEkNA,ADGA,Af6CA,AFMA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AQxBA,AkEtMA,AZoCA,ACHA,ACHA,Ac1CA,AT2BA,AOrBA,ADGA,AIZA,AlCsGA,Ae7CA,AWjCA,ADGA,A7BuFA,AoC5GA,AlBsDA,AS3BA,AhFgPA,ADGA,Af6CA,AFMA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AQxBA,AkEtMA,AZoCA,ACHA,ACHA,Ac1CA,AT2BA,AOrBA,ADGA,AIZA,AlCsGA,Ae7CA,AWjCA,ADGA,A7BuFA,AoC5GA,AlBsDA,AS3BA,AhFgPA,ADGA,Af6CA,AFMA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AQxBA,AkEtMA,AZoCA,ACHA,ACHA,Ac1CA,AT2BA,AOrBA,ADGA,AIZA,AlCsGA,Ae7CA,AWjCA,ADGA,A7BuFA,AoC5GA,AlBsDA,AS3BA,AhFgPA,ADGA,Af6CA,AFMA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AZoCA,ACHA,ACHA,Ac1CA,AT2BA,AOrBA,ADGA,AIZA,AlCsGA,Ae7CA,AWjCA,ADGA,A7BuFA,AoC5GA,AlBsDA,AS3BA,AhFgPA,ADGA,Af6CA,AFMA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AXiCA,ACHA,Ac1CA,AT2BA,AOrBA,ADGA,AIZA,AlCsGA,Ae7CA,AWjCA,ADGA,A7BuFA,AoC5GA,AlBsDA,AS3BA,AhFgPA,ADGA,Af6CA,AFMA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AXiCA,ACHA,Ac1CA,AT2BA,AOrBA,ADGA,AIZA,AlCsGA,Ae7CA,AWjCA,ADGA,A7BuFA,AoC5GA,AlBsDA,AS3BA,AhFgPA,ADGA,Af6CA,AFMA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AXiCA,ACHA,Ac1CA,AT2BA,AOrBA,ADGA,AIZA,AENA,ApC4GA,Ae7CA,AWjCA,ADGA,A7BuFA,AoC5GA,AlBsDA,AS3BA,AhFgPA,ADGA,Af6CA,AFMA,AXiCA,Ae7CA;A6CtIA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AXiCA,ACHA,Ac1CA,AT2BA,AOrBA,ADGA,AIZA,AENA,ApC4GA,Ae7CA,AWjCA,ADGA,A7BuFA,AoC5GA,AlBsDA,AS3BA,AhFgPA,ADGA,Af6CA,AFMA,AXiCA;A4DnLA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AXiCA,ACHA,Ac1CA,AT2BA,AOrBA,ADGA,AIZA,AENA,ApC4GA,Ae7CA,AWjCA,ADGA,A7BuFA,AoC5GA,AlBsDA,AS3BA,AhFgPA,ADGA,Af6CA,AFMA,AXiCA;A4DnLA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AXiCA,ACHA,AkBtDA,AJYA,AT2BA,AOrBA,ADGA,AIZA,AENA,ApC4GA,Ae7CA,AWjCA,ADGA,A7BuFA,AoC5GA,AlBsDA,AS3BA,AhFgPA,ADGA,Af6CA,AFMA,AXiCA;A4DnLA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AXiCA,ACHA,AkBtDA,AJYA,AT2BA,AOrBA,ADGA,AIZA,AENA,ApC4GA,Ae7CA,AWjCA,ADGA,A7BuFA,AoC5GA,AlBsDA,AS3BA,AhFgPA,ADGA,Af6CA,AFMA,AXiCA;A4DnLA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AXiCA,ACHA,AkBtDA,AJYA,AT2BA,AOrBA,ADGA,AIZA,AENA,ApC4GA,Ae7CA,AWjCA,ADGA,A7BuFA,AoC5GA,AlBsDA,AS3BA,AhFgPA,ADGA,Af6CA,AFMA,AXiCA;A4DnLA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AXiCA,ACHA,AkBtDA,AJYA,AT2BA,AOrBA,AGTA,AENA,ApC4GA,Ae7CA,AWjCA,AYpCA,AbuCA,A7BuFA,AoC5GA,AlBsDA,AS3BA,AhFgPA,ADGA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AXiCA,ACHA,AkBtDA,AJYA,AT2BA,AOrBA,AGTA,AENA,ApC4GA,Ae7CA,AWjCA,AYpCA,AbuCA,A7BuFA,AoC5GA,AlBsDA,AS3BA,AhFgPA,ADGA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AXiCA,ACHA,AkBtDA,AJYA,AT2BA,AOrBA,AGTA,AENA,ApC4GA,Ae7CA,AWjCA,AYpCA,AbuCA,A7BuFA,AoC5GA,AlBsDA,AS3BA,AhFgPA,ADGA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AXiCA,ACHA,AkBtDA,AJYA,AT2BA,AOrBA,AGTA,AENA,ApC4GA,Ae7CA,AwBxEA,AbuCA,AYpCA,AbuCA,A7BuFA,AoC5GA,AlBsDA,AS3BA,AhFgPA,ADGA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AXiCA,ACHA,AkBtDA,AJYA,AT2BA,AOrBA,AGTA,AENA,ApC4GA,Ae7CA,AwBxEA,AbuCA,AYpCA,AbuCA,A7BuFA,AoC5GA,AlBsDA,AS3BA,AhFgPA,ADGA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AV8BA,AkBtDA,AJYA,AT2BA,AOrBA,AGTA,AENA,ApC4GA,Ae7CA,AwBxEA,AbuCA,AYpCA,AbuCA,A7BuFA,AoC5GA,AlBsDA,AS3BA,AhFgPA,ADGA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AV8BA,AkBtDA,AJYA,AT2BA,AOrBA,AGTA,AENA,AIZA,AxCwHA,Ae7CA,AwBxEA,AbuCA,AYpCA,AbuCA,A7BuFA,AoC5GA,AlBsDA,AvEqNA,ADGA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AV8BA,AkBtDA,AJYA,AT2BA,AOrBA,AGTA,AENA,AIZA,AxCwHA,Ae7CA,AwBxEA,AbuCA,AYpCA,AbuCA,A7BuFA,AoC5GA,AlBsDA,AvEqNA,ADGA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AV8BA,AkBtDA,AJYA,AT2BA,AOrBA,AGTA,AENA,AIZA,AxCwHA,Ae7CA,AwBxEA,ADGA,AbuCA,A7BuFA,AoC5GA,AlBsDA,AvEqNA,ADGA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AV8BA,AkBtDA,AJYA,AT2BA,AOrBA,AGTA,AENA,AIZA,AxCwHA,Ae7CA,AwBxEA,ADGA,AGTA,AhBgDA,A7BuFA,AoC5GA,AlBsDA,AvEqNA,ADGA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AV8BA,AkBtDA,AJYA,AT2BA,AOrBA,AGTA,AENA,AIZA,AxCwHA,Ae7CA,AwBxEA,ADGA,AGTA,AhBgDA,A7BuFA,AkBtDA,AvEqNA,ADGA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AV8BA,AkBtDA,AJYA,AT2BA,AOrBA,AGTA,AENA,AIZA,AxCwHA,Ae7CA,AwBxEA,ADGA,AGTA,AhBgDA,A7BuFA,AkBtDA,AvEqNA,ADGA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AV8BA,AkBtDA,AJYA,AT2BA,AOrBA,AGTA,AENA,AIZA,AENA,A1C8HA,Ae7CA,AwBxEA,ADGA,AGTA,AhBgDA,A7BuFA,AkBtDA,AvEqNA,ADGA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AV8BA,AkBtDA,AJYA,AT2BA,AOrBA,AGTA,AENA,AIZA,AENA,A1C8HA,Ae7CA,AwBxEA,ADGA,AGTA,AhBgDA,A7BuFA,AkBtDA,AvEqNA,ADGA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AV8BA,AkBtDA,AJYA,AT2BA,AOrBA,AGTA,AENA,AIZA,AENA,A1C8HA,Ae7CA,AwBxEA,ADGA,AGTA,AhBgDA,A7BuFA,AkBtDA,AvEqNA,ADGA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AV8BA,AkBtDA,AJYA,AT2BA,AmBzDA,AZoCA,AGTA,AENA,AIZA,AENA,A1C8HA,Ae7CA,AwBxEA,ADGA,AGTA,AhBgDA,A7BuFA,AkBtDA,AvEqNA,ADGA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AV8BA,AkBtDA,AJYA,AT2BA,AmBzDA,AZoCA,AGTA,AENA,AIZA,AENA,A1C8HA,Ae7CA,AwBxEA,ADGA,AGTA,AhBgDA,A7BuFA,AkBtDA,AvEqNA,ADGA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AV8BA,AkBtDA,AJYA,AT2BA,AmBzDA,AZoCA,AGTA,AENA,AIZA,AENA,A3BiFA,AwBxEA,ADGA,AGTA,AhBgDA,A7BuFA,AkBtDA,AvEqNA,ADGA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AV8BA,AkBtDA,AJYA,AT2BA,AoB5DA,ADGA,AZoCA,AGTA,AENA,AIZA,AENA,A3BiFA,AwBxEA,ADGA,AGTA,AhBgDA,A7BuFA,AkBtDA,AvEqNA,ADGA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AV8BA,AkBtDA,AJYA,AT2BA,AoB5DA,ADGA,AZoCA,AKfA,AIZA,AENA,A3BiFA,AwBxEA,ADGA,AGTA,AhBgDA,A7BuFA,AkBtDA,AvEqNA,ADGA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AjBmDA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AV8BA,AkBtDA,AJYA,AT2BA,AoB5DA,ADGA,AZoCA,AKfA,AIZA,AENA,A3BiFA,AwBxEA,ADGA,AGTA,AhBgDA,A7BuFA,AkBtDA,AvEqNA,ADGA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AkBtDA,AnCyGA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AV8BA,AkBtDA,AJYA,AT2BA,AoB5DA,ADGA,AZoCA,AKfA,AIZA,AENA,A3BiFA,AwBxEA,ADGA,AGTA,AhBgDA,A7BuFA,AkBtDA,AvEqNA,ADGA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AkBtDA,AnCyGA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AV8BA,AkBtDA,AJYA,AT2BA,AoB5DA,ADGA,AZoCA,AKfA,AIZA,AENA,A3BiFA,AwBxEA,ADGA,AGTA,AhBgDA,AXiCA,AvEqNA,ADGA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AkBtDA,AnCyGA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AV8BA,AkBtDA,AJYA,AT2BA,AoB5DA,ADGA,AZoCA,AKfA,AIZA,AENA,A3BiFA,AwBxEA,ADGA,AGTA,AhBgDA,AXiCA,AvEqNA,ADGA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AkBtDA,AnCyGA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AV8BA,AkBtDA,AJYA,AT2BA,AoB5DA,ADGA,AGTA,Af6CA,AKfA,AIZA,AENA,A3BiFA,AwBxEA,ADGA,AGTA,AhBgDA,AXiCA,AvEqNA,ADGA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AkBtDA,AnCyGA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AV8BA,AkBtDA,AJYA,AWjCA,ADGA,AGTA,Af6CA,AKfA,AIZA,AENA,A3BiFA,AwBxEA,ADGA,AGTA,AhBgDA,AXiCA,AvEqNA,ADGA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AkBtDA,AnCyGA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AV8BA,AkBtDA,AJYA,AWjCA,ADGA,AGTA,Af6CA,AKfA,AIZA,AENA,A3BiFA,AwBxEA,ADGA,AGTA,AhBgDA,AXiCA,AvEqNA,ADGA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AkBtDA,AnCyGA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AV8BA,AkBtDA,AU9BA,Ad0CA,AWjCA,ADGA,AGTA,Af6CA,AKfA,AIZA,AENA,A3BiFA,AwBxEA,ADGA,AGTA,AhBgDA,AXiCA,AvEqNA,ADGA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,Ac1CA,A8D1LA,AkBtDA,AnCyGA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AV8BA,AkBtDA,AU9BA,Ad0CA,AWjCA,ADGA,AGTA,Af6CA,AKfA,AIZA,AENA,A3BiFA,AwBxEA,ADGA,AGTA,AhBgDA,AXiCA,AxEwNA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,AFMA,AHSA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,A4EpOA,AkBtDA,AnCyGA,AkBtDA,AzB2EA,AgChGA,AbuCA,AFMA,AjEmMA,AQxBA,AkEtMA,AV8BA,AkBtDA,AU9BA,Ad0CA,AWjCA,ADGA,AGTA,Af6CA,AKfA,AIZA,AENA,AHSA,ADGA,AGTA,AhBgDA,AXiCA,AxEwNA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,A4EpOA,AkBtDA,AnCyGA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AQxBA,AkEtMA,AmBzDA,A7BuFA,AkBtDA,AU9BA,Ad0CA,AWjCA,ADGA,AGTA,Af6CA,AS3BA,AENA,AHSA,ADGA,AGTA,AhBgDA,AXiCA,AxEwNA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,A4EpOA,AkBtDA,AnCyGA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AQxBA,AkEtMA,AmBzDA,A7BuFA,AkBtDA,AU9BA,Ad0CA,AWjCA,ADGA,AGTA,Af6CA,AS3BA,AENA,AHSA,ADGA,AGTA,AhBgDA,AXiCA,AxEwNA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,A4EpOA,AkBtDA,AnCyGA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AQxBA,AkEtMA,AmBzDA,A7BuFA,AkBtDA,AU9BA,Ad0CA,AWjCA,ADGA,AGTA,Af6CA,AS3BA,AENA,AHSA,ADGA,AGTA,AhBgDA,AXiCA,AxEwNA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,A4EpOA,AkBtDA,AnCyGA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AQxBA,AkEtMA,AmBzDA,A7BuFA,AkBtDA,AU9BA,Ad0CA,AWjCA,ADGA,AGTA,Af6CA,AkBtDA,AT2BA,AENA,AHSA,ADGA,AGTA,AhBgDA,AXiCA,AxEwNA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,A4EpOA,AkBtDA,AnCyGA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AQxBA,AkEtMA,AmBzDA,A7BuFA,AkBtDA,AU9BA,Ad0CA,AWjCA,ADGA,AGTA,Af6CA,AkBtDA,AT2BA,AENA,AHSA,ADGA,AGTA,AhBgDA,AXiCA,AxEwNA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,A4EpOA,AkBtDA,AnCyGA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AQxBA,AkEtMA,AmBzDA,A7BuFA,AkBtDA,AU9BA,Ad0CA,AWjCA,ADGA,AGTA,Af6CA,AkBtDA,AT2BA,AENA,AHSA,ADGA,AGTA,A3BiFA,AxEwNA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,A4EpOA,AkBtDA,AnCyGA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AQxBA,AkEtMA,AmBzDA,A7BuFA,AkBtDA,AU9BA,Ad0CA,AWjCA,ADGA,AGTA,Af6CA,AkBtDA,AT2BA,AENA,AHSA,ADGA,AGTA,AS3BA,A5GoUA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,A4EpOA,AkBtDA,AnCyGA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AQxBA,AkEtMA,AmBzDA,A7BuFA,AkBtDA,AU9BA,Ad0CA,AWjCA,ADGA,AGTA,Af6CA,AkBtDA,AT2BA,AENA,AHSA,ADGA,AGTA,AS3BA,A5GoUA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,A4EpOA,AkBtDA,AnCyGA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AQxBA,AkEtMA,AmBzDA,A7BuFA,AkBtDA,AU9BA,Ad0CA,AWjCA,ADGA,AGTA,Af6CA,AkBtDA,AT2BA,AENA,AHSA,ADGA,AGTA,AS3BA,A5GoUA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,A4EpOA,AwBxEA,ANkBA,AnCyGA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AQxBA,AkEtMA,AmBzDA,A7BuFA,AkBtDA,AU9BA,Ad0CA,AWjCA,ADGA,AGTA,Af6CA,AkBtDA,AT2BA,AENA,AHSA,ADGA,AGTA,AS3BA,A5GoUA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,A4EpOA,AwBxEA,ANkBA,AnCyGA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AQxBA,AkEtMA,AmBzDA,A7BuFA,AkBtDA,AU9BA,Ad0CA,AWjCA,ADGA,AGTA,Af6CA,AkBtDA,AT2BA,AENA,AJYA,AGTA,AS3BA,A5GoUA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,A4EpOA,AwBxEA,ANkBA,AnCyGA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AQxBA,AkEtMA,AmBzDA,A7BuFA,AkBtDA,AU9BA,Ad0CA,AWjCA,ADGA,AGTA,Af6CA,AkBtDA,AT2BA,AENA,AJYA,AGTA,AS3BA,A5GoUA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,A4EpOA,AwBxEA,ANkBA,AnCyGA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AQxBA,AkEtMA,AmBzDA,A7BuFA,AkBtDA,AU9BA,Ad0CA,AWjCA,ADGA,AGTA,Af6CA,AkBtDA,AT2BA,AENA,AJYA,AGTA,AS3BA,AENA,A9G0UA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,A4EpOA,AwBxEA,ANkBA,AnCyGA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AQxBA,AkEtMA,AmBzDA,A7BuFA,AkBtDA,AU9BA,Ad0CA,AWjCA,ADGA,AGTA,Af6CA,AkBtDA,AT2BA,AENA,AJYA,AGTA,AS3BA,AENA,A9G0UA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,A4EpOA,AwBxEA,ANkBA,AnCyGA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AQxBA,AkEtMA,AmBzDA,A7BuFA,AkBtDA,AU9BA,Ad0CA,AWjCA,ADGA,AGTA,Af6CA,AkBtDA,AT2BA,AENA,AJYA,AGTA,AS3BA,AENA,A9G0UA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,A4EpOA,AwBxEA,ANkBA,AnCyGA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AQxBA,AkEtMA,AmBzDA,A7BuFA,AkBtDA,AU9BA,Ad0CA,AWjCA,AENA,Af6CA,AkBtDA,AT2BA,AENA,AJYA,AGTA,AS3BA,AENA,ACHA,A/G6UA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,A4EpOA,AwBxEA,ANkBA,AnCyGA,AkBtDA,AzB2EA,AmBzDA,AFMA,AjEmMA,AQxBA,AkEtMA,AmBzDA,A7BuFA,AkBtDA,AU9BA,Ad0CA,AWjCA,AENA,Af6CA,AkBtDA,AT2BA,AENA,AJYA,AGTA,AS3BA,AENA,ACHA,A/G6UA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,A4EpOA,AwBxEA,ANkBA,AnCyGA,AkBtDA,AzB2EA,AiBnDA,AjEmMA,AQxBA,AkEtMA,AmBzDA,A7BuFA,AkBtDA,AU9BA,Ad0CA,AWjCA,AENA,Af6CA,AkBtDA,AT2BA,AENA,AJYA,AGTA,AS3BA,AENA,ACHA,A/G6UA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,A4EpOA,AwBxEA,ANkBA,AnCyGA,AkBtDA,AzB2EA,AiBnDA,AjEmMA,AQxBA,AkEtMA,AmBzDA,A7BuFA,AkBtDA,AU9BA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,AT2BA,AENA,AJYA,AGTA,AS3BA,AENA,ACHA,A/G6UA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,A4EpOA,AwBxEA,ANkBA,AnCyGA,AkBtDA,AzB2EA,AiBnDA,AjEmMA,AQxBA,AkEtMA,AmBzDA,A7BuFA,AkBtDA,AU9BA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,AT2BA,AENA,AJYA,AGTA,AS3BA,AENA,ACHA,A/G6UA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,A4EpOA,AwBxEA,ANkBA,AnCyGA,AkBtDA,AzB2EA,AiBnDA,AjEmMA,AQxBA,AkEtMA,AmBzDA,A7BuFA,AkBtDA,AU9BA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,AT2BA,AENA,AJYA,AGTA,AS3BA,AENA,ACHA,A/G6UA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AIZA,AhBgDA,AQxBA,ADGA,AzB2EA,A4EpOA,AwBxEA,ANkBA,AnCyGA,AkBtDA,AzB2EA,AiBnDA,AjEmMA,AQxBA,AkEtMA,AmBzDA,A7BuFA,AkBtDA,AU9BA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,AT2BA,AENA,AJYA,AGTA,Ac1CA,ALeA,AENA,ACHA,A/G6UA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AZoCA,AQxBA,ADGA,AzB2EA,A4EpOA,AwBxEA,ANkBA,AnCyGA,AkBtDA,AzB2EA,AiBnDA,AjEmMA,AQxBA,AqF/PA,A7BuFA,AkBtDA,AU9BA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,AT2BA,AENA,AJYA,AGTA,Ac1CA,ALeA,AENA,ACHA,A/G6UA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AZoCA,AQxBA,ADGA,AzB2EA,A4EpOA,AwBxEA,ANkBA,AnCyGA,AkBtDA,AzB2EA,AiBnDA,AjEmMA,AQxBA,AqF/PA,A7BuFA,AkBtDA,AU9BA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,AT2BA,AENA,AJYA,AGTA,Ac1CA,ALeA,AENA,ACHA,A/G6UA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AZoCA,AQxBA,ADGA,AzB2EA,AoG5SA,ANkBA,AnCyGA,AkBtDA,AzB2EA,AiBnDA,AjEmMA,AQxBA,AqF/PA,A7BuFA,AkBtDA,AU9BA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,AT2BA,AENA,Ac1CA,AlBsDA,AGTA,Ac1CA,ALeA,AENA,ACHA,A/G6UA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AZoCA,AQxBA,ADGA,AzB2EA,AoG5SA,ANkBA,AnCyGA,AkBtDA,AzB2EA,AiBnDA,AjEmMA,AQxBA,AqF/PA,A7BuFA,AkBtDA,AU9BA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,AT2BA,AENA,Ac1CA,AlBsDA,AGTA,Ac1CA,ALeA,AENA,ACHA,A/G6UA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AZoCA,AQxBA,ADGA,AzB2EA,AoG5SA,ANkBA,AnCyGA,AkBtDA,AzB2EA,AiBnDA,AjEmMA,AQxBA,AqF/PA,A7BuFA,AkBtDA,AU9BA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,AT2BA,AENA,Ac1CA,AlBsDA,AGTA,Ac1CA,ALeA,AENA,ACHA,A/G6UA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AZoCA,AQxBA,ADGA,AzB2EA,AoG5SA,ANkBA,AnCyGA,AkBtDA,AzB2EA,AiBnDA,AjEmMA,AQxBA,AqF/PA,A7BuFA,AkBtDA,AU9BA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,AT2BA,AENA,Ac1CA,AlBsDA,AGTA,Ac1CA,AENA,APqBA,AENA,ACHA,A/G6UA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AZoCA,AQxBA,ADGA,AzB2EA,AoG5SA,ANkBA,AnCyGA,AkBtDA,AzB2EA,AiBnDA,AjEmMA,AQxBA,AqF/PA,A7BuFA,AkBtDA,AU9BA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,AT2BA,AENA,Ac1CA,AlBsDA,AGTA,Ac1CA,AENA,APqBA,AENA,ACHA,A/G6UA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AZoCA,AQxBA,ADGA,AzB2EA,AoG5SA,ANkBA,AnCyGA,AkBtDA,AzB2EA,AiBnDA,AjEmMA,AQxBA,AqF/PA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,AT2BA,AENA,Ac1CA,AlBsDA,AGTA,Ac1CA,AENA,APqBA,AENA,ACHA,A/G6UA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AZoCA,AQxBA,ADGA,AzB2EA,AoG5SA,ANkBA,AnCyGA,APqBA,AiBnDA,AjEmMA,AQxBA,A+F7RA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,AT2BA,AENA,Ac1CA,AlBsDA,AGTA,Ac1CA,AENA,APqBA,AENA,ACHA,A/G6UA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AZoCA,AQxBA,ADGA,AzB2EA,AoG5SA,ANkBA,AnCyGA,APqBA,AiBnDA,AjEmMA,AQxBA,A+F7RA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,AT2BA,AENA,Ac1CA,AlBsDA,AGTA,Ac1CA,AENA,APqBA,AENA,ACHA,A/G6UA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AZoCA,AQxBA,ADGA,AzB2EA,AoG5SA,ANkBA,AnCyGA,APqBA,AiBnDA,AjEmMA,AQxBA,A+F7RA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,AT2BA,AENA,Ac1CA,AlBsDA,AGTA,Ac1CA,AENA,APqBA,AENA,ACHA,A/G6UA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AZoCA,AQxBA,ADGA,AzB2EA,AoG5SA,ANkBA,AnCyGA,APqBA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,AT2BA,AENA,Ac1CA,AlBsDA,AGTA,Ac1CA,AENA,APqBA,AENA,ACHA,A/G6UA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AZoCA,AQxBA,A1B8EA,AoG5SA,ANkBA,AnCyGA,APqBA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,AT2BA,AENA,Ac1CA,AlBsDA,AGTA,Ac1CA,AENA,APqBA,AENA,ACHA,A/G6UA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AZoCA,AQxBA,A1B8EA,AoG5SA,ANkBA,A1C8HA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,AT2BA,AENA,Ac1CA,Af6CA,Ac1CA,AENA,APqBA,AENA,ACHA,A/G6UA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AZoCA,AQxBA,A1B8EA,AoG5SA,ANkBA,A1C8HA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,AT2BA,AENA,Ac1CA,Af6CA,AmBzDA,ALeA,AENA,APqBA,AENA,ACHA,A/G6UA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AZoCA,AQxBA,A1B8EA,AoG5SA,ANkBA,A1C8HA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,AT2BA,AENA,Ac1CA,Af6CA,AmBzDA,ALeA,AENA,APqBA,AENA,ACHA,A/G6UA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AZoCA,AQxBA,A1B8EA,AoG5SA,ANkBA,A1C8HA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,AT2BA,AENA,Ac1CA,Af6CA,AmBzDA,ALeA,AENA,APqBA,AENA,ACHA,A/G6UA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AZoCA,AQxBA,A1B8EA,AoG5SA,ANkBA,A1C8HA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,AT2BA,AENA,Ac1CA,Af6CA,AmBzDA,ALeA,AENA,AIZA,AXiCA,AENA,ACHA,A/G6UA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AZoCA,AlBsDA,AoG5SA,ANkBA,A1C8HA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,AT2BA,AENA,Ac1CA,Af6CA,AmBzDA,ALeA,AENA,AIZA,AXiCA,AENA,ACHA,A/G6UA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AZoCA,AlBsDA,AoG5SA,ANkBA,A1C8HA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,AT2BA,AENA,Ac1CA,Af6CA,AmBzDA,ALeA,AENA,AIZA,AXiCA,AENA,ACHA,A/G6UA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AZoCA,AlBsDA,AoG5SA,ANkBA,A1C8HA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,AT2BA,AENA,Ac1CA,Af6CA,AmBzDA,ALeA,AENA,AKfA,ADGA,AXiCA,AENA,ACHA,A/G6UA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AZoCA,AlBsDA,AoG5SA,ANkBA,A1C8HA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,Af6CA,AmBzDA,ALeA,AENA,AKfA,ADGA,AXiCA,AENA,ACHA,A/G6UA,Af6CA,AbuCA;A4DnLA,AMlBA,AMlBA,ALeA,AZoCA,AlBsDA,AoG5SA,ANkBA,A1C8HA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,Af6CA,AmBzDA,ALeA,AENA,AKfA,ADGA,AXiCA,AENA,ACHA,A/G6UA,Af6CA;A+C5IA,AMlBA,AMlBA,ALeA,AZoCA,AlBsDA,AoG5SA,ANkBA,A1C8HA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,Af6CA,AsBlEA,AHSA,ALeA,AENA,AKfA,ADGA,AXiCA,AENA,ACHA,A/G6UA,Af6CA;A+C5IA,AMlBA,AMlBA,ALeA,AZoCA,AlBsDA,AoG5SA,ANkBA,A1C8HA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,Af6CA,AsBlEA,AHSA,ALeA,AENA,AKfA,ADGA,AXiCA,AENA,ACHA,A/G6UA,Af6CA;A+C5IA,AMlBA,AMlBA,ALeA,AZoCA,AlBsDA,AoG5SA,ANkBA,A1C8HA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,Af6CA,AsBlEA,AHSA,ALeA,AENA,AKfA,ADGA,AXiCA,AENA,ACHA,A/G6UA,Af6CA;A+C5IA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,ANkBA,A1C8HA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,Af6CA,AsBlEA,AHSA,ALeA,AENA,AKfA,ADGA,AXiCA,AENA,ACHA,A/G6UA,Af6CA;A+C5IA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,ANkBA,A1C8HA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,Af6CA,AsBlEA,AHSA,ALeA,AENA,AKfA,ADGA,AXiCA,AENA,ACHA,A/G6UA,Af6CA;A+C5IA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,ANkBA,A1C8HA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,Af6CA,AsBlEA,AHSA,ALeA,AENA,AKfA,ADGA,AXiCA,AENA,ACHA,A/G6UA,Af6CA;A0I7ZA,A3FiRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,ANkBA,A1C8HA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,Af6CA,AsBlEA,AHSA,ALeA,AENA,AKfA,ADGA,AXiCA,AENA,ACHA,A/G6UA,Af6CA;A0I7ZA,A3FiRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,AhDgJA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,Af6CA,AsBlEA,AHSA,ALeA,AENA,AKfA,ADGA,AXiCA,AENA,ACHA,A/G6UA,Af6CA;A0I7ZA,A3FiRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,AhDgJA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,Af6CA,AsBlEA,AHSA,ALeA,AENA,AKfA,ADGA,AXiCA,AENA,ACHA,A/G6UA,Af6CA;A0I7ZA,A3FiRA,AMlBA,AMlBA,ALeA,AZoCA,AiGnSA,AFMA,AjHmVA,AoG5SA,AhDgJA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,Af6CA,AsBlEA,AHSA,ALeA,AENA,AKfA,ADGA,AXiCA,AENA,ACHA,A/G6UA,Af6CA;A0I7ZA,A3FiRA,AMlBA,AMlBA,ALeA,AZoCA,AiGnSA,AFMA,AjHmVA,AoG5SA,AhDgJA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,Af6CA,AsBlEA,AHSA,ALeA,AENA,AKfA,ADGA,AXiCA,AENA,ACHA,A/G6UA,Af6CA;A0I7ZA,A3FiRA,AMlBA,AMlBA,ALeA,AZoCA,AiGnSA,AFMA,AjHmVA,AoG5SA,AhDgJA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,Af6CA,AsBlEA,AHSA,ALeA,AENA,AKfA,ADGA,AXiCA,AENA,ACHA,A/G6UA,Af6CA;A0I7ZA,AENA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,AiGnSA,AFMA,AjHmVA,AoG5SA,AhDgJA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,Af6CA,AsBlEA,AHSA,ALeA,AENA,AKfA,ADGA,AXiCA,AENA,ACHA,A/G6UA,Af6CA;A0I7ZA,AENA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,AiGnSA,AFMA,AjHmVA,AoG5SA,AhDgJA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,Af6CA,AsBlEA,AHSA,ALeA,AENA,AKfA,ADGA,AXiCA,AENA,ACHA,A/G6UA,Af6CA;A0I7ZA,AENA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,AiGnSA,AFMA,AjHmVA,AoG5SA,AhDgJA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,Af6CA,AsBlEA,AHSA,AHSA,AKfA,ADGA,AXiCA,AENA,ACHA,A/G6UA,Af6CA;A6ItaA,AHSA,AENA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,AiGnSA,AFMA,AjHmVA,AoG5SA,AhDgJA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,Af6CA,AsBlEA,AHSA,AHSA,AKfA,ADGA,AXiCA,AENA,ACHA,A/G6UA,Af6CA;A6ItaA,AHSA,AENA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,AiGnSA,AFMA,AjHmVA,AoG5SA,AhDgJA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,Af6CA,AsBlEA,AHSA,AHSA,AKfA,ADGA,AT2BA,ACHA,A/G6UA,Af6CA;A6ItaA,AHSA,AENA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,AiGnSA,AFMA,AjHmVA,AoG5SA,AhDgJA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,Af6CA,AsBlEA,AHSA,AHSA,AKfA,ADGA,AT2BA,ACHA,A/G6UA,Af6CA;A6ItaA,AHSA,AENA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,AiGnSA,AFMA,AjHmVA,AoG5SA,AhDgJA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,Af6CA,AsBlEA,AHSA,AHSA,AKfA,ADGA,AT2BA,ACHA,A/G6UA,Af6CA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,AhDgJA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,Af6CA,AsBlEA,AHSA,AHSA,AKfA,ADGA,AT2BA,ACHA,A/G6UA,Af6CA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,AhDgJA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,AOrBA,AHSA,AHSA,AKfA,ADGA,AT2BA,ACHA,A/G6UA,Af6CA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,AhDgJA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,AOrBA,AHSA,AHSA,AKfA,ADGA,AT2BA,ACHA,A/G6UA,Af6CA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,AhDgJA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,AOrBA,AHSA,AHSA,AKfA,ADGA,AT2BA,ACHA,A/G6UA,Af6CA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,AhDgJA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,AOrBA,AHSA,AHSA,AKfA,ADGA,AT2BA,ACHA,A/G6UA,Af6CA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,AhDgJA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,AOrBA,AHSA,AHSA,AKfA,ADGA,AT2BA,ACHA,A/G6UA,Af6CA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,AhDgJA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,AOrBA,AHSA,AHSA,AKfA,ADGA,AT2BA,ACHA,A/G6UA,Af6CA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,AhDgJA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,AOrBA,AHSA,AHSA,AKfA,ADGA,AT2BA,ACHA,A/G6UA,Af6CA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,AhDgJA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,AOrBA,AHSA,AHSA,AKfA,ADGA,AT2BA,ACHA,A/G6UA,Af6CA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,AhDgJA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,AOrBA,AHSA,AHSA,AKfA,ADGA,AT2BA,ACHA,A/G6UA,Af6CA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,AhDgJA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,AOrBA,AHSA,AHSA,AKfA,ADGA,AT2BA,ACHA,A/G6UA,Af6CA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,AhDgJA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,AOrBA,AHSA,AHSA,AKfA,ADGA,AT2BA,ACHA,A/G6UA,Af6CA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,AhDgJA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,AOrBA,AHSA,AHSA,AKfA,ADGA,AT2BA,ACHA,A/G6UA,Af6CA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,AhDgJA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,AOrBA,AHSA,AHSA,AKfA,ADGA,AT2BA,ACHA,A/G6UA,Af6CA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,AhDgJA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,AOrBA,AHSA,AHSA,AKfA,ADGA,AT2BA,ACHA,A/G6UA,Af6CA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,AhDgJA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,AOrBA,AHSA,AHSA,AKfA,ADGA,AT2BA,ACHA,A/G6UA,Af6CA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,AhDgJA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,Af6CA,AkBtDA,APqBA,Ac1CA,AOrBA,AHSA,AHSA,AKfA,ADGA,AT2BA,ACHA,A/G6UA,Af6CA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,AhDgJA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AGTA,APqBA,Ac1CA,AOrBA,AHSA,AHSA,AKfA,ADGA,AT2BA,ACHA,A/G6UA,Af6CA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,AhDgJA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AGTA,APqBA,Ac1CA,AOrBA,AHSA,AHSA,AKfA,ADGA,AT2BA,ACHA,A/G6UA,Af6CA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,AhDgJA,AiBnDA,AjEmMA,AQxBA,AgGhSA,ADGA,AV8BA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AGTA,APqBA,Ac1CA,AOrBA,AHSA,AHSA,AKfA,ADGA,AT2BA,ACHA,A/G6UA,Af6CA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,AQxBA,AgGhSA,AXiCA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AGTA,APqBA,Ac1CA,AOrBA,AHSA,AHSA,AKfA,ADGA,AT2BA,ACHA,A/G6UA,Af6CA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,AQxBA,AgGhSA,AXiCA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AGTA,APqBA,Ac1CA,AOrBA,AHSA,AHSA,AKfA,ADGA,AT2BA,ACHA,A9H0XA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,AQxBA,AqF/PA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AGTA,APqBA,Ac1CA,AOrBA,AHSA,AHSA,AKfA,ADGA,AT2BA,ACHA,A9H0XA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,A6FvRA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AGTA,APqBA,Ac1CA,AOrBA,AHSA,AHSA,AKfA,ADGA,AT2BA,ACHA,A9H0XA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,A6FvRA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AGTA,APqBA,Ac1CA,AOrBA,AHSA,AHSA,AKfA,ADGA,AT2BA,ACHA,A9H0XA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,A6FvRA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AGTA,APqBA,Ac1CA,AOrBA,AHSA,AHSA,AKfA,ADGA,AT2BA,ACHA,A9H0XA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,A6FvRA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AGTA,APqBA,Ac1CA,AOrBA,AHSA,AHSA,AKfA,ADGA,AT2BA,ACHA,A9H0XA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,A6FvRA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AGTA,APqBA,Ac1CA,AOrBA,AHSA,AHSA,AKfA,ADGA,AT2BA,ACHA,A9H0XA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,A6FvRA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AGTA,APqBA,Ac1CA,AOrBA,AHSA,AHSA,AKfA,ADGA,ARwBA,A9H0XA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,A6FvRA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AGTA,APqBA,Ac1CA,AOrBA,ANkBA,AKfA,ADGA,ARwBA,A9H0XA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,A6FvRA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AGTA,APqBA,Ac1CA,AOrBA,ANkBA,AKfA,ADGA,ARwBA,A9H0XA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,A6FvRA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AGTA,APqBA,Ac1CA,AOrBA,ANkBA,AKfA,ADGA,ARwBA,A9H0XA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,A6FvRA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AGTA,APqBA,Ac1CA,AOrBA,ANkBA,AKfA,ADGA,ARwBA,A9H0XA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,A6FvRA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AGTA,APqBA,Ac1CA,AOrBA,ANkBA,AKfA,ADGA,ARwBA,A9H0XA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,A6FvRA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AGTA,APqBA,Ac1CA,AOrBA,ANkBA,AKfA,ADGA,ARwBA,A9H0XA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,A6FvRA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AGTA,APqBA,Ac1CA,AOrBA,ANkBA,AKfA,ADGA,ARwBA,A9H0XA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,A6FvRA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AGTA,APqBA,Ac1CA,AOrBA,ANkBA,AIZA,ARwBA,A9H0XA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,A6FvRA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AGTA,APqBA,Ac1CA,AOrBA,ANkBA,AIZA,ARwBA,A9H0XA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,A6FvRA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AGTA,APqBA,Ac1CA,AOrBA,ANkBA,AIZA,ARwBA,A9H0XA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,A6FvRA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AGTA,APqBA,Ac1CA,ACHA,AIZA,ARwBA,A9H0XA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,A6FvRA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AGTA,APqBA,Ac1CA,ACHA,AIZA,ARwBA,A9H0XA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,A6FvRA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AGTA,APqBA,Ac1CA,ACHA,AIZA,ARwBA,A9H0XA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,A6FvRA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AGTA,APqBA,Ac1CA,ACHA,AIZA,ARwBA,A9H0XA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,A6FvRA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AGTA,APqBA,Ac1CA,ACHA,AIZA,ARwBA,A9H0XA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,A6FvRA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AGTA,APqBA,Ac1CA,ACHA,AIZA,ARwBA,A9H0XA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,A6FvRA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AGTA,APqBA,Ac1CA,ACHA,AIZA,ARwBA,A9H0XA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,A6FvRA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AGTA,APqBA,Ac1CA,ACHA,AIZA,ARwBA,A9H0XA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,A6FvRA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AGTA,APqBA,Ac1CA,ACHA,AIZA,ARwBA,A9H0XA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,A6FvRA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AGTA,APqBA,Ac1CA,ACHA,AIZA,ARwBA,A9H0XA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,A6FvRA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AGTA,APqBA,Ac1CA,ACHA,AIZA,ARwBA,A9H0XA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,A6FvRA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AGTA,APqBA,Ac1CA,ACHA,AIZA,ARwBA,A9H0XA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,A6FvRA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AGTA,APqBA,Ac1CA,ACHA,AIZA,ARwBA,A9H0XA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,A6FvRA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AGTA,APqBA,Ac1CA,ACHA,AIZA,ARwBA,A9H0XA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,A6FvRA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AGTA,APqBA,Ac1CA,ACHA,AIZA,ARwBA,A9H0XA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,A6FvRA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AJYA,Ac1CA,ACHA,AIZA,ARwBA,A9H0XA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,A6FvRA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AJYA,Ac1CA,ACHA,AIZA,ARwBA,A9H0XA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,A6FvRA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AJYA,Ac1CA,ACHA,AIZA,AtIkZA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,A6FvRA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AJYA,Ac1CA,ACHA,AIZA,AtIkZA;A6ItaA,ADGA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,AjEmMA,A6FvRA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AJYA,Ac1CA,ACHA,AIZA,AtIkZA;A4InaA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AJYA,Ac1CA,ACHA,AIZA,AtIkZA;A4InaA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AJYA,Ac1CA,ACHA,AIZA,AtIkZA;A4InaA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AJYA,Ac1CA,ACHA,AIZA,AtIkZA;A4InaA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AJYA,Ac1CA,AKfA,AtIkZA;A4InaA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AJYA,Ac1CA,AKfA,AtIkZA;A4InaA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AJYA,Ac1CA,AKfA,AtIkZA;A4InaA,A7FuRA,AMlBA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AqB/DA,AV8BA,AENA,AJYA,Ac1CA,AKfA,AtIkZA;A4InaA,AvFqQA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AWjCA,AENA,AJYA,Ac1CA,AjImYA;A4InaA,AvFqQA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AWjCA,AENA,AJYA,Ac1CA,AjImYA;A4InaA,AvFqQA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AWjCA,AENA,AJYA,Ac1CA,AjImYA;A4InaA,AvFqQA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AWjCA,AENA,AJYA,Ac1CA,AjImYA;A4InaA,AvFqQA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AWjCA,AENA,AJYA,Ac1CA,AjImYA;A4InaA,AvFqQA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AWjCA,AENA,AJYA,Ac1CA,AjImYA;A4InaA,AvFqQA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AWjCA,AENA,AJYA,Ac1CA,AjImYA;A4InaA,AvFqQA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AWjCA,AENA,AJYA,Ac1CA,AjImYA;A4InaA,AvFqQA,AMlBA,ALeA,AZoCA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AWjCA,AENA,AJYA,Ac1CA,AjImYA;A4InaA,AvFqQA,AMlBA,AjBmDA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AWjCA,AENA,AJYA,Ac1CA,AjImYA;A4InaA,AvFqQA,AMlBA,AjBmDA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AWjCA,AENA,AU9BA,AjImYA;A4InaA,AvFqQA,AMlBA,AjBmDA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AWjCA,AENA,AU9BA,AjImYA;A4InaA,AvFqQA,AMlBA,AjBmDA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AWjCA,AENA,AU9BA,AjImYA;A4InaA,AvFqQA,AMlBA,AjBmDA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AWjCA,AENA,AU9BA,AjImYA;A4InaA,AvFqQA,AMlBA,AjBmDA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AWjCA,AENA,AU9BA,AjImYA;A4InaA,AvFqQA,AMlBA,AjBmDA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AWjCA,AENA,AU9BA,AjImYA;A4InaA,AvFqQA,AMlBA,AjBmDA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AWjCA,AENA,AU9BA,AjImYA;A4InaA,AvFqQA,AMlBA,AjBmDA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AWjCA,AENA,AU9BA,AjImYA;A4InaA,AvFqQA,AMlBA,AjBmDA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AWjCA,AENA,AU9BA,AjImYA;A4InaA,AvFqQA,AMlBA,AjBmDA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AWjCA,AENA,AU9BA,AjImYA;A4InaA,AvFqQA,AMlBA,AjBmDA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AWjCA,AENA,AU9BA,AjImYA;A4InaA,AvFqQA,AMlBA,AjBmDA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AWjCA,AENA,AU9BA,AjImYA;A4InaA,AvFqQA,AMlBA,AjBmDA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AWjCA,AENA,AU9BA,AjImYA;A4InaA,AvFqQA,AMlBA,AjBmDA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AavCA,AU9BA,AjImYA;A4InaA,AvFqQA,AMlBA,AjBmDA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AavCA,AU9BA,AjImYA;A4InaA,AvFqQA,AMlBA,AjBmDA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AavCA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AavCA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AavCA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AavCA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AavCA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AavCA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AavCA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AavCA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,Ad0CA,AavCA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,A+F7RA,AjHmVA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AoG5SA,A/B6FA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AqE/MA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AqE/MA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AqE/MA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AqE/MA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AqE/MA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AqE/MA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AqE/MA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AqE/MA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AqE/MA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AqE/MA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AqE/MA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AqE/MA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AqE/MA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AqE/MA,A4BpFA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,ADGA,AU9BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AjFmPA,AjBmDA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AlGsSA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AlGsSA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AlGsSA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AlGsSA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AlGsSA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AlGsSA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AlGsSA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AlGsSA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AlGsSA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AlGsSA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AlGsSA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AlGsSA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AlGsSA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AlGsSA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AlGsSA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AlGsSA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,AlGsSA,AlBsDA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,ApH4VA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,ApH4VA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,ApH4VA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,ApH4VA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,ApH4VA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,ApH4VA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,ApH4VA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,ApH4VA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,ApH4VA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,ApH4VA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,ApH4VA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,ApH4VA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,ApH4VA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,ApH4VA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,ApH4VA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,ApH4VA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,ApH4VA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;A4InaA,ApH4VA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AS3BA,AjImYA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AxHwWA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AxHwWA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AxHwWA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AxHwWA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AxHwWA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AxHwWA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AxHwWA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AxHwWA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AxHwWA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AxHwWA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AxHwWA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AxHwWA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AxHwWA;AwBvEA,AiGnSA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,A7BuFA,A4BpFA,AxHwWA;AyH1WA,ADGA,AxHwWA;AyH1WA,ADGA,AxHwWA;AyH1WA,ADGA,AxHwWA;AyH1WA,ADGA,AxHwWA;AyH1WA,ADGA,AxHwWA;AyH1WA,ADGA,AxHwWA;AyH1WA,ADGA,AxHwWA;AyH1WA,ADGA,AxHwWA;AyH1WA,ADGA,AxHwWA;AyH1WA,ADGA,AxHwWA;AyH1WA,ADGA,AxHwWA;AyH1WA,ADGA,AxHwWA;AyH1WA,ADGA,AxHwWA;AyH1WA,ADGA,AxHwWA;AyH1WA,ADGA,AxHwWA;AyH1WA,ADGA,AxHwWA;AyH1WA,ADGA,AxHwWA;AyH1WA,ADGA,AxHwWA;AyH1WA,ADGA,AxHwWA;AyH1WA,ADGA,AxHwWA;AyH1WA,ADGA,AxHwWA;AyH1WA,ADGA,AxHwWA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AyH1WA,AzH2WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["module.exports = require(\"./lib/api/node.js\");\n","\n\nexports.__esModule = true;\nexports.register = register;\nexports.polyfill = polyfill;\nexports.transformFile = transformFile;\nexports.transformFileSync = transformFileSync;\nexports.parse = parse;\n// istanbul ignore next\n\nfunction _interopRequire(obj) { return obj && obj.__esModule ? obj[\"default\"] : obj; }\n\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _lodashLangIsFunction = require(\"lodash/lang/isFunction\");\n\nvar _lodashLangIsFunction2 = _interopRequireDefault(_lodashLangIsFunction);\n\nvar _transformation = require(\"../transformation\");\n\nvar _transformation2 = _interopRequireDefault(_transformation);\n\nvar _babylon = require(\"babylon\");\n\nvar babylon = _interopRequireWildcard(_babylon);\n\nvar _util = require(\"../util\");\n\nvar util = _interopRequireWildcard(_util);\n\nvar _fs = require(\"fs\");\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _types = require(\"../types\");\n\nvar t = _interopRequireWildcard(_types);\n\nexports.util = util;\nexports.acorn = babylon;\nexports.transform = _transformation2[\"default\"];\nexports.pipeline = _transformation.pipeline;\nexports.canCompile = _util.canCompile;\n\nvar _transformationFile = require(\"../transformation/file\");\n\nexports.File = _interopRequire(_transformationFile);\n\nvar _transformationFileOptionsConfig = require(\"../transformation/file/options/config\");\n\nexports.options = _interopRequire(_transformationFileOptionsConfig);\n\nvar _transformationPlugin = require(\"../transformation/plugin\");\n\nexports.Plugin = _interopRequire(_transformationPlugin);\n\nvar _transformationTransformer = require(\"../transformation/transformer\");\n\nexports.Transformer = _interopRequire(_transformationTransformer);\n\nvar _transformationPipeline = require(\"../transformation/pipeline\");\n\nexports.Pipeline = _interopRequire(_transformationPipeline);\n\nvar _traversal = require(\"../traversal\");\n\nexports.traverse = _interopRequire(_traversal);\n\nvar _toolsBuildExternalHelpers = require(\"../tools/build-external-helpers\");\n\nexports.buildExternalHelpers = _interopRequire(_toolsBuildExternalHelpers);\n\nvar _package = require(\"../../package\");\n\nexports.version = _package.version;\nexports.types = t;\n\n/**\n * Register Babel and polyfill globally.\n */\n\nfunction register(opts) {\n  var callback = require(\"./register/node-polyfill\");\n  if (opts != null) callback(opts);\n  return callback;\n}\n\n/**\n * Register polyfill globally.\n */\n\nfunction polyfill() {\n  require(\"../polyfill\");\n}\n\n/**\n * Asynchronously transform `filename` with optional `opts`, calls `callback` when complete.\n */\n\nfunction transformFile(filename, opts, callback) {\n  if (_lodashLangIsFunction2[\"default\"](opts)) {\n    callback = opts;\n    opts = {};\n  }\n\n  opts.filename = filename;\n\n  _fs2[\"default\"].readFile(filename, function (err, code) {\n    if (err) return callback(err);\n\n    var result;\n\n    try {\n      result = _transformation2[\"default\"](code, opts);\n    } catch (err) {\n      return callback(err);\n    }\n\n    callback(null, result);\n  });\n}\n\n/**\n * Synchronous form of `transformFile`.\n */\n\nfunction transformFileSync(filename) {\n  var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n  opts.filename = filename;\n  return _transformation2[\"default\"](_fs2[\"default\"].readFileSync(filename, \"utf8\"), opts);\n}\n\n/**\n * Parse script with Babel's parser.\n */\n\nfunction parse(code) {\n  var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n  opts.allowHashBang = true;\n  opts.sourceType = \"module\";\n  opts.ecmaVersion = Infinity;\n  opts.plugins = {\n    jsx: true,\n    flow: true\n  };\n  opts.features = {};\n\n  for (var key in _transformation2[\"default\"].pipeline.transformers) {\n    opts.features[key] = true;\n  }\n\n  var ast = babylon.parse(code, opts);\n\n  if (opts.onToken) {\n    // istanbul ignore next\n\n    var _opts$onToken;\n\n    (_opts$onToken = opts.onToken).push.apply(_opts$onToken, ast.tokens);\n  }\n\n  if (opts.onComment) {\n    // istanbul ignore next\n\n    var _opts$onComment;\n\n    (_opts$onComment = opts.onComment).push.apply(_opts$onComment, ast.comments);\n  }\n\n  return ast.program;\n}","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _pipeline = require(\"./pipeline\");\n\nvar _pipeline2 = _interopRequireDefault(_pipeline);\n\n/**\n * [Please add a description.]\n */\n\n/**\n * [Please add a description.]\n */\n\nvar _transformers = require(\"./transformers\");\n\nvar _transformers2 = _interopRequireDefault(_transformers);\n\n/**\n * [Please add a description.]\n */\n\nvar _transformersDeprecated = require(\"./transformers/deprecated\");\n\nvar _transformersDeprecated2 = _interopRequireDefault(_transformersDeprecated);\n\n/**\n * [Please add a description.]\n */\n\nvar _transformersAliases = require(\"./transformers/aliases\");\n\nvar _transformersAliases2 = _interopRequireDefault(_transformersAliases);\n\n/**\n * [Please add a description.]\n */\n\nvar _transformersFilters = require(\"./transformers/filters\");\n\nvar filters = _interopRequireWildcard(_transformersFilters);\n\nvar pipeline = new _pipeline2[\"default\"]();\n\nfor (var key in _transformers2[\"default\"]) {\n  var transformer = _transformers2[\"default\"][key];\n\n  if (typeof transformer === \"object\") {\n    var metadata = transformer.metadata = transformer.metadata || {};\n    metadata.group = metadata.group || \"builtin-basic\";\n  }\n}\n\npipeline.addTransformers(_transformers2[\"default\"]);\npipeline.addDeprecated(_transformersDeprecated2[\"default\"]);\npipeline.addAliases(_transformersAliases2[\"default\"]);\npipeline.addFilter(filters.internal);\npipeline.addFilter(filters.blacklist);\npipeline.addFilter(filters.whitelist);\npipeline.addFilter(filters.stage);\npipeline.addFilter(filters.optional);\n\n/**\n * [Please add a description.]\n */\n\nvar transform = pipeline.transform.bind(pipeline);\ntransform.fromAst = pipeline.transformFromAst.bind(pipeline);\ntransform.pipeline = pipeline;\nexports[\"default\"] = transform;\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// istanbul ignore next\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _filePluginManager = require(\"./file/plugin-manager\");\n\nvar _filePluginManager2 = _interopRequireDefault(_filePluginManager);\n\nvar _helpersNormalizeAst = require(\"../helpers/normalize-ast\");\n\nvar _helpersNormalizeAst2 = _interopRequireDefault(_helpersNormalizeAst);\n\nvar _plugin = require(\"./plugin\");\n\nvar _plugin2 = _interopRequireDefault(_plugin);\n\nvar _lodashObjectAssign = require(\"lodash/object/assign\");\n\nvar _lodashObjectAssign2 = _interopRequireDefault(_lodashObjectAssign);\n\nvar _helpersObject = require(\"../helpers/object\");\n\nvar _helpersObject2 = _interopRequireDefault(_helpersObject);\n\nvar _file = require(\"./file\");\n\nvar _file2 = _interopRequireDefault(_file);\n\n/**\n * [Please add a description.]\n */\n\nvar Pipeline = (function () {\n  function Pipeline() {\n    _classCallCheck(this, Pipeline);\n\n    this.transformers = _helpersObject2[\"default\"]();\n    this.namespaces = _helpersObject2[\"default\"]();\n    this.deprecated = _helpersObject2[\"default\"]();\n    this.aliases = _helpersObject2[\"default\"]();\n    this.filters = [];\n  }\n\n  /**\n   * [Please add a description.]\n   */\n\n  Pipeline.prototype.addTransformers = function addTransformers(transformers) {\n    for (var key in transformers) {\n      this.addTransformer(key, transformers[key]);\n    }\n    return this;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Pipeline.prototype.addTransformer = function addTransformer(key, plugin) {\n    if (this.transformers[key]) throw new Error(); // todo: error\n\n    var namespace = key.split(\".\")[0];\n    this.namespaces[namespace] = this.namespaces[namespace] || [];\n    this.namespaces[namespace].push(key);\n    this.namespaces[key] = namespace;\n\n    if (typeof plugin === \"function\") {\n      plugin = _filePluginManager2[\"default\"].memoisePluginContainer(plugin);\n      plugin.key = key;\n      plugin.metadata.optional = true;\n\n      if (key === \"react.displayName\") {\n        plugin.metadata.optional = false;\n      }\n    } else {\n      plugin = new _plugin2[\"default\"](key, plugin);\n    }\n\n    this.transformers[key] = plugin;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Pipeline.prototype.addAliases = function addAliases(names) {\n    _lodashObjectAssign2[\"default\"](this.aliases, names);\n    return this;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Pipeline.prototype.addDeprecated = function addDeprecated(names) {\n    _lodashObjectAssign2[\"default\"](this.deprecated, names);\n    return this;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Pipeline.prototype.addFilter = function addFilter(filter) {\n    this.filters.push(filter);\n    return this;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Pipeline.prototype.canTransform = function canTransform(plugin, fileOpts) {\n    if (plugin.metadata.plugin) {\n      return true;\n    }\n\n    var _arr = this.filters;\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var filter = _arr[_i];\n      var result = filter(plugin, fileOpts);\n      if (result != null) return result;\n    }\n\n    return true;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Pipeline.prototype.analyze = function analyze(code) {\n    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    opts.code = false;\n    return this.transform(code, opts);\n  };\n\n  /**\n   * Build dependency graph by recursing `metadata.modules`. WIP.\n   */\n\n  Pipeline.prototype.pretransform = function pretransform(code, opts) {\n    var file = new _file2[\"default\"](opts, this);\n    return file.wrap(code, function () {\n      file.addCode(code);\n      file.parseCode(code);\n      return file;\n    });\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Pipeline.prototype.transform = function transform(code, opts) {\n    var file = new _file2[\"default\"](opts, this);\n    return file.wrap(code, function () {\n      file.addCode(code);\n      file.parseCode(code);\n      return file.transform();\n    });\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Pipeline.prototype.transformFromAst = function transformFromAst(ast, code, opts) {\n    ast = _helpersNormalizeAst2[\"default\"](ast);\n\n    var file = new _file2[\"default\"](opts, this);\n    return file.wrap(code, function () {\n      file.addCode(code);\n      file.addAst(ast);\n      return file.transform();\n    });\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Pipeline.prototype._ensureTransformerNames = function _ensureTransformerNames(type, rawKeys) {\n    var keys = [];\n\n    for (var i = 0; i < rawKeys.length; i++) {\n      var key = rawKeys[i];\n      var deprecatedKey = this.deprecated[key];\n      var aliasKey = this.aliases[key];\n      if (aliasKey) {\n        keys.push(aliasKey);\n      } else if (deprecatedKey) {\n        // deprecated key, remap it to the new one\n        console.error(\"[BABEL] The transformer \" + key + \" has been renamed to \" + deprecatedKey);\n        rawKeys.push(deprecatedKey);\n      } else if (this.transformers[key]) {\n        // valid key\n        keys.push(key);\n      } else if (this.namespaces[key]) {\n        // namespace, append all transformers within this namespace\n        keys = keys.concat(this.namespaces[key]);\n      } else {\n        // invalid key\n        throw new ReferenceError(\"Unknown transformer \" + key + \" specified in \" + type);\n      }\n    }\n\n    return keys;\n  };\n\n  return Pipeline;\n})();\n\nexports[\"default\"] = Pipeline;\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// istanbul ignore next\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _transformer = require(\"../transformer\");\n\nvar _transformer2 = _interopRequireDefault(_transformer);\n\nvar _plugin = require(\"../plugin\");\n\nvar _plugin2 = _interopRequireDefault(_plugin);\n\nvar _types = require(\"../../types\");\n\nvar types = _interopRequireWildcard(_types);\n\nvar _messages = require(\"../../messages\");\n\nvar messages = _interopRequireWildcard(_messages);\n\nvar _tryResolve = require(\"try-resolve\");\n\nvar _tryResolve2 = _interopRequireDefault(_tryResolve);\n\nvar _traversal = require(\"../../traversal\");\n\nvar _traversal2 = _interopRequireDefault(_traversal);\n\nvar _helpersParse = require(\"../../helpers/parse\");\n\nvar _helpersParse2 = _interopRequireDefault(_helpersParse);\n\n/**\n * [Please add a description.]\n */\n\nvar context = {\n  messages: messages,\n  Transformer: _transformer2[\"default\"],\n  Plugin: _plugin2[\"default\"],\n  types: types,\n  parse: _helpersParse2[\"default\"],\n  traverse: _traversal2[\"default\"]\n};\n\n/**\n * [Please add a description.]\n */\n\nvar PluginManager = (function () {\n\n  /**\n   * [Please add a description.]\n   */\n\n  PluginManager.memoisePluginContainer = function memoisePluginContainer(fn) {\n    for (var i = 0; i < PluginManager.memoisedPlugins.length; i++) {\n      var plugin = PluginManager.memoisedPlugins[i];\n      if (plugin.container === fn) return plugin.transformer;\n    }\n\n    var transformer = fn(context);\n    PluginManager.memoisedPlugins.push({\n      container: fn,\n      transformer: transformer\n    });\n    return transformer;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  _createClass(PluginManager, null, [{\n    key: \"memoisedPlugins\",\n\n    /**\n     * [Please add a description.]\n     */\n\n    value: [],\n    enumerable: true\n  }, {\n    key: \"positions\",\n    value: [\"before\", \"after\"],\n\n    /**\n     * [Please add a description.]\n     */\n\n    enumerable: true\n  }]);\n\n  function PluginManager() {\n    var _ref = arguments.length <= 0 || arguments[0] === undefined ? { transformers: {}, before: [], after: [] } : arguments[0];\n\n    var file = _ref.file;\n    var transformers = _ref.transformers;\n    var before = _ref.before;\n    var after = _ref.after;\n\n    _classCallCheck(this, PluginManager);\n\n    this.transformers = transformers;\n    this.file = file;\n    this.before = before;\n    this.after = after;\n  }\n\n  /**\n   * [Please add a description.]\n   */\n\n  PluginManager.prototype.subnormaliseString = function subnormaliseString(name, position) {\n    // this is a plugin in the form of \"foobar\" or \"foobar:after\"\n    // where the optional colon is the delimiter for plugin position in the transformer stack\n\n    var match = name.match(/^(.*?):(after|before)$/);\n    if (match) {\n      ;\n\n      name = match[1];\n      position = match[2];\n    }var loc = _tryResolve2[\"default\"].relative(\"babel-plugin-\" + name) || _tryResolve2[\"default\"].relative(name);\n    if (loc) {\n      var plugin = require(loc);\n      return {\n        position: position,\n        plugin: plugin[\"default\"] || plugin\n      };\n    } else {\n      throw new ReferenceError(messages.get(\"pluginUnknown\", name));\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  PluginManager.prototype.validate = function validate(name, plugin) {\n    // validate transformer key\n    var key = plugin.key;\n    if (this.transformers[key]) {\n      throw new ReferenceError(messages.get(\"pluginKeyCollision\", key));\n    }\n\n    // validate Transformer instance\n    if (!plugin.buildPass || plugin.constructor.name !== \"Plugin\") {\n      throw new TypeError(messages.get(\"pluginNotTransformer\", name));\n    }\n\n    // register as a plugin\n    plugin.metadata.plugin = true;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  PluginManager.prototype.add = function add(name) {\n    var position;\n    var plugin;\n\n    if (name) {\n      if (typeof name === \"object\" && name.transformer) {\n        plugin = name.transformer;\n        position = name.position;\n      } else if (typeof name !== \"string\") {\n        // not a string so we'll just assume that it's a direct Transformer instance, if not then\n        // the checks later on will complain\n        plugin = name;\n      }\n\n      if (typeof name === \"string\") {\n        var _subnormaliseString = this.subnormaliseString(name, position);\n\n        plugin = _subnormaliseString.plugin;\n        position = _subnormaliseString.position;\n      }\n    } else {\n      throw new TypeError(messages.get(\"pluginIllegalKind\", typeof name, name));\n    }\n\n    // default position\n    position = position || \"before\";\n\n    // validate position\n    if (PluginManager.positions.indexOf(position) < 0) {\n      throw new TypeError(messages.get(\"pluginIllegalPosition\", position, name));\n    }\n\n    // allow plugin containers to be specified so they don't have to manually require\n    if (typeof plugin === \"function\") {\n      plugin = PluginManager.memoisePluginContainer(plugin);\n    }\n\n    //\n    this.validate(name, plugin);\n\n    // build!\n    var pass = this.transformers[plugin.key] = plugin.buildPass(this.file);\n    if (pass.canTransform()) {\n      var stack = position === \"before\" ? this.before : this.after;\n      stack.push(pass);\n    }\n  };\n\n  return PluginManager;\n})();\n\nexports[\"default\"] = PluginManager;\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// istanbul ignore next\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _plugin = require(\"./plugin\");\n\nvar _plugin2 = _interopRequireDefault(_plugin);\n\n/**\n * [Please add a description.]\n */\n\nvar Transformer = function Transformer(key, obj) {\n  _classCallCheck(this, Transformer);\n\n  var plugin = {};\n\n  plugin.metadata = obj.metadata;\n  delete obj.metadata;\n\n  plugin.visitor = obj;\n\n  return new _plugin2[\"default\"](key, plugin);\n};\n\nexports[\"default\"] = Transformer;\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// istanbul ignore next\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _pluginPass = require(\"./plugin-pass\");\n\nvar _pluginPass2 = _interopRequireDefault(_pluginPass);\n\nvar _messages = require(\"../messages\");\n\nvar messages = _interopRequireWildcard(_messages);\n\nvar _traversal = require(\"../traversal\");\n\nvar _traversal2 = _interopRequireDefault(_traversal);\n\nvar _lodashObjectAssign = require(\"lodash/object/assign\");\n\nvar _lodashObjectAssign2 = _interopRequireDefault(_lodashObjectAssign);\n\nvar _lodashLangClone = require(\"lodash/lang/clone\");\n\nvar _lodashLangClone2 = _interopRequireDefault(_lodashLangClone);\n\nvar _file = require(\"./file\");\n\nvar _file2 = _interopRequireDefault(_file);\n\nvar _types = require(\"../types\");\n\nvar t = _interopRequireWildcard(_types);\n\nvar VALID_PLUGIN_PROPERTIES = [\"visitor\", \"metadata\", \"manipulateOptions\", \"post\", \"pre\"];\n\nvar VALID_METADATA_PROPERTIES = [\"dependencies\", \"optional\", \"stage\", \"group\", \"experimental\", \"secondPass\"];\n\n/**\n * [Please add a description.]\n */\n\nvar Plugin = (function () {\n  function Plugin(key, plugin) {\n    _classCallCheck(this, Plugin);\n\n    Plugin.validate(key, plugin);\n\n    plugin = _lodashObjectAssign2[\"default\"]({}, plugin);\n\n    var take = function take(key) {\n      var val = plugin[key];\n      delete plugin[key];\n      return val;\n    };\n\n    this.manipulateOptions = take(\"manipulateOptions\");\n    this.metadata = take(\"metadata\") || {};\n    this.dependencies = this.metadata.dependencies || [];\n    this.post = take(\"post\");\n    this.pre = take(\"pre\");\n\n    //\n\n    if (this.metadata.stage != null) {\n      this.metadata.optional = true;\n    }\n\n    //\n\n    this.visitor = this.normalize(_lodashLangClone2[\"default\"](take(\"visitor\")) || {});\n    this.key = key;\n  }\n\n  /**\n   * [Please add a description.]\n   */\n\n  Plugin.validate = function validate(name, plugin) {\n    for (var key in plugin) {\n      if (key[0] === \"_\") continue;\n      if (VALID_PLUGIN_PROPERTIES.indexOf(key) >= 0) continue;\n\n      var msgType = \"pluginInvalidProperty\";\n      if (t.TYPES.indexOf(key) >= 0) msgType = \"pluginInvalidPropertyVisitor\";\n      throw new Error(messages.get(msgType, name, key));\n    }\n\n    for (var key in plugin.metadata) {\n      if (VALID_METADATA_PROPERTIES.indexOf(key) >= 0) continue;\n\n      throw new Error(messages.get(\"pluginInvalidProperty\", name, \"metadata.\" + key));\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Plugin.prototype.normalize = function normalize(visitor) {\n    _traversal2[\"default\"].explode(visitor);\n    return visitor;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Plugin.prototype.buildPass = function buildPass(file) {\n    // validate Transformer instance\n    if (!(file instanceof _file2[\"default\"])) {\n      throw new TypeError(messages.get(\"pluginNotFile\", this.key));\n    }\n\n    return new _pluginPass2[\"default\"](file, this);\n  };\n\n  return Plugin;\n})();\n\nexports[\"default\"] = Plugin;\nmodule.exports = exports[\"default\"];","\n\n/**\n * This class is responsible for traversing over the provided `File`s\n * AST and running it's parent transformers handlers over it.\n */\n\n\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// istanbul ignore next\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _traversal = require(\"../traversal\");\n\nvar _traversal2 = _interopRequireDefault(_traversal);\n\nvar PluginPass = (function () {\n  function PluginPass(file, plugin) {\n    _classCallCheck(this, PluginPass);\n\n    this.plugin = plugin;\n    this.file = file;\n    this.key = plugin.key;\n\n    if (this.canTransform() && plugin.metadata.experimental && !file.opts.experimental) {\n      file.log.warn(\"THE TRANSFORMER \" + this.key + \" HAS BEEN MARKED AS EXPERIMENTAL AND IS WIP. USE AT YOUR OWN RISK. \" + \"THIS WILL HIGHLY LIKELY BREAK YOUR CODE SO USE WITH **EXTREME** CAUTION. ENABLE THE \" + \"`experimental` OPTION TO IGNORE THIS WARNING.\");\n    }\n  }\n\n  /**\n  * [Please add a description.]\n  */\n\n  PluginPass.prototype.canTransform = function canTransform() {\n    return this.file.transformerDependencies[this.key] || this.file.pipeline.canTransform(this.plugin, this.file.opts);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  PluginPass.prototype.transform = function transform() {\n    var file = this.file;\n    file.log.debug(\"Start transformer \" + this.key);\n    _traversal2[\"default\"](file.ast, this.plugin.visitor, file.scope, file);\n    file.log.debug(\"Finish transformer \" + this.key);\n  };\n\n  return PluginPass;\n})();\n\nexports[\"default\"] = PluginPass;\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\nexports[\"default\"] = traverse;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _context = require(\"./context\");\n\nvar _context2 = _interopRequireDefault(_context);\n\nvar _visitors = require(\"./visitors\");\n\nvar visitors = _interopRequireWildcard(_visitors);\n\nvar _messages = require(\"../messages\");\n\nvar messages = _interopRequireWildcard(_messages);\n\nvar _lodashCollectionIncludes = require(\"lodash/collection/includes\");\n\nvar _lodashCollectionIncludes2 = _interopRequireDefault(_lodashCollectionIncludes);\n\nvar _types = require(\"../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nfunction traverse(parent, opts, scope, state, parentPath) {\n  if (!parent) return;\n  if (!opts) opts = {};\n\n  if (!opts.noScope && !scope) {\n    if (parent.type !== \"Program\" && parent.type !== \"File\") {\n      throw new Error(messages.get(\"traverseNeedsParent\", parent.type));\n    }\n  }\n\n  visitors.explode(opts);\n\n  // array of nodes\n  if (Array.isArray(parent)) {\n    for (var i = 0; i < parent.length; i++) {\n      traverse.node(parent[i], opts, scope, state, parentPath);\n    }\n  } else {\n    traverse.node(parent, opts, scope, state, parentPath);\n  }\n}\n\ntraverse.visitors = visitors;\ntraverse.verify = visitors.verify;\ntraverse.explode = visitors.explode;\n\n/**\n * [Please add a description.]\n */\n\ntraverse.node = function (node, opts, scope, state, parentPath, skipKeys) {\n  var keys = t.VISITOR_KEYS[node.type];\n  if (!keys) return;\n\n  var context = new _context2[\"default\"](scope, opts, state, parentPath);\n  var _arr = keys;\n  for (var _i = 0; _i < _arr.length; _i++) {\n    var key = _arr[_i];\n    if (skipKeys && skipKeys[key]) continue;\n    if (context.visit(node, key)) return;\n  }\n};\n\n/**\n * [Please add a description.]\n */\n\nvar CLEAR_KEYS = t.COMMENT_KEYS.concat([\"_scopeInfo\", \"_paths\", \"tokens\", \"comments\", \"start\", \"end\", \"loc\", \"raw\", \"rawValue\"]);\n\n/**\n * [Please add a description.]\n */\n\ntraverse.clearNode = function (node) {\n  for (var i = 0; i < CLEAR_KEYS.length; i++) {\n    var key = CLEAR_KEYS[i];\n    if (node[key] != null) node[key] = undefined;\n  }\n};\n\n/**\n * [Please add a description.]\n */\n\nvar clearVisitor = {\n  noScope: true,\n  exit: traverse.clearNode\n};\n\n/**\n * [Please add a description.]\n */\n\ntraverse.removeProperties = function (tree) {\n  traverse(tree, clearVisitor);\n  traverse.clearNode(tree);\n\n  return tree;\n};\n\n/**\n * [Please add a description.]\n */\n\nfunction hasBlacklistedType(node, parent, scope, state) {\n  if (node.type === state.type) {\n    state.has = true;\n    this.skip();\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\ntraverse.hasType = function (tree, scope, type, blacklistTypes) {\n  // the node we're searching in is blacklisted\n  if (_lodashCollectionIncludes2[\"default\"](blacklistTypes, tree.type)) return false;\n\n  // the type we're looking for is the same as the passed node\n  if (tree.type === type) return true;\n\n  var state = {\n    has: false,\n    type: type\n  };\n\n  traverse(tree, {\n    blacklist: blacklistTypes,\n    enter: hasBlacklistedType\n  }, scope, state);\n\n  return state.has;\n};\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// istanbul ignore next\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _path = require(\"./path\");\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _types = require(\"../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nvar TraversalContext = (function () {\n  function TraversalContext(scope, opts, state, parentPath) {\n    _classCallCheck(this, TraversalContext);\n\n    this.queue = null;\n\n    this.parentPath = parentPath;\n    this.scope = scope;\n    this.state = state;\n    this.opts = opts;\n  }\n\n  /**\n   * [Please add a description.]\n   */\n\n  TraversalContext.prototype.shouldVisit = function shouldVisit(node) {\n    var opts = this.opts;\n    if (opts.enter || opts.exit) return true;\n\n    if (opts[node.type]) return true;\n\n    var keys = t.VISITOR_KEYS[node.type];\n    if (!keys || !keys.length) return false;\n\n    var _arr = keys;\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var key = _arr[_i];\n      if (node[key]) return true;\n    }\n\n    return false;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  TraversalContext.prototype.create = function create(node, obj, key, listKey) {\n    var path = _path2[\"default\"].get({\n      parentPath: this.parentPath,\n      parent: node,\n      container: obj,\n      key: key,\n      listKey: listKey\n    });\n    path.unshiftContext(this);\n    return path;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  TraversalContext.prototype.visitMultiple = function visitMultiple(container, parent, listKey) {\n    // nothing to traverse!\n    if (container.length === 0) return false;\n\n    var visited = [];\n\n    var queue = this.queue = [];\n    var stop = false;\n\n    // build up initial queue\n    for (var key = 0; key < container.length; key++) {\n      var self = container[key];\n      if (self && this.shouldVisit(self)) {\n        queue.push(this.create(parent, container, key, listKey));\n      }\n    }\n\n    // visit the queue\n    var _arr2 = queue;\n    for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n      var path = _arr2[_i2];\n      path.resync();\n\n      if (visited.indexOf(path.node) >= 0) continue;\n      visited.push(path.node);\n\n      if (path.visit()) {\n        stop = true;\n        break;\n      }\n    }\n\n    var _arr3 = queue;\n    for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n      var path = _arr3[_i3];\n      path.shiftContext();\n    }\n\n    this.queue = null;\n\n    return stop;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  TraversalContext.prototype.visitSingle = function visitSingle(node, key) {\n    if (this.shouldVisit(node[key])) {\n      var path = this.create(node, node, key);\n      path.visit();\n      path.shiftContext();\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  TraversalContext.prototype.visit = function visit(node, key) {\n    var nodes = node[key];\n    if (!nodes) return;\n\n    if (Array.isArray(nodes)) {\n      return this.visitMultiple(nodes, node, key);\n    } else {\n      return this.visitSingle(node, key);\n    }\n  };\n\n  return TraversalContext;\n})();\n\nexports[\"default\"] = TraversalContext;\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _libVirtualTypes = require(\"./lib/virtual-types\");\n\nvar virtualTypes = _interopRequireWildcard(_libVirtualTypes);\n\nvar _index = require(\"../index\");\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _lodashObjectAssign = require(\"lodash/object/assign\");\n\nvar _lodashObjectAssign2 = _interopRequireDefault(_lodashObjectAssign);\n\nvar _scope = require(\"../scope\");\n\nvar _scope2 = _interopRequireDefault(_scope);\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nvar NodePath = (function () {\n\n  /**\n   * [Please add a description.]\n   */\n\n  function NodePath(hub, parent) {\n    _classCallCheck(this, NodePath);\n\n    this.contexts = [];\n    this.parent = parent;\n    this.data = {};\n    this.hub = hub;\n\n    this.shouldSkip = false;\n    this.shouldStop = false;\n    this.removed = false;\n    this.state = null;\n    this.opts = null;\n    this.skipKeys = null;\n    this.parentPath = null;\n    this.context = null;\n    this.container = null;\n    this.listKey = null;\n    this.inList = false;\n    this.parentKey = null;\n    this.key = null;\n    this.node = null;\n    this.scope = null;\n    this.type = null;\n    this.typeAnnotation = null;\n  }\n\n  /**\n   * [Please add a description.]\n   */\n\n  /**\n   * [Please add a description.]\n   */\n\n  NodePath.get = function get(_ref) {\n    var hub = _ref.hub;\n    var parentPath = _ref.parentPath;\n    var parent = _ref.parent;\n    var container = _ref.container;\n    var listKey = _ref.listKey;\n    var key = _ref.key;\n\n    if (!hub && parentPath) {\n      hub = parentPath.hub;\n    }\n\n    var targetNode = container[key];\n    var paths = parent._paths = parent._paths || [];\n    var path;\n\n    for (var i = 0; i < paths.length; i++) {\n      var pathCheck = paths[i];\n      if (pathCheck.node === targetNode) {\n        path = pathCheck;\n        break;\n      }\n    }\n\n    if (!path) {\n      path = new NodePath(hub, parent);\n      paths.push(path);\n    }\n\n    path.setup(parentPath, container, listKey, key);\n\n    return path;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  NodePath.prototype.getScope = function getScope(scope) {\n    var ourScope = scope;\n\n    // we're entering a new scope so let's construct it!\n    if (this.isScope()) {\n      ourScope = new _scope2[\"default\"](this, scope);\n    }\n\n    return ourScope;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  NodePath.prototype.setData = function setData(key, val) {\n    return this.data[key] = val;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  NodePath.prototype.getData = function getData(key, def) {\n    var val = this.data[key];\n    if (!val && def) val = this.data[key] = def;\n    return val;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  NodePath.prototype.errorWithNode = function errorWithNode(msg) {\n    var Error = arguments.length <= 1 || arguments[1] === undefined ? SyntaxError : arguments[1];\n\n    return this.hub.file.errorWithNode(this.node, msg, Error);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  NodePath.prototype.traverse = function traverse(visitor, state) {\n    _index2[\"default\"](this.node, visitor, this.scope, state, this);\n  };\n\n  return NodePath;\n})();\n\nexports[\"default\"] = NodePath;\n_lodashObjectAssign2[\"default\"](NodePath.prototype, require(\"./ancestry\"));\n_lodashObjectAssign2[\"default\"](NodePath.prototype, require(\"./inference\"));\n_lodashObjectAssign2[\"default\"](NodePath.prototype, require(\"./replacement\"));\n_lodashObjectAssign2[\"default\"](NodePath.prototype, require(\"./evaluation\"));\n_lodashObjectAssign2[\"default\"](NodePath.prototype, require(\"./conversion\"));\n_lodashObjectAssign2[\"default\"](NodePath.prototype, require(\"./introspection\"));\n_lodashObjectAssign2[\"default\"](NodePath.prototype, require(\"./context\"));\n_lodashObjectAssign2[\"default\"](NodePath.prototype, require(\"./removal\"));\n_lodashObjectAssign2[\"default\"](NodePath.prototype, require(\"./modification\"));\n_lodashObjectAssign2[\"default\"](NodePath.prototype, require(\"./family\"));\n_lodashObjectAssign2[\"default\"](NodePath.prototype, require(\"./comments\"));\n\nvar _arr = t.TYPES;\n\nvar _loop = function () {\n  var type = _arr[_i];\n  var typeKey = \"is\" + type;\n  NodePath.prototype[typeKey] = function (opts) {\n    return t[typeKey](this.node, opts);\n  };\n};\n\nfor (var _i = 0; _i < _arr.length; _i++) {\n  _loop();\n}\n\nvar _loop2 = function (type) {\n  if (type[0] === \"_\") return \"continue\";\n  if (t.TYPES.indexOf(type) < 0) t.TYPES.push(type);\n\n  NodePath.prototype[\"is\" + type] = function (opts) {\n    return virtualTypes[type].checkPath(this, opts);\n  };\n};\n\nfor (var type in virtualTypes) {\n  var _ret2 = _loop2(type);\n\n  // istanbul ignore next\n  if (_ret2 === \"continue\") continue;\n}\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _transformationHelpersReact = require(\"../../../transformation/helpers/react\");\n\nvar react = _interopRequireWildcard(_transformationHelpersReact);\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nvar ReferencedIdentifier = {\n  types: [\"Identifier\", \"JSXIdentifier\"],\n  checkPath: function checkPath(_ref, opts) {\n    var node = _ref.node;\n    var parent = _ref.parent;\n\n    if (!t.isIdentifier(node, opts)) {\n      if (t.isJSXIdentifier(node, opts)) {\n        if (react.isCompatTag(node.name)) return false;\n      } else {\n        // not a JSXIdentifier or an Identifier\n        return false;\n      }\n    }\n\n    // check if node is referenced\n    return t.isReferenced(node, parent);\n  }\n};\n\nexports.ReferencedIdentifier = ReferencedIdentifier;\n/**\n * [Please add a description.]\n */\n\nvar BindingIdentifier = {\n  types: [\"Identifier\"],\n  checkPath: function checkPath(_ref2) {\n    var node = _ref2.node;\n    var parent = _ref2.parent;\n\n    return t.isBinding(node, parent);\n  }\n};\n\nexports.BindingIdentifier = BindingIdentifier;\n/**\n * [Please add a description.]\n */\n\nvar Statement = {\n  types: [\"Statement\"],\n  checkPath: function checkPath(_ref3) {\n    var node = _ref3.node;\n    var parent = _ref3.parent;\n\n    if (t.isStatement(node)) {\n      if (t.isVariableDeclaration(node)) {\n        if (t.isForXStatement(parent, { left: node })) return false;\n        if (t.isForStatement(parent, { init: node })) return false;\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n};\n\nexports.Statement = Statement;\n/**\n * [Please add a description.]\n */\n\nvar Expression = {\n  types: [\"Expression\"],\n  checkPath: function checkPath(path) {\n    if (path.isIdentifier()) {\n      return path.isReferencedIdentifier();\n    } else {\n      return t.isExpression(path.node);\n    }\n  }\n};\n\nexports.Expression = Expression;\n/**\n * [Please add a description.]\n */\n\nvar Scope = {\n  types: [\"Scopable\"],\n  checkPath: function checkPath(path) {\n    return t.isScope(path.node, path.parent);\n  }\n};\n\nexports.Scope = Scope;\n/**\n * [Please add a description.]\n */\n\nvar Referenced = {\n  checkPath: function checkPath(path) {\n    return t.isReferenced(path.node, path.parent);\n  }\n};\n\nexports.Referenced = Referenced;\n/**\n * [Please add a description.]\n */\n\nvar BlockScoped = {\n  checkPath: function checkPath(path) {\n    return t.isBlockScoped(path.node);\n  }\n};\n\nexports.BlockScoped = BlockScoped;\n/**\n * [Please add a description.]\n */\n\nvar Var = {\n  types: [\"VariableDeclaration\"],\n  checkPath: function checkPath(path) {\n    return t.isVar(path.node);\n  }\n};\n\nexports.Var = Var;\n/**\n * [Please add a description.]\n */\n\nvar DirectiveLiteral = {\n  types: [\"Literal\"],\n  checkPath: function checkPath(path) {\n    return path.isLiteral() && path.parentPath.isExpressionStatement();\n  }\n};\n\nexports.DirectiveLiteral = DirectiveLiteral;\n/**\n * [Please add a description.]\n */\n\nvar Directive = {\n  types: [\"ExpressionStatement\"],\n  checkPath: function checkPath(path) {\n    return path.get(\"expression\").isLiteral();\n  }\n};\n\nexports.Directive = Directive;\n/**\n * [Please add a description.]\n */\n\nvar User = {\n  checkPath: function checkPath(path) {\n    return path.node && !!path.node.loc;\n  }\n};\n\nexports.User = User;\n/**\n * [Please add a description.]\n */\n\nvar Generated = {\n  checkPath: function checkPath(path) {\n    return !path.isUser();\n  }\n};\n\nexports.Generated = Generated;\n/**\n * [Please add a description.]\n */\n\nvar Flow = {\n  types: [\"Flow\", \"ImportDeclaration\", \"ExportDeclaration\"],\n  checkPath: function checkPath(_ref4) {\n    var node = _ref4.node;\n\n    if (t.isFlow(node)) {\n      return true;\n    } else if (t.isImportDeclaration(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else if (t.isExportDeclaration(node)) {\n      return node.exportKind === \"type\";\n    } else {\n      return false;\n    }\n  }\n};\nexports.Flow = Flow;","\n\nexports.__esModule = true;\nexports.isCompatTag = isCompatTag;\nexports.buildChildren = buildChildren;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\nvar isReactComponent = t.buildMatchMemberExpression(\"React.Component\");\n\nexports.isReactComponent = isReactComponent;\n/**\n * [Please add a description.]\n */\n\nfunction isCompatTag(tagName) {\n  return tagName && /^[a-z]|\\-/.test(tagName);\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction cleanJSXElementLiteralChild(child, args) {\n  var lines = child.value.split(/\\r\\n|\\n|\\r/);\n\n  var lastNonEmptyLine = 0;\n\n  for (var i = 0; i < lines.length; i++) {\n    if (lines[i].match(/[^ \\t]/)) {\n      lastNonEmptyLine = i;\n    }\n  }\n\n  var str = \"\";\n\n  for (var i = 0; i < lines.length; i++) {\n    var line = lines[i];\n\n    var isFirstLine = i === 0;\n    var isLastLine = i === lines.length - 1;\n    var isLastNonEmptyLine = i === lastNonEmptyLine;\n\n    // replace rendered whitespace tabs with spaces\n    var trimmedLine = line.replace(/\\t/g, \" \");\n\n    // trim whitespace touching a newline\n    if (!isFirstLine) {\n      trimmedLine = trimmedLine.replace(/^[ ]+/, \"\");\n    }\n\n    // trim whitespace touching an endline\n    if (!isLastLine) {\n      trimmedLine = trimmedLine.replace(/[ ]+$/, \"\");\n    }\n\n    if (trimmedLine) {\n      if (!isLastNonEmptyLine) {\n        trimmedLine += \" \";\n      }\n\n      str += trimmedLine;\n    }\n  }\n\n  if (str) args.push(t.literal(str));\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction buildChildren(node) {\n  var elems = [];\n\n  for (var i = 0; i < node.children.length; i++) {\n    var child = node.children[i];\n\n    if (t.isLiteral(child) && typeof child.value === \"string\") {\n      cleanJSXElementLiteralChild(child, elems);\n      continue;\n    }\n\n    if (t.isJSXExpressionContainer(child)) child = child.expression;\n    if (t.isJSXEmptyExpression(child)) continue;\n\n    elems.push(child);\n  }\n\n  return elems;\n}","\n\nexports.__esModule = true;\nexports.is = is;\nexports.isType = isType;\nexports.shallowEqual = shallowEqual;\nexports.appendToMemberExpression = appendToMemberExpression;\nexports.prependToMemberExpression = prependToMemberExpression;\nexports.ensureBlock = ensureBlock;\nexports.clone = clone;\nexports.cloneDeep = cloneDeep;\nexports.buildMatchMemberExpression = buildMatchMemberExpression;\nexports.removeComments = removeComments;\nexports.inheritsComments = inheritsComments;\nexports.inheritTrailingComments = inheritTrailingComments;\nexports.inheritLeadingComments = inheritLeadingComments;\nexports.inheritInnerComments = inheritInnerComments;\nexports.inherits = inherits;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _toFastProperties = require(\"to-fast-properties\");\n\nvar _toFastProperties2 = _interopRequireDefault(_toFastProperties);\n\nvar _lodashArrayCompact = require(\"lodash/array/compact\");\n\nvar _lodashArrayCompact2 = _interopRequireDefault(_lodashArrayCompact);\n\nvar _lodashObjectAssign = require(\"lodash/object/assign\");\n\nvar _lodashObjectAssign2 = _interopRequireDefault(_lodashObjectAssign);\n\nvar _lodashCollectionEach = require(\"lodash/collection/each\");\n\nvar _lodashCollectionEach2 = _interopRequireDefault(_lodashCollectionEach);\n\nvar _lodashArrayUniq = require(\"lodash/array/uniq\");\n\nvar _lodashArrayUniq2 = _interopRequireDefault(_lodashArrayUniq);\n\nrequire(\"./definitions/init\");\n\nvar _definitions = require(\"./definitions\");\n\nvar t = exports;\n\n/**\n * Registers `is[Type]` and `assert[Type]` generated functions for a given `type`.\n * Pass `skipAliasCheck` to force it to directly compare `node.type` with `type`.\n */\n\nfunction registerType(type, skipAliasCheck) {\n  var is = t[\"is\" + type] = function (node, opts) {\n    return t.is(type, node, opts, skipAliasCheck);\n  };\n\n  t[\"assert\" + type] = function (node, opts) {\n    opts = opts || {};\n    if (!is(node, opts)) {\n      throw new Error(\"Expected type \" + JSON.stringify(type) + \" with option \" + JSON.stringify(opts));\n    }\n  };\n}\n\n/**\n * Constants.\n */\n\nvar STATEMENT_OR_BLOCK_KEYS = [\"consequent\", \"body\", \"alternate\"];\nexports.STATEMENT_OR_BLOCK_KEYS = STATEMENT_OR_BLOCK_KEYS;\nvar FLATTENABLE_KEYS = [\"body\", \"expressions\"];\nexports.FLATTENABLE_KEYS = FLATTENABLE_KEYS;\nvar FOR_INIT_KEYS = [\"left\", \"init\"];\nexports.FOR_INIT_KEYS = FOR_INIT_KEYS;\nvar COMMENT_KEYS = [\"leadingComments\", \"trailingComments\", \"innerComments\"];\n\nexports.COMMENT_KEYS = COMMENT_KEYS;\nvar INHERIT_KEYS = {\n  optional: [\"typeAnnotation\", \"typeParameters\", \"returnType\"],\n  force: [\"_scopeInfo\", \"_paths\", \"start\", \"loc\", \"end\"]\n};\n\nexports.INHERIT_KEYS = INHERIT_KEYS;\nvar BOOLEAN_NUMBER_BINARY_OPERATORS = [\">\", \"<\", \">=\", \"<=\"];\nexports.BOOLEAN_NUMBER_BINARY_OPERATORS = BOOLEAN_NUMBER_BINARY_OPERATORS;\nvar EQUALITY_BINARY_OPERATORS = [\"==\", \"===\", \"!=\", \"!==\"];\nexports.EQUALITY_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS;\nvar COMPARISON_BINARY_OPERATORS = EQUALITY_BINARY_OPERATORS.concat([\"in\", \"instanceof\"]);\nexports.COMPARISON_BINARY_OPERATORS = COMPARISON_BINARY_OPERATORS;\nvar BOOLEAN_BINARY_OPERATORS = [].concat(COMPARISON_BINARY_OPERATORS, BOOLEAN_NUMBER_BINARY_OPERATORS);\nexports.BOOLEAN_BINARY_OPERATORS = BOOLEAN_BINARY_OPERATORS;\nvar NUMBER_BINARY_OPERATORS = [\"-\", \"/\", \"*\", \"**\", \"&\", \"|\", \">>\", \">>>\", \"<<\", \"^\"];\n\nexports.NUMBER_BINARY_OPERATORS = NUMBER_BINARY_OPERATORS;\nvar BOOLEAN_UNARY_OPERATORS = [\"delete\", \"!\"];\nexports.BOOLEAN_UNARY_OPERATORS = BOOLEAN_UNARY_OPERATORS;\nvar NUMBER_UNARY_OPERATORS = [\"+\", \"-\", \"++\", \"--\", \"~\"];\nexports.NUMBER_UNARY_OPERATORS = NUMBER_UNARY_OPERATORS;\nvar STRING_UNARY_OPERATORS = [\"typeof\"];\n\nexports.STRING_UNARY_OPERATORS = STRING_UNARY_OPERATORS;\nexports.VISITOR_KEYS = _definitions.VISITOR_KEYS;\nexports.BUILDER_KEYS = _definitions.BUILDER_KEYS;\nexports.ALIAS_KEYS = _definitions.ALIAS_KEYS;\n\n/**\n * Registers `is[Type]` and `assert[Type]` for all types.\n */\n\n_lodashCollectionEach2[\"default\"](t.VISITOR_KEYS, function (keys, type) {\n  registerType(type, true);\n});\n\n/**\n * Flip `ALIAS_KEYS` for faster access in the reverse direction.\n */\n\nt.FLIPPED_ALIAS_KEYS = {};\n\n_lodashCollectionEach2[\"default\"](t.ALIAS_KEYS, function (aliases, type) {\n  _lodashCollectionEach2[\"default\"](aliases, function (alias) {\n    var types = t.FLIPPED_ALIAS_KEYS[alias] = t.FLIPPED_ALIAS_KEYS[alias] || [];\n    types.push(type);\n  });\n});\n\n/**\n * Registers `is[Alias]` and `assert[Alias]` functions for all aliases.\n */\n\n_lodashCollectionEach2[\"default\"](t.FLIPPED_ALIAS_KEYS, function (types, type) {\n  t[type.toUpperCase() + \"_TYPES\"] = types;\n  registerType(type, false);\n});\n\nvar TYPES = Object.keys(t.VISITOR_KEYS).concat(Object.keys(t.FLIPPED_ALIAS_KEYS));\n\nexports.TYPES = TYPES;\n/**\n * Returns whether `node` is of given `type`.\n *\n * For better performance, use this instead of `is[Type]` when `type` is unknown.\n * Optionally, pass `skipAliasCheck` to directly compare `node.type` with `type`.\n */\n\n// @TODO should `skipAliasCheck` be removed?\n/*eslint-disable no-unused-vars */\n\nfunction is(type, node, opts, skipAliasCheck) {\n  if (!node) return false;\n\n  var matches = isType(node.type, type);\n  if (!matches) return false;\n\n  if (typeof opts === \"undefined\") {\n    return true;\n  } else {\n    return t.shallowEqual(node, opts);\n  }\n}\n\n/*eslint-enable no-unused-vars */\n\n/**\n * Test if a `nodeType` is a `targetType` or if `targetType` is an alias of `nodeType`.\n */\n\nfunction isType(nodeType, targetType) {\n  if (nodeType === targetType) return true;\n\n  var aliases = t.FLIPPED_ALIAS_KEYS[targetType];\n  if (aliases) {\n    if (aliases[0] === nodeType) return true;\n\n    var _arr = aliases;\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var alias = _arr[_i];\n      if (nodeType === alias) return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * [Please add a description.]\n */\n\n_lodashCollectionEach2[\"default\"](t.VISITOR_KEYS, function (keys, type) {\n  if (t.BUILDER_KEYS[type]) return;\n\n  var defs = {};\n  _lodashCollectionEach2[\"default\"](keys, function (key) {\n    defs[key] = null;\n  });\n  t.BUILDER_KEYS[type] = defs;\n});\n\n/**\n * [Please add a description.]\n */\n\n_lodashCollectionEach2[\"default\"](t.BUILDER_KEYS, function (keys, type) {\n  var builder = function builder() {\n    var node = {};\n    node.type = type;\n\n    var i = 0;\n\n    for (var key in keys) {\n      var arg = arguments[i++];\n      if (arg === undefined) arg = keys[key];\n      node[key] = arg;\n    }\n\n    return node;\n  };\n\n  t[type] = builder;\n  t[type[0].toLowerCase() + type.slice(1)] = builder;\n});\n\n/**\n * Test if an object is shallowly equal.\n */\n\nfunction shallowEqual(actual, expected) {\n  var keys = Object.keys(expected);\n\n  var _arr2 = keys;\n  for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n    var key = _arr2[_i2];\n    if (actual[key] !== expected[key]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Append a node to a member expression.\n */\n\nfunction appendToMemberExpression(member, append, computed) {\n  member.object = t.memberExpression(member.object, member.property, member.computed);\n  member.property = append;\n  member.computed = !!computed;\n  return member;\n}\n\n/**\n * Prepend a node to a member expression.\n */\n\nfunction prependToMemberExpression(member, prepend) {\n  member.object = t.memberExpression(prepend, member.object);\n  return member;\n}\n\n/**\n * Ensure the `key` (defaults to \"body\") of a `node` is a block.\n * Casting it to a block if it is not.\n */\n\nfunction ensureBlock(node) {\n  var key = arguments.length <= 1 || arguments[1] === undefined ? \"body\" : arguments[1];\n\n  return node[key] = t.toBlock(node[key], node);\n}\n\n/**\n * Create a shallow clone of a `node` excluding `_private` properties.\n */\n\nfunction clone(node) {\n  var newNode = {};\n  for (var key in node) {\n    if (key[0] === \"_\") continue;\n    newNode[key] = node[key];\n  }\n  return newNode;\n}\n\n/**\n * Create a deep clone of a `node` and all of it's child nodes\n * exluding `_private` properties.\n */\n\nfunction cloneDeep(node) {\n  var newNode = {};\n\n  for (var key in node) {\n    if (key[0] === \"_\") continue;\n\n    var val = node[key];\n\n    if (val) {\n      if (val.type) {\n        val = t.cloneDeep(val);\n      } else if (Array.isArray(val)) {\n        val = val.map(t.cloneDeep);\n      }\n    }\n\n    newNode[key] = val;\n  }\n\n  return newNode;\n}\n\n/**\n * Build a function that when called will return whether or not the\n * input `node` `MemberExpression` matches the input `match`.\n *\n * For example, given the match `React.createClass` it would match the\n * parsed nodes of `React.createClass` and `React[\"createClass\"]`.\n */\n\nfunction buildMatchMemberExpression(match, allowPartial) {\n  var parts = match.split(\".\");\n\n  return function (member) {\n    // not a member expression\n    if (!t.isMemberExpression(member)) return false;\n\n    var search = [member];\n    var i = 0;\n\n    while (search.length) {\n      var node = search.shift();\n\n      if (allowPartial && i === parts.length) {\n        return true;\n      }\n\n      if (t.isIdentifier(node)) {\n        // this part doesn't match\n        if (parts[i] !== node.name) return false;\n      } else if (t.isLiteral(node)) {\n        // this part doesn't match\n        if (parts[i] !== node.value) return false;\n      } else if (t.isMemberExpression(node)) {\n        if (node.computed && !t.isLiteral(node.property)) {\n          // we can't deal with this\n          return false;\n        } else {\n          search.push(node.object);\n          search.push(node.property);\n          continue;\n        }\n      } else {\n        // we can't deal with this\n        return false;\n      }\n\n      // too many parts\n      if (++i > parts.length) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n}\n\n/**\n * Remove comment properties from a node.\n */\n\nfunction removeComments(node) {\n  var _arr3 = COMMENT_KEYS;\n\n  for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n    var key = _arr3[_i3];\n    delete node[key];\n  }\n  return node;\n}\n\n/**\n * Inherit all unique comments from `parent` node to `child` node.\n */\n\nfunction inheritsComments(child, parent) {\n  inheritTrailingComments(child, parent);\n  inheritLeadingComments(child, parent);\n  inheritInnerComments(child, parent);\n  return child;\n}\n\nfunction inheritTrailingComments(child, parent) {\n  _inheritComments(\"trailingComments\", child, parent);\n}\n\nfunction inheritLeadingComments(child, parent) {\n  _inheritComments(\"leadingComments\", child, parent);\n}\n\nfunction inheritInnerComments(child, parent) {\n  _inheritComments(\"innerComments\", child, parent);\n}\n\nfunction _inheritComments(key, child, parent) {\n  if (child && parent) {\n    child[key] = _lodashArrayUniq2[\"default\"](_lodashArrayCompact2[\"default\"]([].concat(child[key], parent[key])));\n  }\n}\n\n/**\n * Inherit all contextual properties from `parent` node to `child` node.\n */\n\nfunction inherits(child, parent) {\n  if (!child || !parent) return child;\n\n  var _arr4 = t.INHERIT_KEYS.optional;\n  for (var _i4 = 0; _i4 < _arr4.length; _i4++) {\n    var key = _arr4[_i4];\n    if (child[key] == null) {\n      child[key] = parent[key];\n    }\n  }\n\n  var _arr5 = t.INHERIT_KEYS.force;\n  for (var _i5 = 0; _i5 < _arr5.length; _i5++) {\n    var key = _arr5[_i5];\n    child[key] = parent[key];\n  }\n\n  t.inheritsComments(child, parent);\n\n  return child;\n}\n\n// Optimize property access.\n_toFastProperties2[\"default\"](t);\n_toFastProperties2[\"default\"](t.VISITOR_KEYS);\n\n// Export all type checkers from other files.\n_lodashObjectAssign2[\"default\"](t, require(\"./retrievers\"));\n_lodashObjectAssign2[\"default\"](t, require(\"./validators\"));\n_lodashObjectAssign2[\"default\"](t, require(\"./converters\"));\n_lodashObjectAssign2[\"default\"](t, require(\"./flow\"));","\n\nrequire(\"./index\");\n\nrequire(\"./core\");\n\nrequire(\"./es2015\");\n\nrequire(\"./flow\");\n\nrequire(\"./jsx\");\n\nrequire(\"./misc\");\n\nrequire(\"./experimental\");","\n\nexports.__esModule = true;\nexports[\"default\"] = defineType;\nvar VISITOR_KEYS = {};\nexports.VISITOR_KEYS = VISITOR_KEYS;\nvar ALIAS_KEYS = {};\nexports.ALIAS_KEYS = ALIAS_KEYS;\nvar BUILDER_KEYS = {};\n\nexports.BUILDER_KEYS = BUILDER_KEYS;\nfunction builderFromArray(arr) {\n  var builder = {};\n  var _arr = arr;\n  for (var _i = 0; _i < _arr.length; _i++) {\n    var key = _arr[_i];builder[key] = null;\n  }return builder;\n}\n\nfunction defineType(type) {\n  var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n  opts.visitor = opts.visitor || [];\n  opts.aliases = opts.aliases || [];\n\n  if (!opts.builder) opts.builder = builderFromArray(opts.visitor);\n  if (Array.isArray(opts.builder)) opts.builder = builderFromArray(opts.builder);\n\n  VISITOR_KEYS[type] = opts.visitor;\n  ALIAS_KEYS[type] = opts.aliases;\n  BUILDER_KEYS[type] = opts.builder;\n}","\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _index = require(\"./index\");\n\nvar _index2 = _interopRequireDefault(_index);\n\n_index2[\"default\"](\"ArrayExpression\", {\n  visitor: [\"elements\"],\n  aliases: [\"Expression\"]\n});\n\n_index2[\"default\"](\"AssignmentExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Expression\"]\n});\n\n_index2[\"default\"](\"BinaryExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"]\n});\n\n_index2[\"default\"](\"BlockStatement\", {\n  visitor: [\"body\"],\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\", \"Statement\"]\n});\n\n_index2[\"default\"](\"BreakStatement\", {\n  visitor: [\"label\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\n\n_index2[\"default\"](\"CallExpression\", {\n  visitor: [\"callee\", \"arguments\"],\n  aliases: [\"Expression\"]\n});\n\n_index2[\"default\"](\"CatchClause\", {\n  visitor: [\"param\", \"body\"],\n  aliases: [\"Scopable\"]\n});\n\n_index2[\"default\"](\"ConditionalExpression\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  aliases: [\"Expression\"]\n});\n\n_index2[\"default\"](\"ContinueStatement\", {\n  visitor: [\"label\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\n\n_index2[\"default\"](\"DebuggerStatement\", {\n  aliases: [\"Statement\"]\n});\n\n_index2[\"default\"](\"DoWhileStatement\", {\n  visitor: [\"body\", \"test\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"]\n});\n\n_index2[\"default\"](\"EmptyStatement\", {\n  aliases: [\"Statement\"]\n});\n\n_index2[\"default\"](\"ExpressionStatement\", {\n  visitor: [\"expression\"],\n  aliases: [\"Statement\"]\n});\n\n_index2[\"default\"](\"File\", {\n  builder: [\"program\", \"comments\", \"tokens\"],\n  visitor: [\"program\"]\n});\n\n_index2[\"default\"](\"ForInStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"]\n});\n\n_index2[\"default\"](\"ForStatement\", {\n  visitor: [\"init\", \"test\", \"update\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\"]\n});\n\n_index2[\"default\"](\"FunctionDeclaration\", {\n  builder: {\n    id: null,\n    params: null,\n    body: null,\n    generator: false,\n    async: false\n  },\n  visitor: [\"id\", \"params\", \"body\", \"returnType\", \"typeParameters\"],\n  aliases: [\"Scopable\", \"Function\", \"Func\", \"BlockParent\", \"FunctionParent\", \"Statement\", \"Pure\", \"Declaration\"]\n});\n\n_index2[\"default\"](\"FunctionExpression\", {\n  builder: {\n    id: null,\n    params: null,\n    body: null,\n    generator: false,\n    async: false\n  },\n  visitor: [\"id\", \"params\", \"body\", \"returnType\", \"typeParameters\"],\n  aliases: [\"Scopable\", \"Function\", \"Func\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pure\"]\n});\n\n_index2[\"default\"](\"Identifier\", {\n  builder: [\"name\"],\n  visitor: [\"typeAnnotation\"],\n  aliases: [\"Expression\"]\n});\n\n_index2[\"default\"](\"IfStatement\", {\n  visitor: [\"test\", \"consequent\", \"alternate\"],\n  aliases: [\"Statement\"]\n});\n\n_index2[\"default\"](\"LabeledStatement\", {\n  visitor: [\"label\", \"body\"],\n  aliases: [\"Statement\"]\n});\n\n_index2[\"default\"](\"Literal\", {\n  builder: [\"value\"],\n  aliases: [\"Expression\", \"Pure\"]\n});\n\n_index2[\"default\"](\"LogicalExpression\", {\n  builder: [\"operator\", \"left\", \"right\"],\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Binary\", \"Expression\"]\n});\n\n_index2[\"default\"](\"MemberExpression\", {\n  builder: {\n    object: null,\n    property: null,\n    computed: false\n  },\n  visitor: [\"object\", \"property\"],\n  aliases: [\"Expression\"]\n});\n\n_index2[\"default\"](\"NewExpression\", {\n  visitor: [\"callee\", \"arguments\"],\n  aliases: [\"Expression\"]\n});\n\n_index2[\"default\"](\"ObjectExpression\", {\n  visitor: [\"properties\"],\n  aliases: [\"Expression\"]\n});\n\n_index2[\"default\"](\"Program\", {\n  visitor: [\"body\"],\n  aliases: [\"Scopable\", \"BlockParent\", \"Block\", \"FunctionParent\"]\n});\n\n_index2[\"default\"](\"Property\", {\n  builder: {\n    kind: \"init\",\n    key: null,\n    value: null,\n    computed: false\n  },\n  visitor: [\"key\", \"value\", \"decorators\"],\n  aliases: [\"UserWhitespacable\"]\n});\n\n_index2[\"default\"](\"RestElement\", {\n  visitor: [\"argument\", \"typeAnnotation\"]\n});\n\n_index2[\"default\"](\"ReturnStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\n\n_index2[\"default\"](\"SequenceExpression\", {\n  visitor: [\"expressions\"],\n  aliases: [\"Expression\"]\n});\n\n_index2[\"default\"](\"SwitchCase\", {\n  visitor: [\"test\", \"consequent\"]\n});\n\n_index2[\"default\"](\"SwitchStatement\", {\n  visitor: [\"discriminant\", \"cases\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Scopable\"]\n});\n\n_index2[\"default\"](\"ThisExpression\", {\n  aliases: [\"Expression\"]\n});\n\n_index2[\"default\"](\"ThrowStatement\", {\n  visitor: [\"argument\"],\n  aliases: [\"Statement\", \"Terminatorless\", \"CompletionStatement\"]\n});\n\n_index2[\"default\"](\"TryStatement\", {\n  builder: [\"block\", \"handler\", \"finalizer\"],\n  visitor: [\"block\", \"handlers\", \"handler\", \"guardedHandlers\", \"finalizer\"],\n  aliases: [\"Statement\"]\n});\n\n_index2[\"default\"](\"UnaryExpression\", {\n  builder: {\n    operator: null,\n    argument: null,\n    prefix: false\n  },\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\", \"Expression\"]\n});\n\n_index2[\"default\"](\"UpdateExpression\", {\n  builder: {\n    operator: null,\n    argument: null,\n    prefix: false\n  },\n  visitor: [\"argument\"],\n  aliases: [\"Expression\"]\n});\n\n_index2[\"default\"](\"VariableDeclaration\", {\n  builder: [\"kind\", \"declarations\"],\n  visitor: [\"declarations\"],\n  aliases: [\"Statement\", \"Declaration\"]\n});\n\n_index2[\"default\"](\"VariableDeclarator\", {\n  visitor: [\"id\", \"init\"]\n});\n\n_index2[\"default\"](\"WhileStatement\", {\n  visitor: [\"test\", \"body\"],\n  aliases: [\"Statement\", \"BlockParent\", \"Loop\", \"While\", \"Scopable\"]\n});\n\n_index2[\"default\"](\"WithStatement\", {\n  visitor: [\"object\", \"body\"],\n  aliases: [\"Statement\"]\n});","\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _index = require(\"./index\");\n\nvar _index2 = _interopRequireDefault(_index);\n\n_index2[\"default\"](\"AssignmentPattern\", {\n  visitor: [\"left\", \"right\"],\n  aliases: [\"Pattern\"]\n});\n\n_index2[\"default\"](\"ArrayPattern\", {\n  visitor: [\"elements\", \"typeAnnotation\"],\n  aliases: [\"Pattern\"]\n});\n\n_index2[\"default\"](\"ArrowFunctionExpression\", {\n  builder: [\"params\", \"body\", \"async\"],\n  visitor: [\"params\", \"body\", \"returnType\"],\n  aliases: [\"Scopable\", \"Function\", \"Func\", \"BlockParent\", \"FunctionParent\", \"Expression\", \"Pure\"]\n});\n\n_index2[\"default\"](\"ClassBody\", {\n  visitor: [\"body\"]\n});\n\n_index2[\"default\"](\"ClassDeclaration\", {\n  visitor: [\"id\", \"body\", \"superClass\", \"mixins\", \"typeParameters\", \"superTypeParameters\", \"implements\", \"decorators\"],\n  aliases: [\"Scopable\", \"Class\", \"Statement\", \"Declaration\"]\n});\n\n_index2[\"default\"](\"ClassExpression\", {\n  visitor: [\"id\", \"body\", \"superClass\", \"typeParameters\", \"superTypeParameters\", \"implements\", \"decorators\"],\n  aliases: [\"Scopable\", \"Class\", \"Expression\"]\n});\n\n_index2[\"default\"](\"ExportAllDeclaration\", {\n  visitor: [\"source\", \"exported\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"]\n});\n\n_index2[\"default\"](\"ExportDefaultDeclaration\", {\n  visitor: [\"declaration\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"]\n});\n\n_index2[\"default\"](\"ExportNamedDeclaration\", {\n  visitor: [\"declaration\", \"specifiers\", \"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\", \"ExportDeclaration\"]\n});\n\n_index2[\"default\"](\"ExportDefaultSpecifier\", {\n  visitor: [\"exported\"],\n  aliases: [\"ModuleSpecifier\"]\n});\n\n_index2[\"default\"](\"ExportNamespaceSpecifier\", {\n  visitor: [\"exported\"],\n  aliases: [\"ModuleSpecifier\"]\n});\n\n_index2[\"default\"](\"ExportSpecifier\", {\n  visitor: [\"local\", \"exported\"],\n  aliases: [\"ModuleSpecifier\"]\n});\n\n_index2[\"default\"](\"ForOfStatement\", {\n  visitor: [\"left\", \"right\", \"body\"],\n  aliases: [\"Scopable\", \"Statement\", \"For\", \"BlockParent\", \"Loop\", \"ForXStatement\"]\n});\n\n_index2[\"default\"](\"ImportDeclaration\", {\n  visitor: [\"specifiers\", \"source\"],\n  aliases: [\"Statement\", \"Declaration\", \"ModuleDeclaration\"]\n});\n\n_index2[\"default\"](\"ImportDefaultSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"]\n});\n\n_index2[\"default\"](\"ImportNamespaceSpecifier\", {\n  visitor: [\"local\"],\n  aliases: [\"ModuleSpecifier\"]\n});\n\n_index2[\"default\"](\"ImportSpecifier\", {\n  visitor: [\"local\", \"imported\"],\n  aliases: [\"ModuleSpecifier\"]\n});\n\n_index2[\"default\"](\"MetaProperty\", {\n  visitor: [\"meta\", \"property\"],\n  aliases: [\"Expression\"]\n});\n\n_index2[\"default\"](\"MethodDefinition\", {\n  builder: {\n    key: null,\n    value: null,\n    kind: \"method\",\n    computed: false,\n    \"static\": false\n  },\n  visitor: [\"key\", \"value\", \"decorators\"]\n});\n\n_index2[\"default\"](\"ObjectPattern\", {\n  visitor: [\"properties\", \"typeAnnotation\"],\n  aliases: [\"Pattern\"]\n});\n\n_index2[\"default\"](\"SpreadElement\", {\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\"]\n});\n\n_index2[\"default\"](\"Super\", {\n  aliases: [\"Expression\"]\n});\n\n_index2[\"default\"](\"TaggedTemplateExpression\", {\n  visitor: [\"tag\", \"quasi\"],\n  aliases: [\"Expression\"]\n});\n\n_index2[\"default\"](\"TemplateElement\");\n\n_index2[\"default\"](\"TemplateLiteral\", {\n  visitor: [\"quasis\", \"expressions\"],\n  aliases: [\"Expression\"]\n});\n\n_index2[\"default\"](\"YieldExpression\", {\n  builder: [\"argument\", \"delegate\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"]\n});","\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _index = require(\"./index\");\n\nvar _index2 = _interopRequireDefault(_index);\n\n_index2[\"default\"](\"AnyTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowBaseAnnotation\"]\n});\n\n_index2[\"default\"](\"ArrayTypeAnnotation\", {\n  visitor: [\"elementType\"],\n  aliases: [\"Flow\"]\n});\n\n_index2[\"default\"](\"BooleanTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowBaseAnnotation\"]\n});\n\n_index2[\"default\"](\"BooleanLiteralTypeAnnotation\", {\n  aliases: [\"Flow\"]\n});\n\n_index2[\"default\"](\"ClassImplements\", {\n  visitor: [\"id\", \"typeParameters\"],\n  aliases: [\"Flow\"]\n});\n\n_index2[\"default\"](\"ClassProperty\", {\n  visitor: [\"key\", \"value\", \"typeAnnotation\", \"decorators\"],\n  aliases: [\"Flow\"]\n});\n\n_index2[\"default\"](\"DeclareClass\", {\n  visitor: [\"id\", \"typeParameters\", \"extends\", \"body\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"]\n});\n\n_index2[\"default\"](\"DeclareFunction\", {\n  visitor: [\"id\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"]\n});\n\n_index2[\"default\"](\"DeclareInterface\", {\n  visitor: [\"id\", \"typeParameters\", \"extends\", \"body\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"]\n});\n\n_index2[\"default\"](\"DeclareModule\", {\n  visitor: [\"id\", \"body\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"]\n});\n\n_index2[\"default\"](\"DeclareTypeAlias\", {\n  visitor: [\"id\", \"typeParameters\", \"right\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"]\n});\n\n_index2[\"default\"](\"DeclareVariable\", {\n  visitor: [\"id\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"]\n});\n\n_index2[\"default\"](\"FunctionTypeAnnotation\", {\n  visitor: [\"typeParameters\", \"params\", \"rest\", \"returnType\"],\n  aliases: [\"Flow\"]\n});\n\n_index2[\"default\"](\"FunctionTypeParam\", {\n  visitor: [\"name\", \"typeAnnotation\"],\n  aliases: [\"Flow\"]\n});\n\n_index2[\"default\"](\"GenericTypeAnnotation\", {\n  visitor: [\"id\", \"typeParameters\"],\n  aliases: [\"Flow\"]\n});\n\n_index2[\"default\"](\"InterfaceExtends\", {\n  visitor: [\"id\", \"typeParameters\"],\n  aliases: [\"Flow\"]\n});\n\n_index2[\"default\"](\"InterfaceDeclaration\", {\n  visitor: [\"id\", \"typeParameters\", \"extends\", \"body\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"]\n});\n\n_index2[\"default\"](\"IntersectionTypeAnnotation\", {\n  visitor: [\"types\"],\n  aliases: [\"Flow\"]\n});\n\n_index2[\"default\"](\"MixedTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowBaseAnnotation\"]\n});\n\n_index2[\"default\"](\"NullableTypeAnnotation\", {\n  visitor: [\"typeAnnotation\"],\n  aliases: [\"Flow\"]\n});\n\n_index2[\"default\"](\"NullLiteralTypeAnnotation\", {\n  aliases: [\"Flow\"]\n});\n\n_index2[\"default\"](\"NumberLiteralTypeAnnotation\", {\n  aliases: [\"Flow\"]\n});\n\n_index2[\"default\"](\"NumberTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowBaseAnnotation\"]\n});\n\n_index2[\"default\"](\"StringLiteralTypeAnnotation\", {\n  aliases: [\"Flow\"]\n});\n\n_index2[\"default\"](\"StringTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowBaseAnnotation\"]\n});\n\n_index2[\"default\"](\"ThisTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowBaseAnnotation\"]\n});\n\n_index2[\"default\"](\"TupleTypeAnnotation\", {\n  visitor: [\"types\"],\n  aliases: [\"Flow\"]\n});\n\n_index2[\"default\"](\"TypeofTypeAnnotation\", {\n  visitor: [\"argument\"],\n  aliases: [\"Flow\"]\n});\n\n_index2[\"default\"](\"TypeAlias\", {\n  visitor: [\"id\", \"typeParameters\", \"right\"],\n  aliases: [\"Flow\", \"FlowDeclaration\", \"Statement\", \"Declaration\"]\n});\n\n_index2[\"default\"](\"TypeAnnotation\", {\n  visitor: [\"typeAnnotation\"],\n  aliases: [\"Flow\"]\n});\n\n_index2[\"default\"](\"TypeCastExpression\", {\n  visitor: [\"expression\", \"typeAnnotation\"],\n  aliases: [\"Flow\"]\n});\n\n_index2[\"default\"](\"TypeParameterDeclaration\", {\n  visitor: [\"params\"],\n  aliases: [\"Flow\"]\n});\n\n_index2[\"default\"](\"TypeParameterInstantiation\", {\n  visitor: [\"params\"],\n  aliases: [\"Flow\"]\n});\n\n_index2[\"default\"](\"ObjectTypeAnnotation\", {\n  visitor: [\"properties\", \"indexers\", \"callProperties\"],\n  aliases: [\"Flow\"]\n});\n\n_index2[\"default\"](\"ObjectTypeCallProperty\", {\n  visitor: [\"value\"],\n  aliases: [\"Flow\", \"UserWhitespacable\"]\n});\n\n_index2[\"default\"](\"ObjectTypeIndexer\", {\n  visitor: [\"id\", \"key\", \"value\"],\n  aliases: [\"Flow\", \"UserWhitespacable\"]\n});\n\n_index2[\"default\"](\"ObjectTypeProperty\", {\n  visitor: [\"key\", \"value\"],\n  aliases: [\"Flow\", \"UserWhitespacable\"]\n});\n\n_index2[\"default\"](\"QualifiedTypeIdentifier\", {\n  visitor: [\"id\", \"qualification\"],\n  aliases: [\"Flow\"]\n});\n\n_index2[\"default\"](\"UnionTypeAnnotation\", {\n  visitor: [\"types\"],\n  aliases: [\"Flow\"]\n});\n\n_index2[\"default\"](\"VoidTypeAnnotation\", {\n  aliases: [\"Flow\", \"FlowBaseAnnotation\"]\n});","\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _index = require(\"./index\");\n\nvar _index2 = _interopRequireDefault(_index);\n\n_index2[\"default\"](\"JSXAttribute\", {\n  visitor: [\"name\", \"value\"],\n  aliases: [\"JSX\", \"Immutable\"]\n});\n\n_index2[\"default\"](\"JSXClosingElement\", {\n  visitor: [\"name\"],\n  aliases: [\"JSX\", \"Immutable\"]\n});\n\n_index2[\"default\"](\"JSXElement\", {\n  visitor: [\"openingElement\", \"closingElement\", \"children\"],\n  aliases: [\"JSX\", \"Immutable\", \"Expression\"]\n});\n\n_index2[\"default\"](\"JSXEmptyExpression\", {\n  aliases: [\"JSX\", \"Expression\"]\n});\n\n_index2[\"default\"](\"JSXExpressionContainer\", {\n  visitor: [\"expression\"],\n  aliases: [\"JSX\", \"Immutable\"]\n});\n\n_index2[\"default\"](\"JSXIdentifier\", {\n  aliases: [\"JSX\", \"Expression\"]\n});\n\n_index2[\"default\"](\"JSXMemberExpression\", {\n  visitor: [\"object\", \"property\"],\n  aliases: [\"JSX\", \"Expression\"]\n});\n\n_index2[\"default\"](\"JSXNamespacedName\", {\n  visitor: [\"namespace\", \"name\"],\n  aliases: [\"JSX\"]\n});\n\n_index2[\"default\"](\"JSXOpeningElement\", {\n  visitor: [\"name\", \"attributes\"],\n  aliases: [\"JSX\", \"Immutable\"]\n});\n\n_index2[\"default\"](\"JSXSpreadAttribute\", {\n  visitor: [\"argument\"],\n  aliases: [\"JSX\"]\n});","\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _index = require(\"./index\");\n\nvar _index2 = _interopRequireDefault(_index);\n\n_index2[\"default\"](\"Noop\", {\n  visitor: []\n});\n\n_index2[\"default\"](\"ParenthesizedExpression\", {\n  visitor: [\"expression\"],\n  aliases: [\"Expression\"]\n});","\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _index = require(\"./index\");\n\nvar _index2 = _interopRequireDefault(_index);\n\n_index2[\"default\"](\"AwaitExpression\", {\n  builder: [\"argument\", \"all\"],\n  visitor: [\"argument\"],\n  aliases: [\"Expression\", \"Terminatorless\"]\n});\n\n_index2[\"default\"](\"BindExpression\", {\n  visitor: [\"object\", \"callee\"]\n});\n\n_index2[\"default\"](\"ComprehensionBlock\", {\n  visitor: [\"left\", \"right\"]\n});\n\n_index2[\"default\"](\"ComprehensionExpression\", {\n  visitor: [\"filter\", \"blocks\", \"body\"],\n  aliases: [\"Expression\", \"Scopable\"]\n});\n\n_index2[\"default\"](\"Decorator\", {\n  visitor: [\"expression\"]\n});\n\n_index2[\"default\"](\"DoExpression\", {\n  visitor: [\"body\"],\n  aliases: [\"Expression\"]\n});\n\n_index2[\"default\"](\"SpreadProperty\", {\n  visitor: [\"argument\"],\n  aliases: [\"UnaryLike\"]\n});","\n\nexports.__esModule = true;\nexports.getBindingIdentifiers = getBindingIdentifiers;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _index = require(\"./index\");\n\nvar t = _interopRequireWildcard(_index);\n\n/**\n * Return a list of binding identifiers associated with the input `node`.\n */\n\nfunction getBindingIdentifiers(node, duplicates) {\n  var search = [].concat(node);\n  var ids = Object.create(null);\n\n  while (search.length) {\n    var id = search.shift();\n    if (!id) continue;\n\n    var keys = t.getBindingIdentifiers.keys[id.type];\n\n    if (t.isIdentifier(id)) {\n      if (duplicates) {\n        var _ids = ids[id.name] = ids[id.name] || [];\n        _ids.push(id);\n      } else {\n        ids[id.name] = id;\n      }\n    } else if (t.isExportDeclaration(id)) {\n      if (t.isDeclaration(node.declaration)) {\n        search.push(node.declaration);\n      }\n    } else if (keys) {\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        if (id[key]) {\n          search = search.concat(id[key]);\n        }\n      }\n    }\n  }\n\n  return ids;\n}\n\n/**\n * Mapping of types to their identifier keys.\n */\n\ngetBindingIdentifiers.keys = {\n  DeclareClass: [\"id\"],\n  DeclareFunction: [\"id\"],\n  DeclareModule: [\"id\"],\n  DeclareVariable: [\"id\"],\n  InterfaceDeclaration: [\"id\"],\n  TypeAlias: [\"id\"],\n\n  ComprehensionExpression: [\"blocks\"],\n  ComprehensionBlock: [\"left\"],\n\n  CatchClause: [\"param\"],\n  LabeledStatement: [\"label\"],\n  UnaryExpression: [\"argument\"],\n  AssignmentExpression: [\"left\"],\n\n  ImportSpecifier: [\"local\"],\n  ImportNamespaceSpecifier: [\"local\"],\n  ImportDefaultSpecifier: [\"local\"],\n  ImportDeclaration: [\"specifiers\"],\n\n  FunctionDeclaration: [\"id\", \"params\"],\n  FunctionExpression: [\"id\", \"params\"],\n\n  ClassDeclaration: [\"id\"],\n  ClassExpression: [\"id\"],\n\n  RestElement: [\"argument\"],\n  UpdateExpression: [\"argument\"],\n\n  SpreadProperty: [\"argument\"],\n  Property: [\"value\"],\n\n  AssignmentPattern: [\"left\"],\n  ArrayPattern: [\"elements\"],\n  ObjectPattern: [\"properties\"],\n\n  VariableDeclaration: [\"declarations\"],\n  VariableDeclarator: [\"id\"]\n};","\n\nexports.__esModule = true;\nexports.isBinding = isBinding;\nexports.isReferenced = isReferenced;\nexports.isValidIdentifier = isValidIdentifier;\nexports.isLet = isLet;\nexports.isBlockScoped = isBlockScoped;\nexports.isVar = isVar;\nexports.isSpecifierDefault = isSpecifierDefault;\nexports.isScope = isScope;\nexports.isImmutable = isImmutable;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _retrievers = require(\"./retrievers\");\n\nvar _esutils = require(\"esutils\");\n\nvar _esutils2 = _interopRequireDefault(_esutils);\n\nvar _index = require(\"./index\");\n\nvar t = _interopRequireWildcard(_index);\n\n/**\n * Check if the input `node` is a binding identifier.\n */\n\nfunction isBinding(node, parent) {\n  var keys = _retrievers.getBindingIdentifiers.keys[parent.type];\n  if (keys) {\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n      var val = parent[key];\n      if (Array.isArray(val)) {\n        if (val.indexOf(node) >= 0) return true;\n      } else {\n        if (val === node) return true;\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * Check if the input `node` is a reference to a bound variable.\n */\n\nfunction isReferenced(node, parent) {\n  switch (parent.type) {\n    // yes: PARENT[NODE]\n    // yes: NODE.child\n    // no: parent.NODE\n    case \"MemberExpression\":\n    case \"JSXMemberExpression\":\n      if (parent.property === node && parent.computed) {\n        return true;\n      } else if (parent.object === node) {\n        return true;\n      } else {\n        return false;\n      }\n\n    // no: new.NODE\n    // no: NODE.target\n    case \"MetaProperty\":\n      return false;\n\n    // yes: { [NODE]: \"\" }\n    // yes: { NODE }\n    // no: { NODE: \"\" }\n    case \"Property\":\n      if (parent.key === node) {\n        return parent.computed;\n      }\n\n    // no: var NODE = init;\n    // yes: var id = NODE;\n    case \"VariableDeclarator\":\n      return parent.id !== node;\n\n    // no: function NODE() {}\n    // no: function foo(NODE) {}\n    case \"ArrowFunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"FunctionExpression\":\n      var _arr = parent.params;\n\n      for (var _i = 0; _i < _arr.length; _i++) {\n        var param = _arr[_i];\n        if (param === node) return false;\n      }\n\n      return parent.id !== node;\n\n    // no: export { foo as NODE };\n    // yes: export { NODE as foo };\n    // no: export { NODE as foo } from \"foo\";\n    case \"ExportSpecifier\":\n      if (parent.source) {\n        return false;\n      } else {\n        return parent.local === node;\n      }\n\n    // no: <div NODE=\"foo\" />\n    case \"JSXAttribute\":\n      return parent.name !== node;\n\n    // no: class { NODE = value; }\n    // yes: class { key = NODE; }\n    case \"ClassProperty\":\n      return parent.value === node;\n\n    // no: import NODE from \"foo\";\n    // no: import * as NODE from \"foo\";\n    // no: import { NODE as foo } from \"foo\";\n    // no: import { foo as NODE } from \"foo\";\n    // no: import NODE from \"bar\";\n    case \"ImportDefaultSpecifier\":\n    case \"ImportNamespaceSpecifier\":\n    case \"ImportSpecifier\":\n      return false;\n\n    // no: class NODE {}\n    case \"ClassDeclaration\":\n    case \"ClassExpression\":\n      return parent.id !== node;\n\n    // yes: class { [NODE](){} }\n    case \"MethodDefinition\":\n      return parent.key === node && parent.computed;\n\n    // no: NODE: for (;;) {}\n    case \"LabeledStatement\":\n      return false;\n\n    // no: try {} catch (NODE) {}\n    case \"CatchClause\":\n      return parent.param !== node;\n\n    // no: function foo(...NODE) {}\n    case \"RestElement\":\n      return false;\n\n    // yes: left = NODE;\n    // no: NODE = right;\n    case \"AssignmentExpression\":\n      return parent.right === node;\n\n    // no: [NODE = foo] = [];\n    // yes: [foo = NODE] = [];\n    case \"AssignmentPattern\":\n      return parent.right === node;\n\n    // no: [NODE] = [];\n    // no: ({ NODE }) = [];\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n      return false;\n  }\n\n  return true;\n}\n\n/**\n * Check if the input `name` is a valid identifier name\n * and isn't a reserved word.\n */\n\nfunction isValidIdentifier(name) {\n  if (typeof name !== \"string\" || _esutils2[\"default\"].keyword.isReservedWordES6(name, true)) {\n    return false;\n  } else {\n    return _esutils2[\"default\"].keyword.isIdentifierNameES6(name);\n  }\n}\n\n/**\n * Check if the input `node` is a `let` variable declaration.\n */\n\nfunction isLet(node) {\n  return t.isVariableDeclaration(node) && (node.kind !== \"var\" || node._let);\n}\n\n/**\n * Check if the input `node` is block scoped.\n */\n\nfunction isBlockScoped(node) {\n  return t.isFunctionDeclaration(node) || t.isClassDeclaration(node) || t.isLet(node);\n}\n\n/**\n * Check if the input `node` is a variable declaration.\n */\n\nfunction isVar(node) {\n  return t.isVariableDeclaration(node, { kind: \"var\" }) && !node._let;\n}\n\n/**\n * Check if the input `specifier` is a `default` import or export.\n */\n\nfunction isSpecifierDefault(specifier) {\n  return t.isImportDefaultSpecifier(specifier) || t.isIdentifier(specifier.imported || specifier.exported, { name: \"default\" });\n}\n\n/**\n * Check if the input `node` is a scope.\n */\n\nfunction isScope(node, parent) {\n  if (t.isBlockStatement(node) && t.isFunction(parent, { body: node })) {\n    return false;\n  }\n\n  return t.isScopable(node);\n}\n\n/**\n * Check if the input `node` is definitely immutable.\n */\n\nfunction isImmutable(node) {\n  if (t.isType(node.type, \"Immutable\")) return true;\n\n  if (t.isLiteral(node)) {\n    if (node.regex) {\n      // regexs are mutable\n      return false;\n    } else {\n      // immutable!\n      return true;\n    }\n  } else if (t.isIdentifier(node)) {\n    if (node.name === \"undefined\") {\n      // immutable!\n      return true;\n    } else {\n      // no idea...\n      return false;\n    }\n  }\n\n  return false;\n}","\n\nexports.__esModule = true;\nexports.toComputedKey = toComputedKey;\nexports.toSequenceExpression = toSequenceExpression;\nexports.toKeyAlias = toKeyAlias;\nexports.toIdentifier = toIdentifier;\nexports.toBindingIdentifierName = toBindingIdentifierName;\nexports.toStatement = toStatement;\nexports.toExpression = toExpression;\nexports.toBlock = toBlock;\nexports.valueToNode = valueToNode;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _lodashLangIsPlainObject = require(\"lodash/lang/isPlainObject\");\n\nvar _lodashLangIsPlainObject2 = _interopRequireDefault(_lodashLangIsPlainObject);\n\nvar _lodashLangIsNumber = require(\"lodash/lang/isNumber\");\n\nvar _lodashLangIsNumber2 = _interopRequireDefault(_lodashLangIsNumber);\n\nvar _lodashLangIsRegExp = require(\"lodash/lang/isRegExp\");\n\nvar _lodashLangIsRegExp2 = _interopRequireDefault(_lodashLangIsRegExp);\n\nvar _lodashLangIsString = require(\"lodash/lang/isString\");\n\nvar _lodashLangIsString2 = _interopRequireDefault(_lodashLangIsString);\n\nvar _traversal = require(\"../traversal\");\n\nvar _traversal2 = _interopRequireDefault(_traversal);\n\nvar _index = require(\"./index\");\n\nvar t = _interopRequireWildcard(_index);\n\n/**\n * [Please add a description.]\n */\n\nfunction toComputedKey(node) {\n  var key = arguments.length <= 1 || arguments[1] === undefined ? node.key || node.property : arguments[1];\n  return (function () {\n    if (!node.computed) {\n      if (t.isIdentifier(key)) key = t.literal(key.name);\n    }\n    return key;\n  })();\n}\n\n/**\n * Turn an array of statement `nodes` into a `SequenceExpression`.\n *\n * Variable declarations are turned into simple assignments and their\n * declarations hoisted to the top of the current scope.\n *\n * Expression statements are just resolved to their expression.\n */\n\nfunction toSequenceExpression(nodes, scope) {\n  var declars = [];\n  var bailed = false;\n\n  var result = convert(nodes);\n  if (bailed) return;\n\n  for (var i = 0; i < declars.length; i++) {\n    scope.push(declars[i]);\n  }\n\n  return result;\n\n  function convert(nodes) {\n    var ensureLastUndefined = false;\n    var exprs = [];\n\n    var _arr = nodes;\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var node = _arr[_i];\n      if (t.isExpression(node)) {\n        exprs.push(node);\n      } else if (t.isExpressionStatement(node)) {\n        exprs.push(node.expression);\n      } else if (t.isVariableDeclaration(node)) {\n        if (node.kind !== \"var\") return bailed = true; // bailed\n\n        var _arr2 = node.declarations;\n        for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n          var declar = _arr2[_i2];\n          var bindings = t.getBindingIdentifiers(declar);\n          for (var key in bindings) {\n            declars.push({\n              kind: node.kind,\n              id: bindings[key]\n            });\n          }\n\n          if (declar.init) {\n            exprs.push(t.assignmentExpression(\"=\", declar.id, declar.init));\n          }\n        }\n\n        ensureLastUndefined = true;\n        continue;\n      } else if (t.isIfStatement(node)) {\n        var consequent = node.consequent ? convert([node.consequent]) : t.identifier(\"undefined\");\n        var alternate = node.alternate ? convert([node.alternate]) : t.identifier(\"undefined\");\n        if (!consequent || !alternate) return bailed = true;\n\n        exprs.push(t.conditionalExpression(node.test, consequent, alternate));\n      } else if (t.isBlockStatement(node)) {\n        exprs.push(convert(node.body));\n      } else if (t.isEmptyStatement(node)) {\n        // empty statement so ensure the last item is undefined if we're last\n        ensureLastUndefined = true;\n        continue;\n      } else {\n        // bailed, we can't turn this statement into an expression\n        return bailed = true;\n      }\n\n      ensureLastUndefined = false;\n    }\n\n    if (ensureLastUndefined) {\n      exprs.push(t.identifier(\"undefined\"));\n    }\n\n    //\n\n    if (exprs.length === 1) {\n      return exprs[0];\n    } else {\n      return t.sequenceExpression(exprs);\n    }\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction toKeyAlias(node) {\n  var key = arguments.length <= 1 || arguments[1] === undefined ? node.key : arguments[1];\n  return (function () {\n    var alias;\n\n    if (node.kind === \"method\") {\n      return toKeyAlias.uid++;\n    } else if (t.isIdentifier(key)) {\n      alias = key.name;\n    } else if (t.isLiteral(key)) {\n      alias = JSON.stringify(key.value);\n    } else {\n      alias = JSON.stringify(_traversal2[\"default\"].removeProperties(t.cloneDeep(key)));\n    }\n\n    if (node.computed) {\n      alias = \"[\" + alias + \"]\";\n    }\n\n    return alias;\n  })();\n}\n\ntoKeyAlias.uid = 0;\n\n/**\n * [Please add a description.]\n */\n\nfunction toIdentifier(name) {\n  if (t.isIdentifier(name)) return name.name;\n\n  name = name + \"\";\n\n  // replace all non-valid identifiers with dashes\n  name = name.replace(/[^a-zA-Z0-9$_]/g, \"-\");\n\n  // remove all dashes and numbers from start of name\n  name = name.replace(/^[-0-9]+/, \"\");\n\n  // camel case\n  name = name.replace(/[-\\s]+(.)?/g, function (match, c) {\n    return c ? c.toUpperCase() : \"\";\n  });\n\n  if (!t.isValidIdentifier(name)) {\n    name = \"_\" + name;\n  }\n\n  return name || \"_\";\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction toBindingIdentifierName(name) {\n  name = toIdentifier(name);\n  if (name === \"eval\" || name === \"arguments\") name = \"_\" + name;\n  return name;\n}\n\n/**\n * [Please add a description.]\n * @returns {Object|Boolean}\n */\n\nfunction toStatement(node, ignore) {\n  if (t.isStatement(node)) {\n    return node;\n  }\n\n  var mustHaveId = false;\n  var newType;\n\n  if (t.isClass(node)) {\n    mustHaveId = true;\n    newType = \"ClassDeclaration\";\n  } else if (t.isFunction(node)) {\n    mustHaveId = true;\n    newType = \"FunctionDeclaration\";\n  } else if (t.isAssignmentExpression(node)) {\n    return t.expressionStatement(node);\n  }\n\n  if (mustHaveId && !node.id) {\n    newType = false;\n  }\n\n  if (!newType) {\n    if (ignore) {\n      return false;\n    } else {\n      throw new Error(\"cannot turn \" + node.type + \" to a statement\");\n    }\n  }\n\n  node.type = newType;\n\n  return node;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction toExpression(node) {\n  if (t.isExpressionStatement(node)) {\n    node = node.expression;\n  }\n\n  if (t.isClass(node)) {\n    node.type = \"ClassExpression\";\n  } else if (t.isFunction(node)) {\n    node.type = \"FunctionExpression\";\n  }\n\n  if (t.isExpression(node)) {\n    return node;\n  } else {\n    throw new Error(\"cannot turn \" + node.type + \" to an expression\");\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction toBlock(node, parent) {\n  if (t.isBlockStatement(node)) {\n    return node;\n  }\n\n  if (t.isEmptyStatement(node)) {\n    node = [];\n  }\n\n  if (!Array.isArray(node)) {\n    if (!t.isStatement(node)) {\n      if (t.isFunction(parent)) {\n        node = t.returnStatement(node);\n      } else {\n        node = t.expressionStatement(node);\n      }\n    }\n\n    node = [node];\n  }\n\n  return t.blockStatement(node);\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction valueToNode(value) {\n  // undefined\n  if (value === undefined) {\n    return t.identifier(\"undefined\");\n  }\n\n  // null, booleans, strings, numbers, regexs\n  if (value === true || value === false || value === null || _lodashLangIsString2[\"default\"](value) || _lodashLangIsNumber2[\"default\"](value) || _lodashLangIsRegExp2[\"default\"](value)) {\n    return t.literal(value);\n  }\n\n  // array\n  if (Array.isArray(value)) {\n    return t.arrayExpression(value.map(t.valueToNode));\n  }\n\n  // object\n  if (_lodashLangIsPlainObject2[\"default\"](value)) {\n    var props = [];\n    for (var key in value) {\n      var nodeKey;\n      if (t.isValidIdentifier(key)) {\n        nodeKey = t.identifier(key);\n      } else {\n        nodeKey = t.literal(key);\n      }\n      props.push(t.property(\"init\", nodeKey, t.valueToNode(value[key])));\n    }\n    return t.objectExpression(props);\n  }\n\n  throw new Error(\"don't know how to turn this value into a node\");\n}","\n\nexports.__esModule = true;\nexports.createUnionTypeAnnotation = createUnionTypeAnnotation;\nexports.removeTypeDuplicates = removeTypeDuplicates;\nexports.createTypeAnnotationBasedOnTypeof = createTypeAnnotationBasedOnTypeof;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _index = require(\"./index\");\n\nvar t = _interopRequireWildcard(_index);\n\n/**\n * Takes an array of `types` and flattens them, removing duplicates and\n * returns a `UnionTypeAnnotation` node containg them.\n */\n\nfunction createUnionTypeAnnotation(types) {\n  var flattened = removeTypeDuplicates(types);\n\n  if (flattened.length === 1) {\n    return flattened[0];\n  } else {\n    return t.unionTypeAnnotation(flattened);\n  }\n}\n\n/**\n * Dedupe type annotations.\n */\n\nfunction removeTypeDuplicates(nodes) {\n  var generics = {};\n  var bases = {};\n\n  // store union type groups to circular references\n  var typeGroups = [];\n\n  var types = [];\n\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    if (!node) continue;\n\n    // detect duplicates\n    if (types.indexOf(node) >= 0) {\n      continue;\n    }\n\n    // this type matches anything\n    if (t.isAnyTypeAnnotation(node)) {\n      return [node];\n    }\n\n    //\n    if (t.isFlowBaseAnnotation(node)) {\n      bases[node.type] = node;\n      continue;\n    }\n\n    //\n    if (t.isUnionTypeAnnotation(node)) {\n      if (typeGroups.indexOf(node.types) < 0) {\n        nodes = nodes.concat(node.types);\n        typeGroups.push(node.types);\n      }\n      continue;\n    }\n\n    // find a matching generic type and merge and deduplicate the type parameters\n    if (t.isGenericTypeAnnotation(node)) {\n      var _name = node.id.name;\n\n      if (generics[_name]) {\n        var existing = generics[_name];\n        if (existing.typeParameters) {\n          if (node.typeParameters) {\n            existing.typeParameters.params = removeTypeDuplicates(existing.typeParameters.params.concat(node.typeParameters.params));\n          }\n        } else {\n          existing = node.typeParameters;\n        }\n      } else {\n        generics[_name] = node;\n      }\n\n      continue;\n    }\n\n    types.push(node);\n  }\n\n  // add back in bases\n  for (var type in bases) {\n    types.push(bases[type]);\n  }\n\n  // add back in generics\n  for (var _name2 in generics) {\n    types.push(generics[_name2]);\n  }\n\n  return types;\n}\n\n/**\n * Create a type anotation based on typeof expression.\n */\n\nfunction createTypeAnnotationBasedOnTypeof(type) {\n  if (type === \"string\") {\n    return t.stringTypeAnnotation();\n  } else if (type === \"number\") {\n    return t.numberTypeAnnotation();\n  } else if (type === \"undefined\") {\n    return t.voidTypeAnnotation();\n  } else if (type === \"boolean\") {\n    return t.booleanTypeAnnotation();\n  } else if (type === \"function\") {\n    return t.genericTypeAnnotation(t.identifier(\"Function\"));\n  } else if (type === \"object\") {\n    return t.genericTypeAnnotation(t.identifier(\"Object\"));\n  } else if (type === \"symbol\") {\n    return t.genericTypeAnnotation(t.identifier(\"Symbol\"));\n  } else {\n    throw new Error(\"Invalid typeof value\");\n  }\n}","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// istanbul ignore next\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _lodashCollectionIncludes = require(\"lodash/collection/includes\");\n\nvar _lodashCollectionIncludes2 = _interopRequireDefault(_lodashCollectionIncludes);\n\nvar _repeating = require(\"repeating\");\n\nvar _repeating2 = _interopRequireDefault(_repeating);\n\nvar _index = require(\"../index\");\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _lodashObjectDefaults = require(\"lodash/object/defaults\");\n\nvar _lodashObjectDefaults2 = _interopRequireDefault(_lodashObjectDefaults);\n\nvar _messages = require(\"../../messages\");\n\nvar messages = _interopRequireWildcard(_messages);\n\nvar _binding = require(\"./binding\");\n\nvar _binding2 = _interopRequireDefault(_binding);\n\nvar _globals = require(\"globals\");\n\nvar _globals2 = _interopRequireDefault(_globals);\n\nvar _lodashArrayFlatten = require(\"lodash/array/flatten\");\n\nvar _lodashArrayFlatten2 = _interopRequireDefault(_lodashArrayFlatten);\n\nvar _lodashObjectExtend = require(\"lodash/object/extend\");\n\nvar _lodashObjectExtend2 = _interopRequireDefault(_lodashObjectExtend);\n\nvar _helpersObject = require(\"../../helpers/object\");\n\nvar _helpersObject2 = _interopRequireDefault(_helpersObject);\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\nvar collectorVisitor = {\n  For: function For() {\n    var _arr = t.FOR_INIT_KEYS;\n\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var key = _arr[_i];\n      var declar = this.get(key);\n      if (declar.isVar()) this.scope.getFunctionParent().registerBinding(\"var\", declar);\n    }\n  },\n\n  Declaration: function Declaration() {\n    // delegate block scope handling to the `blockVariableVisitor`\n    if (this.isBlockScoped()) return;\n\n    // this will be hit again once we traverse into it after this iteration\n    if (this.isExportDeclaration() && this.get(\"declaration\").isDeclaration()) return;\n\n    // we've ran into a declaration!\n    this.scope.getFunctionParent().registerDeclaration(this);\n  },\n\n  ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope, state) {\n    state.references.push(this);\n  },\n\n  ForXStatement: function ForXStatement(node, parent, scope, state) {\n    var left = this.get(\"left\");\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(left);\n    }\n  },\n\n  ExportDeclaration: {\n    exit: function exit(node, parent, scope) {\n      var declar = node.declaration;\n      if (t.isClassDeclaration(declar) || t.isFunctionDeclaration(declar)) {\n        var binding = scope.getBinding(declar.id.name);\n        if (binding) binding.reference();\n      } else if (t.isVariableDeclaration(declar)) {\n        var _arr2 = declar.declarations;\n\n        for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n          var decl = _arr2[_i2];\n          var ids = t.getBindingIdentifiers(decl);\n          for (var _name in ids) {\n            var binding = scope.getBinding(_name);\n            if (binding) binding.reference();\n          }\n        }\n      }\n    }\n  },\n\n  LabeledStatement: function LabeledStatement() {\n    this.scope.getProgramParent().addGlobal(this.node);\n    this.scope.getBlockParent().registerDeclaration(this);\n  },\n\n  AssignmentExpression: function AssignmentExpression(node, parent, scope, state) {\n    state.assignments.push(this);\n  },\n\n  UpdateExpression: function UpdateExpression(node, parent, scope, state) {\n    state.constantViolations.push(this.get(\"argument\"));\n  },\n\n  UnaryExpression: function UnaryExpression(node, parent, scope, state) {\n    if (this.node.operator === \"delete\") {\n      state.constantViolations.push(this.get(\"argument\"));\n    }\n  },\n\n  BlockScoped: function BlockScoped() {\n    var scope = this.scope;\n    if (scope.path === this) scope = scope.parent;\n    scope.getBlockParent().registerDeclaration(this);\n  },\n\n  ClassDeclaration: function ClassDeclaration() {\n    var name = this.node.id.name;\n    this.scope.bindings[name] = this.scope.getBinding(name);\n  },\n\n  Block: function Block() {\n    var paths = this.get(\"body\");\n    var _arr3 = paths;\n    for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n      var bodyPath = _arr3[_i3];\n      if (bodyPath.isFunctionDeclaration()) {\n        this.scope.getBlockParent().registerDeclaration(bodyPath);\n      }\n    }\n  }\n};\n\n/**\n * [Please add a description.]\n */\n\nvar renameVisitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope, state) {\n    if (node.name === state.oldName) {\n      node.name = state.newName;\n    }\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  Scope: function Scope(node, parent, scope, state) {\n    if (!scope.bindingIdentifierEquals(state.oldName, state.binding)) {\n      this.skip();\n    }\n  },\n\n  \"AssignmentExpression|Declaration\": function AssignmentExpressionDeclaration(node, parent, scope, state) {\n    var ids = this.getBindingIdentifiers();\n\n    for (var name in ids) {\n      if (name === state.oldName) ids[name].name = state.newName;\n    }\n  }\n};\n\n/**\n * [Please add a description.]\n */\n\nvar Scope = (function () {\n\n  /**\n   * This searches the current \"scope\" and collects all references/bindings\n   * within.\n   */\n\n  function Scope(path, parent) {\n    _classCallCheck(this, Scope);\n\n    if (parent && parent.block === path.node) {\n      return parent;\n    }\n\n    var cached = path.getData(\"scope\");\n    if (cached && cached.parent === parent && cached.block === path.node) {\n      return cached;\n    } else {\n      path.setData(\"scope\", this);\n    }\n\n    this.parent = parent;\n    this.hub = path.hub;\n\n    this.parentBlock = path.parent;\n    this.block = path.node;\n    this.path = path;\n  }\n\n  /**\n   * Globals.\n   */\n\n  /**\n   * Traverse node with current scope and path.\n   */\n\n  Scope.prototype.traverse = function traverse(node, opts, state) {\n    _index2[\"default\"](node, opts, this, state, this.path);\n  };\n\n  /**\n   * Generate a unique identifier and add it to the current scope.\n   */\n\n  Scope.prototype.generateDeclaredUidIdentifier = function generateDeclaredUidIdentifier() {\n    var name = arguments.length <= 0 || arguments[0] === undefined ? \"temp\" : arguments[0];\n\n    var id = this.generateUidIdentifier(name);\n    this.push({ id: id });\n    return id;\n  };\n\n  /**\n   * Generate a unique identifier.\n   */\n\n  Scope.prototype.generateUidIdentifier = function generateUidIdentifier(name) {\n    return t.identifier(this.generateUid(name));\n  };\n\n  /**\n   * Generate a unique `_id1` binding.\n   */\n\n  Scope.prototype.generateUid = function generateUid(name) {\n    name = t.toIdentifier(name).replace(/^_+/, \"\");\n\n    var uid;\n    var i = 0;\n    do {\n      uid = this._generateUid(name, i);\n      i++;\n    } while (this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));\n\n    var program = this.getProgramParent();\n    program.references[uid] = true;\n    program.uids[uid] = true;\n\n    return uid;\n  };\n\n  /**\n   * Generate an `_id1`.\n   */\n\n  Scope.prototype._generateUid = function _generateUid(name, i) {\n    var id = name;\n    if (i > 1) id += i;\n    return \"_\" + id;\n  };\n\n  /**\n   * Generate a unique identifier based on a node.\n   */\n\n  Scope.prototype.generateUidIdentifierBasedOnNode = function generateUidIdentifierBasedOnNode(parent, defaultName) {\n    var node = parent;\n\n    if (t.isAssignmentExpression(parent)) {\n      node = parent.left;\n    } else if (t.isVariableDeclarator(parent)) {\n      node = parent.id;\n    } else if (t.isProperty(node)) {\n      node = node.key;\n    }\n\n    var parts = [];\n\n    var add = function add(node) {\n      if (t.isModuleDeclaration(node)) {\n        if (node.source) {\n          add(node.source);\n        } else if (node.specifiers && node.specifiers.length) {\n          var _arr4 = node.specifiers;\n\n          for (var _i4 = 0; _i4 < _arr4.length; _i4++) {\n            var specifier = _arr4[_i4];\n            add(specifier);\n          }\n        } else if (node.declaration) {\n          add(node.declaration);\n        }\n      } else if (t.isModuleSpecifier(node)) {\n        add(node.local);\n      } else if (t.isMemberExpression(node)) {\n        add(node.object);\n        add(node.property);\n      } else if (t.isIdentifier(node)) {\n        parts.push(node.name);\n      } else if (t.isLiteral(node)) {\n        parts.push(node.value);\n      } else if (t.isCallExpression(node)) {\n        add(node.callee);\n      } else if (t.isObjectExpression(node) || t.isObjectPattern(node)) {\n        var _arr5 = node.properties;\n\n        for (var _i5 = 0; _i5 < _arr5.length; _i5++) {\n          var prop = _arr5[_i5];\n          add(prop.key || prop.argument);\n        }\n      }\n    };\n\n    add(node);\n\n    var id = parts.join(\"$\");\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n\n    return this.generateUidIdentifier(id);\n  };\n\n  /**\n   * Determine whether evaluating the specific input `node` is a consequenceless reference. ie.\n   * evaluating it wont result in potentially arbitrary code from being ran. The following are\n   * whitelisted and determined not to cause side effects:\n   *\n   *  - `this` expressions\n   *  - `super` expressions\n   *  - Bound identifiers\n   */\n\n  Scope.prototype.isStatic = function isStatic(node) {\n    if (t.isThisExpression(node) || t.isSuper(node)) {\n      return true;\n    }\n\n    if (t.isIdentifier(node)) {\n      var binding = this.getBinding(node.name);\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n\n    return false;\n  };\n\n  /**\n   * Possibly generate a memoised identifier if it is not static and has consequences.\n   */\n\n  Scope.prototype.maybeGenerateMemoised = function maybeGenerateMemoised(node, dontPush) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      var id = this.generateUidIdentifierBasedOnNode(node);\n      if (!dontPush) this.push({ id: id });\n      return id;\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Scope.prototype.checkBlockScopedCollisions = function checkBlockScopedCollisions(local, kind, name, id) {\n    // ignore parameters\n    if (kind === \"param\") return;\n\n    // ignore hoisted functions if there's also a local let\n    if (kind === \"hoisted\" && local.kind === \"let\") return;\n\n    var duplicate = false;\n\n    // don't allow duplicate bindings to exist alongside\n    if (!duplicate) duplicate = kind === \"let\" || local.kind === \"let\" || local.kind === \"const\" || local.kind === \"module\";\n\n    // don't allow a local of param with a kind of let\n    if (!duplicate) duplicate = local.kind === \"param\" && (kind === \"let\" || kind === \"const\");\n\n    if (duplicate) {\n      throw this.hub.file.errorWithNode(id, messages.get(\"scopeDuplicateDeclaration\", name), TypeError);\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Scope.prototype.rename = function rename(oldName, newName, block) {\n    newName = newName || this.generateUidIdentifier(oldName).name;\n\n    var info = this.getBinding(oldName);\n    if (!info) return;\n\n    var state = {\n      newName: newName,\n      oldName: oldName,\n      binding: info.identifier,\n      info: info\n    };\n\n    var scope = info.scope;\n    scope.traverse(block || scope.block, renameVisitor, state);\n\n    if (!block) {\n      scope.removeOwnBinding(oldName);\n      scope.bindings[newName] = info;\n      state.binding.name = newName;\n    }\n\n    var file = this.hub.file;\n    if (file) {\n      this._renameFromMap(file.moduleFormatter.localImports, oldName, newName, state.binding);\n      //this._renameFromMap(file.moduleFormatter.localExports, oldName, newName);\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Scope.prototype._renameFromMap = function _renameFromMap(map, oldName, newName, value) {\n    if (map[oldName]) {\n      map[newName] = value;\n      map[oldName] = null;\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Scope.prototype.dump = function dump() {\n    var sep = _repeating2[\"default\"](\"-\", 60);\n    console.log(sep);\n    var scope = this;\n    do {\n      console.log(\"#\", scope.block.type);\n      for (var name in scope.bindings) {\n        var binding = scope.bindings[name];\n        console.log(\" -\", name, {\n          constant: binding.constant,\n          references: binding.references,\n          kind: binding.kind\n        });\n      }\n    } while (scope = scope.parent);\n    console.log(sep);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Scope.prototype.toArray = function toArray(node, i) {\n    var file = this.hub.file;\n\n    if (t.isIdentifier(node)) {\n      var binding = this.getBinding(node.name);\n      if (binding && binding.constant && binding.path.isGenericType(\"Array\")) return node;\n    }\n\n    if (t.isArrayExpression(node)) {\n      return node;\n    }\n\n    if (t.isIdentifier(node, { name: \"arguments\" })) {\n      return t.callExpression(t.memberExpression(file.addHelper(\"slice\"), t.identifier(\"call\")), [node]);\n    }\n\n    var helperName = \"to-array\";\n    var args = [node];\n    if (i === true) {\n      helperName = \"to-consumable-array\";\n    } else if (i) {\n      args.push(t.literal(i));\n      helperName = \"sliced-to-array\";\n      if (this.hub.file.isLoose(\"es6.forOf\")) helperName += \"-loose\";\n    }\n    return t.callExpression(file.addHelper(helperName), args);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Scope.prototype.registerDeclaration = function registerDeclaration(path) {\n    if (path.isLabeledStatement()) {\n      this.registerBinding(\"label\", path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n    } else if (path.isVariableDeclaration()) {\n      var declarations = path.get(\"declarations\");\n      var _arr6 = declarations;\n      for (var _i6 = 0; _i6 < _arr6.length; _i6++) {\n        var declar = _arr6[_i6];\n        this.registerBinding(path.node.kind, declar);\n      }\n    } else if (path.isClassDeclaration()) {\n      this.registerBinding(\"let\", path);\n    } else if (path.isImportDeclaration()) {\n      var specifiers = path.get(\"specifiers\");\n      var _arr7 = specifiers;\n      for (var _i7 = 0; _i7 < _arr7.length; _i7++) {\n        var specifier = _arr7[_i7];\n        this.registerBinding(\"module\", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      var declar = path.get(\"declaration\");\n      if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {\n        this.registerDeclaration(declar);\n      }\n    } else {\n      this.registerBinding(\"unknown\", path);\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Scope.prototype.registerConstantViolation = function registerConstantViolation(path) {\n    var ids = path.getBindingIdentifiers();\n    for (var _name2 in ids) {\n      var binding = this.getBinding(_name2);\n      if (binding) binding.reassign(path);\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Scope.prototype.registerBinding = function registerBinding(kind, path) {\n    var bindingPath = arguments.length <= 2 || arguments[2] === undefined ? path : arguments[2];\n    return (function () {\n      if (!kind) throw new ReferenceError(\"no `kind`\");\n\n      if (path.isVariableDeclaration()) {\n        var declarators = path.get(\"declarations\");\n        var _arr8 = declarators;\n        for (var _i8 = 0; _i8 < _arr8.length; _i8++) {\n          var declar = _arr8[_i8];\n          this.registerBinding(kind, declar);\n        }\n        return;\n      }\n\n      var parent = this.getProgramParent();\n      var ids = path.getBindingIdentifiers(true);\n\n      for (var name in ids) {\n        var _arr9 = ids[name];\n\n        for (var _i9 = 0; _i9 < _arr9.length; _i9++) {\n          var id = _arr9[_i9];\n          var local = this.getOwnBinding(name);\n          if (local) {\n            // same identifier so continue safely as we're likely trying to register it\n            // multiple times\n            if (local.identifier === id) continue;\n\n            this.checkBlockScopedCollisions(local, kind, name, id);\n          }\n\n          parent.references[name] = true;\n\n          this.bindings[name] = new _binding2[\"default\"]({\n            identifier: id,\n            existing: local,\n            scope: this,\n            path: bindingPath,\n            kind: kind\n          });\n        }\n      }\n    }).apply(this, arguments);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Scope.prototype.addGlobal = function addGlobal(node) {\n    this.globals[node.name] = node;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Scope.prototype.hasUid = function hasUid(name) {\n    var scope = this;\n\n    do {\n      if (scope.uids[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Scope.prototype.hasGlobal = function hasGlobal(name) {\n    var scope = this;\n\n    do {\n      if (scope.globals[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Scope.prototype.hasReference = function hasReference(name) {\n    var scope = this;\n\n    do {\n      if (scope.references[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Scope.prototype.isPure = function isPure(node, constantsOnly) {\n    if (t.isIdentifier(node)) {\n      var binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (t.isClass(node)) {\n      return !node.superClass || this.isPure(node.superClass, constantsOnly);\n    } else if (t.isBinary(node)) {\n      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);\n    } else if (t.isArrayExpression(node)) {\n      var _arr10 = node.elements;\n\n      for (var _i10 = 0; _i10 < _arr10.length; _i10++) {\n        var elem = _arr10[_i10];\n        if (!this.isPure(elem, constantsOnly)) return false;\n      }\n      return true;\n    } else if (t.isObjectExpression(node)) {\n      var _arr11 = node.properties;\n\n      for (var _i11 = 0; _i11 < _arr11.length; _i11++) {\n        var prop = _arr11[_i11];\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n      return true;\n    } else if (t.isProperty(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      return this.isPure(node.value, constantsOnly);\n    } else {\n      return t.isPure(node);\n    }\n  };\n\n  /**\n   * Set some arbitrary data on the current scope.\n   */\n\n  Scope.prototype.setData = function setData(key, val) {\n    return this.data[key] = val;\n  };\n\n  /**\n   * Recursively walk up scope tree looking for the data `key`.\n   */\n\n  Scope.prototype.getData = function getData(key) {\n    var scope = this;\n    do {\n      var data = scope.data[key];\n      if (data != null) return data;\n    } while (scope = scope.parent);\n  };\n\n  /**\n   * Recursively walk up scope tree looking for the data `key` and if it exists,\n   * remove it.\n   */\n\n  Scope.prototype.removeData = function removeData(key) {\n    var scope = this;\n    do {\n      var data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while (scope = scope.parent);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Scope.prototype.init = function init() {\n    if (!this.references) this.crawl();\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Scope.prototype.crawl = function crawl() {\n    var path = this.path;\n\n    //\n\n    var info = this.block._scopeInfo;\n    if (info) return _lodashObjectExtend2[\"default\"](this, info);\n\n    info = this.block._scopeInfo = {\n      references: _helpersObject2[\"default\"](),\n      bindings: _helpersObject2[\"default\"](),\n      globals: _helpersObject2[\"default\"](),\n      uids: _helpersObject2[\"default\"](),\n      data: _helpersObject2[\"default\"]()\n    };\n\n    _lodashObjectExtend2[\"default\"](this, info);\n\n    // ForStatement - left, init\n\n    if (path.isLoop()) {\n      var _arr12 = t.FOR_INIT_KEYS;\n\n      for (var _i12 = 0; _i12 < _arr12.length; _i12++) {\n        var key = _arr12[_i12];\n        var node = path.get(key);\n        if (node.isBlockScoped()) this.registerBinding(node.node.kind, node);\n      }\n    }\n\n    // FunctionExpression - id\n\n    if (path.isFunctionExpression() && path.has(\"id\")) {\n      this.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n\n    // Class\n\n    if (path.isClassExpression() && path.has(\"id\")) {\n      this.registerBinding(\"local\", path);\n    }\n\n    // Function - params, rest\n\n    if (path.isFunction()) {\n      var params = path.get(\"params\");\n      var _arr13 = params;\n      for (var _i13 = 0; _i13 < _arr13.length; _i13++) {\n        var param = _arr13[_i13];\n        this.registerBinding(\"param\", param);\n      }\n    }\n\n    // CatchClause - param\n\n    if (path.isCatchClause()) {\n      this.registerBinding(\"let\", path);\n    }\n\n    // ComprehensionExpression - blocks\n\n    if (path.isComprehensionExpression()) {\n      this.registerBinding(\"let\", path);\n    }\n\n    // Program\n\n    var parent = this.getProgramParent();\n    if (parent.crawling) return;\n\n    var state = {\n      references: [],\n      constantViolations: [],\n      assignments: []\n    };\n\n    this.crawling = true;\n    path.traverse(collectorVisitor, state);\n    this.crawling = false;\n\n    // register assignments\n    for (var _iterator = state.assignments, _isArray = Array.isArray(_iterator), _i14 = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i14 >= _iterator.length) break;\n        _ref = _iterator[_i14++];\n      } else {\n        _i14 = _iterator.next();\n        if (_i14.done) break;\n        _ref = _i14.value;\n      }\n\n      var _path = _ref;\n\n      // register undeclared bindings as globals\n      var ids = _path.getBindingIdentifiers();\n      var programParent = undefined;\n      for (var _name3 in ids) {\n        if (_path.scope.getBinding(_name3)) continue;\n\n        programParent = programParent || _path.scope.getProgramParent();\n        programParent.addGlobal(ids[_name3]);\n      }\n\n      // register as constant violation\n      _path.scope.registerConstantViolation(_path);\n    }\n\n    // register references\n    for (var _iterator2 = state.references, _isArray2 = Array.isArray(_iterator2), _i15 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i15 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i15++];\n      } else {\n        _i15 = _iterator2.next();\n        if (_i15.done) break;\n        _ref2 = _i15.value;\n      }\n\n      var ref = _ref2;\n\n      var binding = ref.scope.getBinding(ref.node.name);\n      if (binding) {\n        binding.reference(ref);\n      } else {\n        ref.scope.getProgramParent().addGlobal(ref.node);\n      }\n    }\n\n    // register constant violations\n    for (var _iterator3 = state.constantViolations, _isArray3 = Array.isArray(_iterator3), _i16 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {\n      var _ref3;\n\n      if (_isArray3) {\n        if (_i16 >= _iterator3.length) break;\n        _ref3 = _iterator3[_i16++];\n      } else {\n        _i16 = _iterator3.next();\n        if (_i16.done) break;\n        _ref3 = _i16.value;\n      }\n\n      var _path2 = _ref3;\n\n      _path2.scope.registerConstantViolation(_path2);\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Scope.prototype.push = function push(opts) {\n    var path = this.path;\n\n    if (path.isSwitchStatement()) {\n      path = this.getFunctionParent().path;\n    }\n\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      t.ensureBlock(path.node);\n      path = path.get(\"body\");\n    }\n\n    if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n\n    var unique = opts.unique;\n    var kind = opts.kind || \"var\";\n    var blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n\n    var dataKey = \"declaration:\" + kind + \":\" + blockHoist;\n    var declarPath = !unique && path.getData(dataKey);\n\n    if (!declarPath) {\n      var declar = t.variableDeclaration(kind, []);\n      declar._generated = true;\n      declar._blockHoist = blockHoist;\n\n      this.hub.file.attachAuxiliaryComment(declar);\n\n      var _path$unshiftContainer = path.unshiftContainer(\"body\", [declar]);\n\n      declarPath = _path$unshiftContainer[0];\n\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n\n    var declarator = t.variableDeclarator(opts.id, opts.init);\n    declarPath.node.declarations.push(declarator);\n    this.registerBinding(kind, declarPath.get(\"declarations\").pop());\n  };\n\n  /**\n   * Walk up to the top of the scope tree and get the `Program`.\n   */\n\n  Scope.prototype.getProgramParent = function getProgramParent() {\n    var scope = this;\n    do {\n      if (scope.path.isProgram()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n    throw new Error(\"We couldn't find a Function or Program...\");\n  };\n\n  /**\n   * Walk up the scope tree until we hit either a Function or reach the\n   * very top and hit Program.\n   */\n\n  Scope.prototype.getFunctionParent = function getFunctionParent() {\n    var scope = this;\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n    throw new Error(\"We couldn't find a Function or Program...\");\n  };\n\n  /**\n   * Walk up the scope tree until we hit either a BlockStatement/Loop/Program/Function/Switch or reach the\n   * very top and hit Program.\n   */\n\n  Scope.prototype.getBlockParent = function getBlockParent() {\n    var scope = this;\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n    throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n  };\n\n  /**\n   * Walks the scope tree and gathers **all** bindings.\n   */\n\n  Scope.prototype.getAllBindings = function getAllBindings() {\n    var ids = _helpersObject2[\"default\"]();\n\n    var scope = this;\n    do {\n      _lodashObjectDefaults2[\"default\"](ids, scope.bindings);\n      scope = scope.parent;\n    } while (scope);\n\n    return ids;\n  };\n\n  /**\n   * Walks the scope tree and gathers all declarations of `kind`.\n   */\n\n  Scope.prototype.getAllBindingsOfKind = function getAllBindingsOfKind() {\n    var ids = _helpersObject2[\"default\"]();\n\n    var _arr14 = arguments;\n    for (var _i17 = 0; _i17 < _arr14.length; _i17++) {\n      var kind = _arr14[_i17];\n      var scope = this;\n      do {\n        for (var name in scope.bindings) {\n          var binding = scope.bindings[name];\n          if (binding.kind === kind) ids[name] = binding;\n        }\n        scope = scope.parent;\n      } while (scope);\n    }\n\n    return ids;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Scope.prototype.bindingIdentifierEquals = function bindingIdentifierEquals(name, node) {\n    return this.getBindingIdentifier(name) === node;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Scope.prototype.getBinding = function getBinding(name) {\n    var scope = this;\n\n    do {\n      var binding = scope.getOwnBinding(name);\n      if (binding) return binding;\n    } while (scope = scope.parent);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Scope.prototype.getOwnBinding = function getOwnBinding(name) {\n    return this.bindings[name];\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Scope.prototype.getBindingIdentifier = function getBindingIdentifier(name) {\n    var info = this.getBinding(name);\n    return info && info.identifier;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Scope.prototype.getOwnBindingIdentifier = function getOwnBindingIdentifier(name) {\n    var binding = this.bindings[name];\n    return binding && binding.identifier;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Scope.prototype.hasOwnBinding = function hasOwnBinding(name) {\n    return !!this.getOwnBinding(name);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Scope.prototype.hasBinding = function hasBinding(name, noGlobals) {\n    if (!name) return false;\n    if (this.hasOwnBinding(name)) return true;\n    if (this.parentHasBinding(name, noGlobals)) return true;\n    if (this.hasUid(name)) return true;\n    if (!noGlobals && _lodashCollectionIncludes2[\"default\"](Scope.globals, name)) return true;\n    if (!noGlobals && _lodashCollectionIncludes2[\"default\"](Scope.contextVariables, name)) return true;\n    return false;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Scope.prototype.parentHasBinding = function parentHasBinding(name, noGlobals) {\n    return this.parent && this.parent.hasBinding(name, noGlobals);\n  };\n\n  /**\n   * Move a binding of `name` to another `scope`.\n   */\n\n  Scope.prototype.moveBindingTo = function moveBindingTo(name, scope) {\n    var info = this.getBinding(name);\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Scope.prototype.removeOwnBinding = function removeOwnBinding(name) {\n    delete this.bindings[name];\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Scope.prototype.removeBinding = function removeBinding(name) {\n    // clear literal binding\n    var info = this.getBinding(name);\n    if (info) {\n      info.scope.removeOwnBinding(name);\n    }\n\n    // clear uids with this name - https://github.com/babel/babel/issues/2101\n    var scope = this;\n    do {\n      if (scope.uids[name]) {\n        scope.uids[name] = false;\n      }\n    } while (scope = scope.parent);\n  };\n\n  _createClass(Scope, null, [{\n    key: \"globals\",\n    value: _lodashArrayFlatten2[\"default\"]([_globals2[\"default\"].builtin, _globals2[\"default\"].browser, _globals2[\"default\"].node].map(Object.keys)),\n\n    /**\n     * Variables available in current context.\n     */\n\n    enumerable: true\n  }, {\n    key: \"contextVariables\",\n    value: [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"],\n    enumerable: true\n  }]);\n\n  return Scope;\n})();\n\nexports[\"default\"] = Scope;\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\nexports.get = get;\nexports.parseArgs = parseArgs;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _util = require(\"util\");\n\nvar util = _interopRequireWildcard(_util);\n\n/**\n * Mapping of messages to be used in Babel.\n * Messages can include $0-style placeholders.\n */\n\nvar MESSAGES = {\n  tailCallReassignmentDeopt: \"Function reference has been reassigned, so it will probably be dereferenced, therefore we can't optimise this with confidence\",\n  JSXNamespacedTags: \"Namespace tags are not supported. ReactJSX is not XML.\",\n  classesIllegalBareSuper: \"Illegal use of bare super\",\n  classesIllegalSuperCall: \"Direct super call is illegal in non-constructor, use super.$1() instead\",\n  scopeDuplicateDeclaration: \"Duplicate declaration $1\",\n  settersNoRest: \"Setters aren't allowed to have a rest\",\n  noAssignmentsInForHead: \"No assignments allowed in for-in/of head\",\n  expectedMemberExpressionOrIdentifier: \"Expected type MemberExpression or Identifier\",\n  invalidParentForThisNode: \"We don't know how to handle this node within the current parent - please open an issue\",\n  readOnly: \"$1 is read-only\",\n  unknownForHead: \"Unknown node type $1 in ForStatement\",\n  didYouMean: \"Did you mean $1?\",\n  codeGeneratorDeopt: \"Note: The code generator has deoptimised the styling of $1 as it exceeds the max of $2.\",\n  missingTemplatesDirectory: \"no templates directory - this is most likely the result of a broken `npm publish`. Please report to https://github.com/babel/babel/issues\",\n  unsupportedOutputType: \"Unsupported output type $1\",\n  illegalMethodName: \"Illegal method name $1\",\n  lostTrackNodePath: \"We lost track of this node's position, likely because the AST was directly manipulated\",\n\n  modulesIllegalExportName: \"Illegal export $1\",\n  modulesDuplicateDeclarations: \"Duplicate module declarations with the same source but in different scopes\",\n\n  undeclaredVariable: \"Reference to undeclared variable $1\",\n  undeclaredVariableType: \"Referencing a type alias outside of a type annotation\",\n  undeclaredVariableSuggestion: \"Reference to undeclared variable $1 - did you mean $2?\",\n\n  traverseNeedsParent: \"You must pass a scope and parentPath unless traversing a Program/File got a $1 node\",\n  traverseVerifyRootFunction: \"You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?\",\n  traverseVerifyVisitorProperty: \"You passed `traverse()` a visitor object with the property $1 that has the invalid property $2\",\n  traverseVerifyNodeType: \"You gave us a visitor for the node type $1 but it's not a valid type\",\n\n  pluginIllegalKind: \"Illegal kind $1 for plugin $2\",\n  pluginIllegalPosition: \"Illegal position $1 for plugin $2\",\n  pluginKeyCollision: \"The plugin $1 collides with another of the same name\",\n  pluginNotTransformer: \"The plugin $1 didn't export a Plugin instance\",\n  pluginUnknown: \"Unknown plugin $1\",\n\n  pluginNotFile: \"Plugin $1 is resolving to a different Babel version than what is performing the transformation.\",\n\n  pluginInvalidProperty: \"Plugin $1 provided an invalid property of $2.\",\n  pluginInvalidPropertyVisitor: \"Define your visitor methods inside a `visitor` property like so:\\n\\n  new Plugin(\\\"foobar\\\", {\\n    visitor: {\\n      // define your visitor methods here!\\n    }\\n  });\\n\"\n};\n\nexports.MESSAGES = MESSAGES;\n/**\n * Get a message with $0 placeholders replaced by arguments.\n */\n\nfunction get(key) {\n  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  var msg = MESSAGES[key];\n  if (!msg) throw new ReferenceError(\"Unknown message \" + JSON.stringify(key));\n\n  // stringify args\n  args = parseArgs(args);\n\n  // replace $0 placeholders with args\n  return msg.replace(/\\$(\\d+)/g, function (str, i) {\n    return args[--i];\n  });\n}\n\n/**\n * Stingify arguments to be used inside messages.\n */\n\nfunction parseArgs(args) {\n  return args.map(function (val) {\n    if (val != null && val.inspect) {\n      return val.inspect();\n    } else {\n      try {\n        return JSON.stringify(val) || val + \"\";\n      } catch (e) {\n        return util.inspect(val);\n      }\n    }\n  });\n}","\n\nexports.__esModule = true;\nexports.canCompile = canCompile;\nexports.list = list;\nexports.regexify = regexify;\nexports.arrayify = arrayify;\nexports.booleanify = booleanify;\nexports.shouldIgnore = shouldIgnore;\nexports.template = template;\nexports.parseTemplate = parseTemplate;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _lodashStringEscapeRegExp = require(\"lodash/string/escapeRegExp\");\n\nvar _lodashStringEscapeRegExp2 = _interopRequireDefault(_lodashStringEscapeRegExp);\n\nvar _lodashStringStartsWith = require(\"lodash/string/startsWith\");\n\nvar _lodashStringStartsWith2 = _interopRequireDefault(_lodashStringStartsWith);\n\nvar _lodashLangCloneDeep = require(\"lodash/lang/cloneDeep\");\n\nvar _lodashLangCloneDeep2 = _interopRequireDefault(_lodashLangCloneDeep);\n\nvar _lodashLangIsBoolean = require(\"lodash/lang/isBoolean\");\n\nvar _lodashLangIsBoolean2 = _interopRequireDefault(_lodashLangIsBoolean);\n\nvar _messages = require(\"./messages\");\n\nvar messages = _interopRequireWildcard(_messages);\n\nvar _minimatch = require(\"minimatch\");\n\nvar _minimatch2 = _interopRequireDefault(_minimatch);\n\nvar _lodashCollectionContains = require(\"lodash/collection/contains\");\n\nvar _lodashCollectionContains2 = _interopRequireDefault(_lodashCollectionContains);\n\nvar _traversal = require(\"./traversal\");\n\nvar _traversal2 = _interopRequireDefault(_traversal);\n\nvar _lodashLangIsString = require(\"lodash/lang/isString\");\n\nvar _lodashLangIsString2 = _interopRequireDefault(_lodashLangIsString);\n\nvar _lodashLangIsRegExp = require(\"lodash/lang/isRegExp\");\n\nvar _lodashLangIsRegExp2 = _interopRequireDefault(_lodashLangIsRegExp);\n\nvar _lodashLangIsEmpty = require(\"lodash/lang/isEmpty\");\n\nvar _lodashLangIsEmpty2 = _interopRequireDefault(_lodashLangIsEmpty);\n\nvar _helpersParse = require(\"./helpers/parse\");\n\nvar _helpersParse2 = _interopRequireDefault(_helpersParse);\n\nvar _path = require(\"path\");\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _lodashObjectHas = require(\"lodash/object/has\");\n\nvar _lodashObjectHas2 = _interopRequireDefault(_lodashObjectHas);\n\nvar _fs = require(\"fs\");\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _types = require(\"./types\");\n\nvar t = _interopRequireWildcard(_types);\n\nvar _slash = require(\"slash\");\n\nvar _slash2 = _interopRequireDefault(_slash);\n\nvar _pathExists = require(\"path-exists\");\n\nvar _pathExists2 = _interopRequireDefault(_pathExists);\n\nvar _util = require(\"util\");\n\nexports.inherits = _util.inherits;\nexports.inspect = _util.inspect;\n\n/**\n * Test if a filename ends with a compilable extension.\n */\n\nfunction canCompile(filename, altExts) {\n  var exts = altExts || canCompile.EXTENSIONS;\n  var ext = _path2[\"default\"].extname(filename);\n  return _lodashCollectionContains2[\"default\"](exts, ext);\n}\n\n/**\n * Default set of compilable extensions.\n */\n\ncanCompile.EXTENSIONS = [\".js\", \".jsx\", \".es6\", \".es\"];\n\n/**\n * Create an array from any value, splitting strings by \",\".\n */\n\nfunction list(val) {\n  if (!val) {\n    return [];\n  } else if (Array.isArray(val)) {\n    return val;\n  } else if (typeof val === \"string\") {\n    return val.split(\",\");\n  } else {\n    return [val];\n  }\n}\n\n/**\n * Create a RegExp from a string, array, or regexp.\n */\n\nfunction regexify(val) {\n  if (!val) return new RegExp(/.^/);\n\n  if (Array.isArray(val)) val = new RegExp(val.map(_lodashStringEscapeRegExp2[\"default\"]).join(\"|\"), \"i\");\n\n  if (_lodashLangIsString2[\"default\"](val)) {\n    // normalise path separators\n    val = _slash2[\"default\"](val);\n\n    // remove starting wildcards or relative separator if present\n    if (_lodashStringStartsWith2[\"default\"](val, \"./\") || _lodashStringStartsWith2[\"default\"](val, \"*/\")) val = val.slice(2);\n    if (_lodashStringStartsWith2[\"default\"](val, \"**/\")) val = val.slice(3);\n\n    var regex = _minimatch2[\"default\"].makeRe(val, { nocase: true });\n    return new RegExp(regex.source.slice(1, -1), \"i\");\n  }\n\n  if (_lodashLangIsRegExp2[\"default\"](val)) return val;\n\n  throw new TypeError(\"illegal type for regexify\");\n}\n\n/**\n * Create an array from a boolean, string, or array, mapped by and optional function.\n */\n\nfunction arrayify(val, mapFn) {\n  if (!val) return [];\n  if (_lodashLangIsBoolean2[\"default\"](val)) return arrayify([val], mapFn);\n  if (_lodashLangIsString2[\"default\"](val)) return arrayify(list(val), mapFn);\n\n  if (Array.isArray(val)) {\n    if (mapFn) val = val.map(mapFn);\n    return val;\n  }\n\n  return [val];\n}\n\n/**\n * Makes boolean-like strings into booleans.\n */\n\nfunction booleanify(val) {\n  if (val === \"true\") return true;\n  if (val === \"false\") return false;\n  return val;\n}\n\n/**\n * Tests if a filename should be ignored based on \"ignore\" and \"only\" options.\n */\n\nfunction shouldIgnore(filename, ignore, only) {\n  filename = _slash2[\"default\"](filename);\n\n  if (only) {\n    var _arr = only;\n\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var pattern = _arr[_i];\n      if (_shouldIgnore(pattern, filename)) return false;\n    }\n    return true;\n  } else if (ignore.length) {\n    var _arr2 = ignore;\n\n    for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n      var pattern = _arr2[_i2];\n      if (_shouldIgnore(pattern, filename)) return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Returns result of calling function with filename if pattern is a function.\n * Otherwise returns result of matching pattern Regex with filename.\n */\n\nfunction _shouldIgnore(pattern, filename) {\n  if (typeof pattern === \"function\") {\n    return pattern(filename);\n  } else {\n    return pattern.test(filename);\n  }\n}\n\n/**\n * A visitor for Babel templates, replaces placeholder references.\n */\n\nvar templateVisitor = {\n\n  /**\n   * 360 NoScope PWNd\n   */\n  noScope: true,\n\n  enter: function enter(node, parent, scope, nodes) {\n    if (t.isExpressionStatement(node)) {\n      node = node.expression;\n    }\n\n    if (t.isIdentifier(node) && _lodashObjectHas2[\"default\"](nodes, node.name)) {\n      this.skip();\n      this.replaceInline(nodes[node.name]);\n    }\n  },\n\n  exit: function exit(node) {\n    _traversal2[\"default\"].clearNode(node);\n  }\n};\n\n/**\n * Create an instance of a template to use in a transformer.\n */\n\nfunction template(name, nodes, keepExpression) {\n  var ast = exports.templates[name];\n  if (!ast) throw new ReferenceError(\"unknown template \" + name);\n\n  if (nodes === true) {\n    keepExpression = true;\n    nodes = null;\n  }\n\n  ast = _lodashLangCloneDeep2[\"default\"](ast);\n\n  if (!_lodashLangIsEmpty2[\"default\"](nodes)) {\n    _traversal2[\"default\"](ast, templateVisitor, null, nodes);\n  }\n\n  if (ast.body.length > 1) return ast.body;\n\n  var node = ast.body[0];\n\n  if (!keepExpression && t.isExpressionStatement(node)) {\n    return node.expression;\n  } else {\n    return node;\n  }\n}\n\n/**\n * Parse a template.\n */\n\nfunction parseTemplate(loc, code) {\n  var ast = _helpersParse2[\"default\"](code, { filename: loc, looseModules: true }).program;\n  ast = _traversal2[\"default\"].removeProperties(ast);\n  return ast;\n}\n\n/**\n * Load templates from transformation/templates directory.\n */\n\nfunction loadTemplates() {\n  var templates = {};\n\n  var templatesLoc = _path2[\"default\"].join(__dirname, \"transformation/templates\");\n  if (!_pathExists2[\"default\"].sync(templatesLoc)) {\n    throw new ReferenceError(messages.get(\"missingTemplatesDirectory\"));\n  }\n\n  var _arr3 = _fs2[\"default\"].readdirSync(templatesLoc);\n\n  for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n    var name = _arr3[_i3];\n    if (name[0] === \".\") return;\n\n    var key = _path2[\"default\"].basename(name, _path2[\"default\"].extname(name));\n    var loc = _path2[\"default\"].join(templatesLoc, name);\n    var code = _fs2[\"default\"].readFileSync(loc, \"utf8\");\n\n    templates[key] = parseTemplate(loc, code);\n  }\n\n  return templates;\n}\n\ntry {\n  exports.templates = require(\"../templates.json\");\n} catch (err) {\n  if (err.code !== \"MODULE_NOT_FOUND\") throw err;\n  exports.templates = loadTemplates();\n}","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _babylon = require(\"babylon\");\n\nvar babylon = _interopRequireWildcard(_babylon);\n\n/**\n * Parse `code` with normalized options, collecting tokens and comments.\n */\n\nexports[\"default\"] = function (code) {\n  var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n  var parseOpts = {\n    allowImportExportEverywhere: opts.looseModules,\n    allowReturnOutsideFunction: opts.looseModules,\n    allowHashBang: true,\n    ecmaVersion: 6,\n    strictMode: opts.strictMode,\n    sourceType: opts.sourceType,\n    locations: true,\n    features: opts.features || {},\n    plugins: opts.plugins || {}\n  };\n\n  if (opts.nonStandard) {\n    parseOpts.plugins.jsx = true;\n    parseOpts.plugins.flow = true;\n  }\n\n  return babylon.parse(code, parseOpts);\n};\n\nmodule.exports = exports[\"default\"];","module.exports = {\"abstract-expression-call\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"PROPERTY\"},\"property\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Symbol\"},\"property\":{\"type\":\"Identifier\",\"name\":\"referenceGet\"},\"computed\":false},\"computed\":true},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"OBJECT\"}]},\"property\":{\"type\":\"Identifier\",\"name\":\"call\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"OBJECT\"}]}}]},\"abstract-expression-delete\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"PROPERTY\"},\"property\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Symbol\"},\"property\":{\"type\":\"Identifier\",\"name\":\"referenceDelete\"},\"computed\":false},\"computed\":true},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"OBJECT\"}]}}]},\"abstract-expression-get\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"PROPERTY\"},\"property\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Symbol\"},\"property\":{\"type\":\"Identifier\",\"name\":\"referenceGet\"},\"computed\":false},\"computed\":true},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"OBJECT\"}]}}]},\"abstract-expression-set\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"PROPERTY\"},\"property\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Symbol\"},\"property\":{\"type\":\"Identifier\",\"name\":\"referenceSet\"},\"computed\":false},\"computed\":true},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"OBJECT\"},{\"type\":\"Identifier\",\"name\":\"VALUE\"}]}}]},\"array-comprehension-container\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"KEY\"},\"init\":{\"type\":\"ArrayExpression\",\"elements\":[]}}],\"kind\":\"var\"},{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"Identifier\",\"name\":\"KEY\"}}]},\"parenthesizedExpression\":true},\"arguments\":[]}}]},\"array-from\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Array\"},\"property\":{\"type\":\"Identifier\",\"name\":\"from\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"VALUE\"}]}}]},\"array-push\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"KEY\"},\"property\":{\"type\":\"Identifier\",\"name\":\"push\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"STATEMENT\"}]}}]},\"call\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"OBJECT\"},\"property\":{\"type\":\"Identifier\",\"name\":\"call\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"CONTEXT\"}]}}]},\"class-decorator\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"Identifier\",\"name\":\"CLASS_REF\"},\"right\":{\"type\":\"LogicalExpression\",\"left\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"DECORATOR\"},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"CLASS_REF\"}]},\"operator\":\"||\",\"right\":{\"type\":\"Identifier\",\"name\":\"CLASS_REF\"}}}}]},\"class-derived-default-constructor\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"Super\"},\"arguments\":[{\"type\":\"SpreadElement\",\"argument\":{\"type\":\"Identifier\",\"name\":\"arguments\"}}]}}]},\"parenthesizedExpression\":true}}]},\"default-parameter-assign\":{\"type\":\"Program\",\"body\":[{\"type\":\"IfStatement\",\"test\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"Identifier\",\"name\":\"VARIABLE_NAME\"},\"operator\":\"===\",\"right\":{\"type\":\"Identifier\",\"name\":\"undefined\"}},\"consequent\":{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"Identifier\",\"name\":\"VARIABLE_NAME\"},\"right\":{\"type\":\"Identifier\",\"name\":\"DEFAULT_VALUE\"}}},\"alternate\":null}]},\"default-parameter\":{\"type\":\"Program\",\"body\":[{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"VARIABLE_NAME\"},\"init\":{\"type\":\"ConditionalExpression\",\"test\":{\"type\":\"LogicalExpression\",\"left\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"ARGUMENTS\"},\"property\":{\"type\":\"Identifier\",\"name\":\"length\"},\"computed\":false},\"operator\":\"<=\",\"right\":{\"type\":\"Identifier\",\"name\":\"ARGUMENT_KEY\"}},\"operator\":\"||\",\"right\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"ARGUMENTS\"},\"property\":{\"type\":\"Identifier\",\"name\":\"ARGUMENT_KEY\"},\"computed\":true},\"operator\":\"===\",\"right\":{\"type\":\"Identifier\",\"name\":\"undefined\"}}},\"consequent\":{\"type\":\"Identifier\",\"name\":\"DEFAULT_VALUE\"},\"alternate\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"ARGUMENTS\"},\"property\":{\"type\":\"Identifier\",\"name\":\"ARGUMENT_KEY\"},\"computed\":true}}}],\"kind\":\"let\"}]},\"exports-assign\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"exports\"},\"property\":{\"type\":\"Identifier\",\"name\":\"KEY\"},\"computed\":false},\"right\":{\"type\":\"Identifier\",\"name\":\"VALUE\"}}}]},\"exports-default-assign\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"module\"},\"property\":{\"type\":\"Identifier\",\"name\":\"exports\"},\"computed\":false},\"right\":{\"type\":\"Identifier\",\"name\":\"VALUE\"}}}]},\"exports-from-assign\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Object\"},\"property\":{\"type\":\"Identifier\",\"name\":\"defineProperty\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"exports\"},{\"type\":\"Identifier\",\"name\":\"ID\"},{\"type\":\"ObjectExpression\",\"properties\":[{\"type\":\"Property\",\"method\":false,\"shorthand\":false,\"computed\":false,\"key\":{\"type\":\"Identifier\",\"name\":\"enumerable\"},\"value\":{\"type\":\"Literal\",\"value\":true},\"kind\":\"init\"},{\"type\":\"Property\",\"method\":false,\"shorthand\":false,\"computed\":false,\"key\":{\"type\":\"Identifier\",\"name\":\"get\"},\"value\":{\"type\":\"FunctionExpression\",\"id\":{\"type\":\"Identifier\",\"name\":\"get\"},\"generator\":false,\"expression\":false,\"params\":[],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"Identifier\",\"name\":\"INIT\"}}]}},\"kind\":\"init\"}]}]}}]},\"exports-module-declaration-loose\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"exports\"},\"property\":{\"type\":\"Identifier\",\"name\":\"__esModule\"},\"computed\":false},\"right\":{\"type\":\"Literal\",\"value\":true}}}]},\"exports-module-declaration\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Object\"},\"property\":{\"type\":\"Identifier\",\"name\":\"defineProperty\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"exports\"},{\"type\":\"Literal\",\"value\":\"__esModule\"},{\"type\":\"ObjectExpression\",\"properties\":[{\"type\":\"Property\",\"method\":false,\"shorthand\":false,\"computed\":false,\"key\":{\"type\":\"Identifier\",\"name\":\"value\"},\"value\":{\"type\":\"Literal\",\"value\":true},\"kind\":\"init\"}]}]}}]},\"for-of-array\":{\"type\":\"Program\",\"body\":[{\"type\":\"ForStatement\",\"init\":{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"KEY\"},\"init\":{\"type\":\"Literal\",\"value\":0}}],\"kind\":\"var\"},\"test\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"Identifier\",\"name\":\"KEY\"},\"operator\":\"<\",\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"ARR\"},\"property\":{\"type\":\"Identifier\",\"name\":\"length\"},\"computed\":false}},\"update\":{\"type\":\"UpdateExpression\",\"operator\":\"++\",\"prefix\":false,\"argument\":{\"type\":\"Identifier\",\"name\":\"KEY\"}},\"body\":{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"Identifier\",\"name\":\"BODY\"}}}]},\"for-of-loose\":{\"type\":\"Program\",\"body\":[{\"type\":\"ForStatement\",\"init\":{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"LOOP_OBJECT\"},\"init\":{\"type\":\"Identifier\",\"name\":\"OBJECT\"}},{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"IS_ARRAY\"},\"init\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Array\"},\"property\":{\"type\":\"Identifier\",\"name\":\"isArray\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"LOOP_OBJECT\"}]}},{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"INDEX\"},\"init\":{\"type\":\"Literal\",\"value\":0}},{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"LOOP_OBJECT\"},\"init\":{\"type\":\"ConditionalExpression\",\"test\":{\"type\":\"Identifier\",\"name\":\"IS_ARRAY\"},\"consequent\":{\"type\":\"Identifier\",\"name\":\"LOOP_OBJECT\"},\"alternate\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"LOOP_OBJECT\"},\"property\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Symbol\"},\"property\":{\"type\":\"Identifier\",\"name\":\"iterator\"},\"computed\":false},\"computed\":true},\"arguments\":[]}}}],\"kind\":\"var\"},\"test\":null,\"update\":null,\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"ID\"},\"init\":null}],\"kind\":\"var\"},{\"type\":\"IfStatement\",\"test\":{\"type\":\"Identifier\",\"name\":\"IS_ARRAY\"},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"IfStatement\",\"test\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"Identifier\",\"name\":\"INDEX\"},\"operator\":\">=\",\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"LOOP_OBJECT\"},\"property\":{\"type\":\"Identifier\",\"name\":\"length\"},\"computed\":false}},\"consequent\":{\"type\":\"BreakStatement\",\"label\":null},\"alternate\":null},{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"Identifier\",\"name\":\"ID\"},\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"LOOP_OBJECT\"},\"property\":{\"type\":\"UpdateExpression\",\"operator\":\"++\",\"prefix\":false,\"argument\":{\"type\":\"Identifier\",\"name\":\"INDEX\"}},\"computed\":true}}}]},\"alternate\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"Identifier\",\"name\":\"INDEX\"},\"right\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"LOOP_OBJECT\"},\"property\":{\"type\":\"Identifier\",\"name\":\"next\"},\"computed\":false},\"arguments\":[]}}},{\"type\":\"IfStatement\",\"test\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"INDEX\"},\"property\":{\"type\":\"Identifier\",\"name\":\"done\"},\"computed\":false},\"consequent\":{\"type\":\"BreakStatement\",\"label\":null},\"alternate\":null},{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"Identifier\",\"name\":\"ID\"},\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"INDEX\"},\"property\":{\"type\":\"Identifier\",\"name\":\"value\"},\"computed\":false}}}]}}]}}]},\"for-of\":{\"type\":\"Program\",\"body\":[{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"ITERATOR_COMPLETION\"},\"init\":{\"type\":\"Literal\",\"value\":true}}],\"kind\":\"var\"},{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"ITERATOR_HAD_ERROR_KEY\"},\"init\":{\"type\":\"Literal\",\"value\":false}}],\"kind\":\"var\"},{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"ITERATOR_ERROR_KEY\"},\"init\":{\"type\":\"Identifier\",\"name\":\"undefined\"}}],\"kind\":\"var\"},{\"type\":\"TryStatement\",\"block\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ForStatement\",\"init\":{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"ITERATOR_KEY\"},\"init\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"OBJECT\"},\"property\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Symbol\"},\"property\":{\"type\":\"Identifier\",\"name\":\"iterator\"},\"computed\":false},\"computed\":true},\"arguments\":[]}},{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"STEP_KEY\"},\"init\":null}],\"kind\":\"var\"},\"test\":{\"type\":\"UnaryExpression\",\"operator\":\"!\",\"prefix\":true,\"argument\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"Identifier\",\"name\":\"ITERATOR_COMPLETION\"},\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"Identifier\",\"name\":\"STEP_KEY\"},\"right\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"ITERATOR_KEY\"},\"property\":{\"type\":\"Identifier\",\"name\":\"next\"},\"computed\":false},\"arguments\":[]},\"parenthesizedExpression\":true},\"property\":{\"type\":\"Identifier\",\"name\":\"done\"},\"computed\":false},\"parenthesizedExpression\":true}},\"update\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"Identifier\",\"name\":\"ITERATOR_COMPLETION\"},\"right\":{\"type\":\"Literal\",\"value\":true}},\"body\":{\"type\":\"BlockStatement\",\"body\":[]}}]},\"handler\":{\"type\":\"CatchClause\",\"param\":{\"type\":\"Identifier\",\"name\":\"err\"},\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"Identifier\",\"name\":\"ITERATOR_HAD_ERROR_KEY\"},\"right\":{\"type\":\"Literal\",\"value\":true}}},{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"Identifier\",\"name\":\"ITERATOR_ERROR_KEY\"},\"right\":{\"type\":\"Identifier\",\"name\":\"err\"}}}]}},\"guardedHandlers\":[],\"finalizer\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"TryStatement\",\"block\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"IfStatement\",\"test\":{\"type\":\"LogicalExpression\",\"left\":{\"type\":\"UnaryExpression\",\"operator\":\"!\",\"prefix\":true,\"argument\":{\"type\":\"Identifier\",\"name\":\"ITERATOR_COMPLETION\"}},\"operator\":\"&&\",\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"ITERATOR_KEY\"},\"property\":{\"type\":\"Literal\",\"value\":\"return\"},\"computed\":true}},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"ITERATOR_KEY\"},\"property\":{\"type\":\"Literal\",\"value\":\"return\"},\"computed\":true},\"arguments\":[]}}]},\"alternate\":null}]},\"handler\":null,\"guardedHandlers\":[],\"finalizer\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"IfStatement\",\"test\":{\"type\":\"Identifier\",\"name\":\"ITERATOR_HAD_ERROR_KEY\"},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ThrowStatement\",\"argument\":{\"type\":\"Identifier\",\"name\":\"ITERATOR_ERROR_KEY\"}}]},\"alternate\":null}]}}]}}]},\"helper-async-to-generator\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"fn\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"gen\"},\"init\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"fn\"},\"property\":{\"type\":\"Identifier\",\"name\":\"apply\"},\"computed\":false},\"arguments\":[{\"type\":\"ThisExpression\"},{\"type\":\"Identifier\",\"name\":\"arguments\"}]}}],\"kind\":\"var\"},{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"NewExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"Promise\"},\"arguments\":[{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"resolve\"},{\"type\":\"Identifier\",\"name\":\"reject\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"callNext\"},\"init\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"step\"},\"property\":{\"type\":\"Identifier\",\"name\":\"bind\"},\"computed\":false},\"arguments\":[{\"type\":\"Literal\",\"value\":null,\"rawValue\":null},{\"type\":\"Literal\",\"value\":\"next\"}]}}],\"kind\":\"var\"},{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"callThrow\"},\"init\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"step\"},\"property\":{\"type\":\"Identifier\",\"name\":\"bind\"},\"computed\":false},\"arguments\":[{\"type\":\"Literal\",\"value\":null,\"rawValue\":null},{\"type\":\"Literal\",\"value\":\"throw\"}]}}],\"kind\":\"var\"},{\"type\":\"FunctionDeclaration\",\"id\":{\"type\":\"Identifier\",\"name\":\"step\"},\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"key\"},{\"type\":\"Identifier\",\"name\":\"arg\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"TryStatement\",\"block\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"info\"},\"init\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"gen\"},\"property\":{\"type\":\"Identifier\",\"name\":\"key\"},\"computed\":true},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"arg\"}]}}],\"kind\":\"var\"},{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"value\"},\"init\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"info\"},\"property\":{\"type\":\"Identifier\",\"name\":\"value\"},\"computed\":false}}],\"kind\":\"var\"}]},\"handler\":{\"type\":\"CatchClause\",\"param\":{\"type\":\"Identifier\",\"name\":\"error\"},\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"reject\"},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"error\"}]}},{\"type\":\"ReturnStatement\",\"argument\":null}]}},\"guardedHandlers\":[],\"finalizer\":null},{\"type\":\"IfStatement\",\"test\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"info\"},\"property\":{\"type\":\"Identifier\",\"name\":\"done\"},\"computed\":false},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"resolve\"},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"value\"}]}}]},\"alternate\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Promise\"},\"property\":{\"type\":\"Identifier\",\"name\":\"resolve\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"value\"}]},\"property\":{\"type\":\"Identifier\",\"name\":\"then\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"callNext\"},{\"type\":\"Identifier\",\"name\":\"callThrow\"}]}}]}}]}},{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"callNext\"},\"arguments\":[]}}]}}]}}]}}}]},\"parenthesizedExpression\":true}}]},\"helper-bind\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Function\"},\"property\":{\"type\":\"Identifier\",\"name\":\"prototype\"},\"computed\":false},\"property\":{\"type\":\"Identifier\",\"name\":\"bind\"},\"computed\":false}}]},\"helper-class-call-check\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"instance\"},{\"type\":\"Identifier\",\"name\":\"Constructor\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"IfStatement\",\"test\":{\"type\":\"UnaryExpression\",\"operator\":\"!\",\"prefix\":true,\"argument\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"Identifier\",\"name\":\"instance\"},\"operator\":\"instanceof\",\"right\":{\"type\":\"Identifier\",\"name\":\"Constructor\"},\"parenthesizedExpression\":true}},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ThrowStatement\",\"argument\":{\"type\":\"NewExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"TypeError\"},\"arguments\":[{\"type\":\"Literal\",\"value\":\"Cannot call a class as a function\"}]}}]},\"alternate\":null}]},\"parenthesizedExpression\":true}}]},\"helper-create-class\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"FunctionDeclaration\",\"id\":{\"type\":\"Identifier\",\"name\":\"defineProperties\"},\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"target\"},{\"type\":\"Identifier\",\"name\":\"props\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ForStatement\",\"init\":{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"i\"},\"init\":{\"type\":\"Literal\",\"value\":0}}],\"kind\":\"var\"},\"test\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"Identifier\",\"name\":\"i\"},\"operator\":\"<\",\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"props\"},\"property\":{\"type\":\"Identifier\",\"name\":\"length\"},\"computed\":false}},\"update\":{\"type\":\"UpdateExpression\",\"operator\":\"++\",\"prefix\":false,\"argument\":{\"type\":\"Identifier\",\"name\":\"i\"}},\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"descriptor\"},\"init\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"props\"},\"property\":{\"type\":\"Identifier\",\"name\":\"i\"},\"computed\":true}}],\"kind\":\"var\"},{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"descriptor\"},\"property\":{\"type\":\"Identifier\",\"name\":\"enumerable\"},\"computed\":false},\"right\":{\"type\":\"LogicalExpression\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"descriptor\"},\"property\":{\"type\":\"Identifier\",\"name\":\"enumerable\"},\"computed\":false},\"operator\":\"||\",\"right\":{\"type\":\"Literal\",\"value\":false}}}},{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"descriptor\"},\"property\":{\"type\":\"Identifier\",\"name\":\"configurable\"},\"computed\":false},\"right\":{\"type\":\"Literal\",\"value\":true}}},{\"type\":\"IfStatement\",\"test\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"Literal\",\"value\":\"value\"},\"operator\":\"in\",\"right\":{\"type\":\"Identifier\",\"name\":\"descriptor\"}},\"consequent\":{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"descriptor\"},\"property\":{\"type\":\"Identifier\",\"name\":\"writable\"},\"computed\":false},\"right\":{\"type\":\"Literal\",\"value\":true}}},\"alternate\":null},{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Object\"},\"property\":{\"type\":\"Identifier\",\"name\":\"defineProperty\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"target\"},{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"descriptor\"},\"property\":{\"type\":\"Identifier\",\"name\":\"key\"},\"computed\":false},{\"type\":\"Identifier\",\"name\":\"descriptor\"}]}}]}}]}},{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"Constructor\"},{\"type\":\"Identifier\",\"name\":\"protoProps\"},{\"type\":\"Identifier\",\"name\":\"staticProps\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"IfStatement\",\"test\":{\"type\":\"Identifier\",\"name\":\"protoProps\"},\"consequent\":{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"defineProperties\"},\"arguments\":[{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Constructor\"},\"property\":{\"type\":\"Identifier\",\"name\":\"prototype\"},\"computed\":false},{\"type\":\"Identifier\",\"name\":\"protoProps\"}]}},\"alternate\":null},{\"type\":\"IfStatement\",\"test\":{\"type\":\"Identifier\",\"name\":\"staticProps\"},\"consequent\":{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"defineProperties\"},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"Constructor\"},{\"type\":\"Identifier\",\"name\":\"staticProps\"}]}},\"alternate\":null},{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"Identifier\",\"name\":\"Constructor\"}}]}}}]},\"parenthesizedExpression\":true},\"arguments\":[]}}]},\"helper-create-decorated-class\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"FunctionDeclaration\",\"id\":{\"type\":\"Identifier\",\"name\":\"defineProperties\"},\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"target\"},{\"type\":\"Identifier\",\"name\":\"descriptors\"},{\"type\":\"Identifier\",\"name\":\"initializers\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ForStatement\",\"init\":{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"i\"},\"init\":{\"type\":\"Literal\",\"value\":0}}],\"kind\":\"var\"},\"test\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"Identifier\",\"name\":\"i\"},\"operator\":\"<\",\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"descriptors\"},\"property\":{\"type\":\"Identifier\",\"name\":\"length\"},\"computed\":false}},\"update\":{\"type\":\"UpdateExpression\",\"operator\":\"++\",\"prefix\":false,\"argument\":{\"type\":\"Identifier\",\"name\":\"i\"}},\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"descriptor\"},\"init\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"descriptors\"},\"property\":{\"type\":\"Identifier\",\"name\":\"i\"},\"computed\":true}}],\"kind\":\"var\"},{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"decorators\"},\"init\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"descriptor\"},\"property\":{\"type\":\"Identifier\",\"name\":\"decorators\"},\"computed\":false}}],\"kind\":\"var\"},{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"key\"},\"init\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"descriptor\"},\"property\":{\"type\":\"Identifier\",\"name\":\"key\"},\"computed\":false}}],\"kind\":\"var\"},{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"UnaryExpression\",\"operator\":\"delete\",\"prefix\":true,\"argument\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"descriptor\",\"leadingComments\":null},\"property\":{\"type\":\"Identifier\",\"name\":\"key\"},\"computed\":false,\"leadingComments\":null},\"leadingComments\":null}},{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"UnaryExpression\",\"operator\":\"delete\",\"prefix\":true,\"argument\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"descriptor\"},\"property\":{\"type\":\"Identifier\",\"name\":\"decorators\"},\"computed\":false}}},{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"descriptor\"},\"property\":{\"type\":\"Identifier\",\"name\":\"enumerable\"},\"computed\":false},\"right\":{\"type\":\"LogicalExpression\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"descriptor\"},\"property\":{\"type\":\"Identifier\",\"name\":\"enumerable\"},\"computed\":false},\"operator\":\"||\",\"right\":{\"type\":\"Literal\",\"value\":false}}}},{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"descriptor\"},\"property\":{\"type\":\"Identifier\",\"name\":\"configurable\"},\"computed\":false},\"right\":{\"type\":\"Literal\",\"value\":true}}},{\"type\":\"IfStatement\",\"test\":{\"type\":\"LogicalExpression\",\"left\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"Literal\",\"value\":\"value\"},\"operator\":\"in\",\"right\":{\"type\":\"Identifier\",\"name\":\"descriptor\"}},\"operator\":\"||\",\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"descriptor\"},\"property\":{\"type\":\"Identifier\",\"name\":\"initializer\"},\"computed\":false}},\"consequent\":{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"descriptor\"},\"property\":{\"type\":\"Identifier\",\"name\":\"writable\"},\"computed\":false},\"right\":{\"type\":\"Literal\",\"value\":true}}},\"alternate\":null},{\"type\":\"IfStatement\",\"test\":{\"type\":\"Identifier\",\"name\":\"decorators\"},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ForStatement\",\"init\":{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"f\"},\"init\":{\"type\":\"Literal\",\"value\":0}}],\"kind\":\"var\"},\"test\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"Identifier\",\"name\":\"f\"},\"operator\":\"<\",\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"decorators\"},\"property\":{\"type\":\"Identifier\",\"name\":\"length\"},\"computed\":false}},\"update\":{\"type\":\"UpdateExpression\",\"operator\":\"++\",\"prefix\":false,\"argument\":{\"type\":\"Identifier\",\"name\":\"f\"}},\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"decorator\"},\"init\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"decorators\"},\"property\":{\"type\":\"Identifier\",\"name\":\"f\"},\"computed\":true}}],\"kind\":\"var\"},{\"type\":\"IfStatement\",\"test\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"UnaryExpression\",\"operator\":\"typeof\",\"prefix\":true,\"argument\":{\"type\":\"Identifier\",\"name\":\"decorator\"}},\"operator\":\"===\",\"right\":{\"type\":\"Literal\",\"value\":\"function\"}},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"Identifier\",\"name\":\"descriptor\"},\"right\":{\"type\":\"LogicalExpression\",\"left\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"decorator\"},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"target\"},{\"type\":\"Identifier\",\"name\":\"key\"},{\"type\":\"Identifier\",\"name\":\"descriptor\"}]},\"operator\":\"||\",\"right\":{\"type\":\"Identifier\",\"name\":\"descriptor\"}}}}]},\"alternate\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ThrowStatement\",\"argument\":{\"type\":\"NewExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"TypeError\"},\"arguments\":[{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"Literal\",\"value\":\"The decorator for method \"},\"operator\":\"+\",\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"descriptor\"},\"property\":{\"type\":\"Identifier\",\"name\":\"key\"},\"computed\":false}},\"operator\":\"+\",\"right\":{\"type\":\"Literal\",\"value\":\" is of the invalid type \"}},\"operator\":\"+\",\"right\":{\"type\":\"UnaryExpression\",\"operator\":\"typeof\",\"prefix\":true,\"argument\":{\"type\":\"Identifier\",\"name\":\"decorator\"}}}]}}]}}]}},{\"type\":\"IfStatement\",\"test\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"descriptor\"},\"property\":{\"type\":\"Identifier\",\"name\":\"initializer\"},\"computed\":false},\"operator\":\"!==\",\"right\":{\"type\":\"Identifier\",\"name\":\"undefined\"}},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"initializers\"},\"property\":{\"type\":\"Identifier\",\"name\":\"key\"},\"computed\":true},\"right\":{\"type\":\"Identifier\",\"name\":\"descriptor\"}}},{\"type\":\"ContinueStatement\",\"label\":null}]},\"alternate\":null}]},\"alternate\":null},{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Object\"},\"property\":{\"type\":\"Identifier\",\"name\":\"defineProperty\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"target\"},{\"type\":\"Identifier\",\"name\":\"key\"},{\"type\":\"Identifier\",\"name\":\"descriptor\"}]}}]}}]}},{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"Constructor\"},{\"type\":\"Identifier\",\"name\":\"protoProps\"},{\"type\":\"Identifier\",\"name\":\"staticProps\"},{\"type\":\"Identifier\",\"name\":\"protoInitializers\"},{\"type\":\"Identifier\",\"name\":\"staticInitializers\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"IfStatement\",\"test\":{\"type\":\"Identifier\",\"name\":\"protoProps\"},\"consequent\":{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"defineProperties\"},\"arguments\":[{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Constructor\"},\"property\":{\"type\":\"Identifier\",\"name\":\"prototype\"},\"computed\":false},{\"type\":\"Identifier\",\"name\":\"protoProps\"},{\"type\":\"Identifier\",\"name\":\"protoInitializers\"}]}},\"alternate\":null},{\"type\":\"IfStatement\",\"test\":{\"type\":\"Identifier\",\"name\":\"staticProps\"},\"consequent\":{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"defineProperties\"},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"Constructor\"},{\"type\":\"Identifier\",\"name\":\"staticProps\"},{\"type\":\"Identifier\",\"name\":\"staticInitializers\"}]}},\"alternate\":null},{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"Identifier\",\"name\":\"Constructor\"}}]}}}]},\"parenthesizedExpression\":true},\"arguments\":[]}}]},\"helper-create-decorated-object\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"descriptors\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"target\"},\"init\":{\"type\":\"ObjectExpression\",\"properties\":[]}}],\"kind\":\"var\"},{\"type\":\"ForStatement\",\"init\":{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"i\"},\"init\":{\"type\":\"Literal\",\"value\":0}}],\"kind\":\"var\"},\"test\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"Identifier\",\"name\":\"i\"},\"operator\":\"<\",\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"descriptors\"},\"property\":{\"type\":\"Identifier\",\"name\":\"length\"},\"computed\":false}},\"update\":{\"type\":\"UpdateExpression\",\"operator\":\"++\",\"prefix\":false,\"argument\":{\"type\":\"Identifier\",\"name\":\"i\"}},\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"descriptor\"},\"init\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"descriptors\"},\"property\":{\"type\":\"Identifier\",\"name\":\"i\"},\"computed\":true}}],\"kind\":\"var\"},{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"decorators\"},\"init\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"descriptor\"},\"property\":{\"type\":\"Identifier\",\"name\":\"decorators\"},\"computed\":false}}],\"kind\":\"var\"},{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"key\"},\"init\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"descriptor\"},\"property\":{\"type\":\"Identifier\",\"name\":\"key\"},\"computed\":false}}],\"kind\":\"var\"},{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"UnaryExpression\",\"operator\":\"delete\",\"prefix\":true,\"argument\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"descriptor\",\"leadingComments\":null},\"property\":{\"type\":\"Identifier\",\"name\":\"key\"},\"computed\":false,\"leadingComments\":null},\"leadingComments\":null}},{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"UnaryExpression\",\"operator\":\"delete\",\"prefix\":true,\"argument\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"descriptor\"},\"property\":{\"type\":\"Identifier\",\"name\":\"decorators\"},\"computed\":false}}},{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"descriptor\"},\"property\":{\"type\":\"Identifier\",\"name\":\"enumerable\"},\"computed\":false},\"right\":{\"type\":\"Literal\",\"value\":true}}},{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"descriptor\"},\"property\":{\"type\":\"Identifier\",\"name\":\"configurable\"},\"computed\":false},\"right\":{\"type\":\"Literal\",\"value\":true}}},{\"type\":\"IfStatement\",\"test\":{\"type\":\"LogicalExpression\",\"left\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"Literal\",\"value\":\"value\"},\"operator\":\"in\",\"right\":{\"type\":\"Identifier\",\"name\":\"descriptor\"}},\"operator\":\"||\",\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"descriptor\"},\"property\":{\"type\":\"Identifier\",\"name\":\"initializer\"},\"computed\":false}},\"consequent\":{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"descriptor\"},\"property\":{\"type\":\"Identifier\",\"name\":\"writable\"},\"computed\":false},\"right\":{\"type\":\"Literal\",\"value\":true}}},\"alternate\":null},{\"type\":\"IfStatement\",\"test\":{\"type\":\"Identifier\",\"name\":\"decorators\"},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ForStatement\",\"init\":{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"f\"},\"init\":{\"type\":\"Literal\",\"value\":0}}],\"kind\":\"var\"},\"test\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"Identifier\",\"name\":\"f\"},\"operator\":\"<\",\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"decorators\"},\"property\":{\"type\":\"Identifier\",\"name\":\"length\"},\"computed\":false}},\"update\":{\"type\":\"UpdateExpression\",\"operator\":\"++\",\"prefix\":false,\"argument\":{\"type\":\"Identifier\",\"name\":\"f\"}},\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"decorator\"},\"init\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"decorators\"},\"property\":{\"type\":\"Identifier\",\"name\":\"f\"},\"computed\":true}}],\"kind\":\"var\"},{\"type\":\"IfStatement\",\"test\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"UnaryExpression\",\"operator\":\"typeof\",\"prefix\":true,\"argument\":{\"type\":\"Identifier\",\"name\":\"decorator\"}},\"operator\":\"===\",\"right\":{\"type\":\"Literal\",\"value\":\"function\"}},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"Identifier\",\"name\":\"descriptor\"},\"right\":{\"type\":\"LogicalExpression\",\"left\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"decorator\"},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"target\"},{\"type\":\"Identifier\",\"name\":\"key\"},{\"type\":\"Identifier\",\"name\":\"descriptor\"}]},\"operator\":\"||\",\"right\":{\"type\":\"Identifier\",\"name\":\"descriptor\"}}}}]},\"alternate\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ThrowStatement\",\"argument\":{\"type\":\"NewExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"TypeError\"},\"arguments\":[{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"Literal\",\"value\":\"The decorator for method \"},\"operator\":\"+\",\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"descriptor\"},\"property\":{\"type\":\"Identifier\",\"name\":\"key\"},\"computed\":false}},\"operator\":\"+\",\"right\":{\"type\":\"Literal\",\"value\":\" is of the invalid type \"}},\"operator\":\"+\",\"right\":{\"type\":\"UnaryExpression\",\"operator\":\"typeof\",\"prefix\":true,\"argument\":{\"type\":\"Identifier\",\"name\":\"decorator\"}}}]}}]}}]}}]},\"alternate\":null},{\"type\":\"IfStatement\",\"test\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"descriptor\"},\"property\":{\"type\":\"Identifier\",\"name\":\"initializer\"},\"computed\":false},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"descriptor\"},\"property\":{\"type\":\"Identifier\",\"name\":\"value\"},\"computed\":false},\"right\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"descriptor\"},\"property\":{\"type\":\"Identifier\",\"name\":\"initializer\"},\"computed\":false},\"property\":{\"type\":\"Identifier\",\"name\":\"call\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"target\"}]}}}]},\"alternate\":null},{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Object\"},\"property\":{\"type\":\"Identifier\",\"name\":\"defineProperty\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"target\"},{\"type\":\"Identifier\",\"name\":\"key\"},{\"type\":\"Identifier\",\"name\":\"descriptor\"}]}}]}},{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"Identifier\",\"name\":\"target\"}}]},\"parenthesizedExpression\":true}}]},\"helper-default-props\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"defaultProps\"},{\"type\":\"Identifier\",\"name\":\"props\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"IfStatement\",\"test\":{\"type\":\"Identifier\",\"name\":\"defaultProps\"},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ForInStatement\",\"left\":{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"propName\"},\"init\":null}],\"kind\":\"var\"},\"right\":{\"type\":\"Identifier\",\"name\":\"defaultProps\"},\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"IfStatement\",\"test\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"UnaryExpression\",\"operator\":\"typeof\",\"prefix\":true,\"argument\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"props\"},\"property\":{\"type\":\"Identifier\",\"name\":\"propName\"},\"computed\":true}},\"operator\":\"===\",\"right\":{\"type\":\"Literal\",\"value\":\"undefined\"}},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"props\"},\"property\":{\"type\":\"Identifier\",\"name\":\"propName\"},\"computed\":true},\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"defaultProps\"},\"property\":{\"type\":\"Identifier\",\"name\":\"propName\"},\"computed\":true}}}]},\"alternate\":null}]}}]},\"alternate\":null},{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"Identifier\",\"name\":\"props\"}}]},\"parenthesizedExpression\":true}}]},\"helper-defaults\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"obj\"},{\"type\":\"Identifier\",\"name\":\"defaults\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"keys\"},\"init\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Object\"},\"property\":{\"type\":\"Identifier\",\"name\":\"getOwnPropertyNames\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"defaults\"}]}}],\"kind\":\"var\"},{\"type\":\"ForStatement\",\"init\":{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"i\"},\"init\":{\"type\":\"Literal\",\"value\":0}}],\"kind\":\"var\"},\"test\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"Identifier\",\"name\":\"i\"},\"operator\":\"<\",\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"keys\"},\"property\":{\"type\":\"Identifier\",\"name\":\"length\"},\"computed\":false}},\"update\":{\"type\":\"UpdateExpression\",\"operator\":\"++\",\"prefix\":false,\"argument\":{\"type\":\"Identifier\",\"name\":\"i\"}},\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"key\"},\"init\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"keys\"},\"property\":{\"type\":\"Identifier\",\"name\":\"i\"},\"computed\":true}}],\"kind\":\"var\"},{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"value\"},\"init\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Object\"},\"property\":{\"type\":\"Identifier\",\"name\":\"getOwnPropertyDescriptor\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"defaults\"},{\"type\":\"Identifier\",\"name\":\"key\"}]}}],\"kind\":\"var\"},{\"type\":\"IfStatement\",\"test\":{\"type\":\"LogicalExpression\",\"left\":{\"type\":\"LogicalExpression\",\"left\":{\"type\":\"Identifier\",\"name\":\"value\"},\"operator\":\"&&\",\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"value\"},\"property\":{\"type\":\"Identifier\",\"name\":\"configurable\"},\"computed\":false}},\"operator\":\"&&\",\"right\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"obj\"},\"property\":{\"type\":\"Identifier\",\"name\":\"key\"},\"computed\":true},\"operator\":\"===\",\"right\":{\"type\":\"Identifier\",\"name\":\"undefined\"}}},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Object\"},\"property\":{\"type\":\"Identifier\",\"name\":\"defineProperty\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"obj\"},{\"type\":\"Identifier\",\"name\":\"key\"},{\"type\":\"Identifier\",\"name\":\"value\"}]}}]},\"alternate\":null}]}},{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"Identifier\",\"name\":\"obj\"}}]},\"parenthesizedExpression\":true}}]},\"helper-define-decorated-property-descriptor\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"target\"},{\"type\":\"Identifier\",\"name\":\"key\"},{\"type\":\"Identifier\",\"name\":\"descriptors\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"_descriptor\"},\"init\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"descriptors\"},\"property\":{\"type\":\"Identifier\",\"name\":\"key\"},\"computed\":true}}],\"kind\":\"var\"},{\"type\":\"IfStatement\",\"test\":{\"type\":\"UnaryExpression\",\"operator\":\"!\",\"prefix\":true,\"argument\":{\"type\":\"Identifier\",\"name\":\"_descriptor\"}},\"consequent\":{\"type\":\"ReturnStatement\",\"argument\":null,\"leadingComments\":null,\"trailingComments\":null},\"alternate\":null},{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"descriptor\",\"leadingComments\":null},\"init\":{\"type\":\"ObjectExpression\",\"properties\":[]},\"leadingComments\":null}],\"kind\":\"var\"},{\"type\":\"ForInStatement\",\"left\":{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"_key\"},\"init\":null}],\"kind\":\"var\"},\"right\":{\"type\":\"Identifier\",\"name\":\"_descriptor\"},\"body\":{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"descriptor\"},\"property\":{\"type\":\"Identifier\",\"name\":\"_key\"},\"computed\":true},\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"_descriptor\"},\"property\":{\"type\":\"Identifier\",\"name\":\"_key\"},\"computed\":true}},\"trailingComments\":null}},{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"descriptor\",\"leadingComments\":null},\"property\":{\"type\":\"Identifier\",\"name\":\"value\"},\"computed\":false,\"leadingComments\":null},\"right\":{\"type\":\"ConditionalExpression\",\"test\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"descriptor\"},\"property\":{\"type\":\"Identifier\",\"name\":\"initializer\"},\"computed\":false},\"consequent\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"descriptor\"},\"property\":{\"type\":\"Identifier\",\"name\":\"initializer\"},\"computed\":false},\"property\":{\"type\":\"Identifier\",\"name\":\"call\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"target\"}]},\"alternate\":{\"type\":\"Identifier\",\"name\":\"undefined\"}},\"leadingComments\":null}},{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Object\"},\"property\":{\"type\":\"Identifier\",\"name\":\"defineProperty\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"target\"},{\"type\":\"Identifier\",\"name\":\"key\"},{\"type\":\"Identifier\",\"name\":\"descriptor\"}]}}]},\"parenthesizedExpression\":true}}]},\"helper-define-property\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"obj\"},{\"type\":\"Identifier\",\"name\":\"key\"},{\"type\":\"Identifier\",\"name\":\"value\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"IfStatement\",\"test\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"Identifier\",\"name\":\"key\",\"leadingComments\":null},\"operator\":\"in\",\"right\":{\"type\":\"Identifier\",\"name\":\"obj\"},\"leadingComments\":null},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Object\"},\"property\":{\"type\":\"Identifier\",\"name\":\"defineProperty\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"obj\"},{\"type\":\"Identifier\",\"name\":\"key\"},{\"type\":\"ObjectExpression\",\"properties\":[{\"type\":\"Property\",\"method\":false,\"shorthand\":false,\"computed\":false,\"key\":{\"type\":\"Identifier\",\"name\":\"value\"},\"value\":{\"type\":\"Identifier\",\"name\":\"value\"},\"kind\":\"init\"},{\"type\":\"Property\",\"method\":false,\"shorthand\":false,\"computed\":false,\"key\":{\"type\":\"Identifier\",\"name\":\"enumerable\"},\"value\":{\"type\":\"Literal\",\"value\":true},\"kind\":\"init\"},{\"type\":\"Property\",\"method\":false,\"shorthand\":false,\"computed\":false,\"key\":{\"type\":\"Identifier\",\"name\":\"configurable\"},\"value\":{\"type\":\"Literal\",\"value\":true},\"kind\":\"init\"},{\"type\":\"Property\",\"method\":false,\"shorthand\":false,\"computed\":false,\"key\":{\"type\":\"Identifier\",\"name\":\"writable\"},\"value\":{\"type\":\"Literal\",\"value\":true},\"kind\":\"init\"}]}]}}]},\"alternate\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"obj\"},\"property\":{\"type\":\"Identifier\",\"name\":\"key\"},\"computed\":true},\"right\":{\"type\":\"Identifier\",\"name\":\"value\"}}}]}},{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"Identifier\",\"name\":\"obj\"}}]},\"parenthesizedExpression\":true}}]},\"helper-extends\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"LogicalExpression\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Object\"},\"property\":{\"type\":\"Identifier\",\"name\":\"assign\"},\"computed\":false},\"operator\":\"||\",\"right\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"target\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ForStatement\",\"init\":{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"i\"},\"init\":{\"type\":\"Literal\",\"value\":1}}],\"kind\":\"var\"},\"test\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"Identifier\",\"name\":\"i\"},\"operator\":\"<\",\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"arguments\"},\"property\":{\"type\":\"Identifier\",\"name\":\"length\"},\"computed\":false}},\"update\":{\"type\":\"UpdateExpression\",\"operator\":\"++\",\"prefix\":false,\"argument\":{\"type\":\"Identifier\",\"name\":\"i\"}},\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"source\"},\"init\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"arguments\"},\"property\":{\"type\":\"Identifier\",\"name\":\"i\"},\"computed\":true}}],\"kind\":\"var\"},{\"type\":\"ForInStatement\",\"left\":{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"key\"},\"init\":null}],\"kind\":\"var\"},\"right\":{\"type\":\"Identifier\",\"name\":\"source\"},\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"IfStatement\",\"test\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Object\"},\"property\":{\"type\":\"Identifier\",\"name\":\"prototype\"},\"computed\":false},\"property\":{\"type\":\"Identifier\",\"name\":\"hasOwnProperty\"},\"computed\":false},\"property\":{\"type\":\"Identifier\",\"name\":\"call\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"source\"},{\"type\":\"Identifier\",\"name\":\"key\"}]},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"target\"},\"property\":{\"type\":\"Identifier\",\"name\":\"key\"},\"computed\":true},\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"source\"},\"property\":{\"type\":\"Identifier\",\"name\":\"key\"},\"computed\":true}}}]},\"alternate\":null}]}}]}},{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"Identifier\",\"name\":\"target\"}}]}}}}]},\"helper-get\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"FunctionExpression\",\"id\":{\"type\":\"Identifier\",\"name\":\"get\"},\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"object\"},{\"type\":\"Identifier\",\"name\":\"property\"},{\"type\":\"Identifier\",\"name\":\"receiver\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"IfStatement\",\"test\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"Identifier\",\"name\":\"object\"},\"operator\":\"===\",\"right\":{\"type\":\"Literal\",\"value\":null,\"rawValue\":null}},\"consequent\":{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"Identifier\",\"name\":\"object\"},\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Function\"},\"property\":{\"type\":\"Identifier\",\"name\":\"prototype\"},\"computed\":false}}},\"alternate\":null},{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"desc\"},\"init\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Object\"},\"property\":{\"type\":\"Identifier\",\"name\":\"getOwnPropertyDescriptor\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"object\"},{\"type\":\"Identifier\",\"name\":\"property\"}]}}],\"kind\":\"var\"},{\"type\":\"IfStatement\",\"test\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"Identifier\",\"name\":\"desc\"},\"operator\":\"===\",\"right\":{\"type\":\"Identifier\",\"name\":\"undefined\"}},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"parent\"},\"init\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Object\"},\"property\":{\"type\":\"Identifier\",\"name\":\"getPrototypeOf\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"object\"}]}}],\"kind\":\"var\"},{\"type\":\"IfStatement\",\"test\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"Identifier\",\"name\":\"parent\"},\"operator\":\"===\",\"right\":{\"type\":\"Literal\",\"value\":null,\"rawValue\":null}},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"Identifier\",\"name\":\"undefined\"}}]},\"alternate\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"get\"},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"parent\"},{\"type\":\"Identifier\",\"name\":\"property\"},{\"type\":\"Identifier\",\"name\":\"receiver\"}]}}]}}]},\"alternate\":{\"type\":\"IfStatement\",\"test\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"Literal\",\"value\":\"value\"},\"operator\":\"in\",\"right\":{\"type\":\"Identifier\",\"name\":\"desc\"}},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"desc\"},\"property\":{\"type\":\"Identifier\",\"name\":\"value\"},\"computed\":false}}]},\"alternate\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"getter\"},\"init\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"desc\"},\"property\":{\"type\":\"Identifier\",\"name\":\"get\"},\"computed\":false}}],\"kind\":\"var\"},{\"type\":\"IfStatement\",\"test\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"Identifier\",\"name\":\"getter\"},\"operator\":\"===\",\"right\":{\"type\":\"Identifier\",\"name\":\"undefined\"}},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"Identifier\",\"name\":\"undefined\"}}]},\"alternate\":null},{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"getter\"},\"property\":{\"type\":\"Identifier\",\"name\":\"call\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"receiver\"}]}}]}}}]},\"parenthesizedExpression\":true}}]},\"helper-has-own\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Object\"},\"property\":{\"type\":\"Identifier\",\"name\":\"prototype\"},\"computed\":false},\"property\":{\"type\":\"Identifier\",\"name\":\"hasOwnProperty\"},\"computed\":false}}]},\"helper-inherits\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"subClass\"},{\"type\":\"Identifier\",\"name\":\"superClass\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"IfStatement\",\"test\":{\"type\":\"LogicalExpression\",\"left\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"UnaryExpression\",\"operator\":\"typeof\",\"prefix\":true,\"argument\":{\"type\":\"Identifier\",\"name\":\"superClass\"}},\"operator\":\"!==\",\"right\":{\"type\":\"Literal\",\"value\":\"function\"}},\"operator\":\"&&\",\"right\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"Identifier\",\"name\":\"superClass\"},\"operator\":\"!==\",\"right\":{\"type\":\"Literal\",\"value\":null,\"rawValue\":null}}},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ThrowStatement\",\"argument\":{\"type\":\"NewExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"TypeError\"},\"arguments\":[{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"Literal\",\"value\":\"Super expression must either be null or a function, not \"},\"operator\":\"+\",\"right\":{\"type\":\"UnaryExpression\",\"operator\":\"typeof\",\"prefix\":true,\"argument\":{\"type\":\"Identifier\",\"name\":\"superClass\"}}}]}}]},\"alternate\":null},{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"subClass\"},\"property\":{\"type\":\"Identifier\",\"name\":\"prototype\"},\"computed\":false},\"right\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Object\"},\"property\":{\"type\":\"Identifier\",\"name\":\"create\"},\"computed\":false},\"arguments\":[{\"type\":\"LogicalExpression\",\"left\":{\"type\":\"Identifier\",\"name\":\"superClass\"},\"operator\":\"&&\",\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"superClass\"},\"property\":{\"type\":\"Identifier\",\"name\":\"prototype\"},\"computed\":false}},{\"type\":\"ObjectExpression\",\"properties\":[{\"type\":\"Property\",\"method\":false,\"shorthand\":false,\"computed\":false,\"key\":{\"type\":\"Identifier\",\"name\":\"constructor\"},\"value\":{\"type\":\"ObjectExpression\",\"properties\":[{\"type\":\"Property\",\"method\":false,\"shorthand\":false,\"computed\":false,\"key\":{\"type\":\"Identifier\",\"name\":\"value\"},\"value\":{\"type\":\"Identifier\",\"name\":\"subClass\"},\"kind\":\"init\"},{\"type\":\"Property\",\"method\":false,\"shorthand\":false,\"computed\":false,\"key\":{\"type\":\"Identifier\",\"name\":\"enumerable\"},\"value\":{\"type\":\"Literal\",\"value\":false},\"kind\":\"init\"},{\"type\":\"Property\",\"method\":false,\"shorthand\":false,\"computed\":false,\"key\":{\"type\":\"Identifier\",\"name\":\"writable\"},\"value\":{\"type\":\"Literal\",\"value\":true},\"kind\":\"init\"},{\"type\":\"Property\",\"method\":false,\"shorthand\":false,\"computed\":false,\"key\":{\"type\":\"Identifier\",\"name\":\"configurable\"},\"value\":{\"type\":\"Literal\",\"value\":true},\"kind\":\"init\"}]},\"kind\":\"init\"}]}]}}},{\"type\":\"IfStatement\",\"test\":{\"type\":\"Identifier\",\"name\":\"superClass\"},\"consequent\":{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"ConditionalExpression\",\"test\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Object\"},\"property\":{\"type\":\"Identifier\",\"name\":\"setPrototypeOf\"},\"computed\":false},\"consequent\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Object\"},\"property\":{\"type\":\"Identifier\",\"name\":\"setPrototypeOf\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"subClass\"},{\"type\":\"Identifier\",\"name\":\"superClass\"}]},\"alternate\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"subClass\"},\"property\":{\"type\":\"Identifier\",\"name\":\"__proto__\"},\"computed\":false},\"right\":{\"type\":\"Identifier\",\"name\":\"superClass\"}}}},\"alternate\":null}]},\"parenthesizedExpression\":true}}]},\"helper-instanceof\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"left\"},{\"type\":\"Identifier\",\"name\":\"right\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"IfStatement\",\"test\":{\"type\":\"LogicalExpression\",\"left\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"Identifier\",\"name\":\"right\"},\"operator\":\"!=\",\"right\":{\"type\":\"Literal\",\"value\":null,\"rawValue\":null}},\"operator\":\"&&\",\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"right\"},\"property\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Symbol\"},\"property\":{\"type\":\"Identifier\",\"name\":\"hasInstance\"},\"computed\":false},\"computed\":true}},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"right\"},\"property\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Symbol\"},\"property\":{\"type\":\"Identifier\",\"name\":\"hasInstance\"},\"computed\":false},\"computed\":true},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"left\"}]}}]},\"alternate\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"Identifier\",\"name\":\"left\"},\"operator\":\"instanceof\",\"right\":{\"type\":\"Identifier\",\"name\":\"right\"}}}]}}]},\"parenthesizedExpression\":true}}]},\"helper-interop-export-wildcard\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"obj\"},{\"type\":\"Identifier\",\"name\":\"defaults\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"newObj\"},\"init\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"defaults\"},\"arguments\":[{\"type\":\"ObjectExpression\",\"properties\":[]},{\"type\":\"Identifier\",\"name\":\"obj\"}]}}],\"kind\":\"var\"},{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"UnaryExpression\",\"operator\":\"delete\",\"prefix\":true,\"argument\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"newObj\"},\"property\":{\"type\":\"Literal\",\"value\":\"default\"},\"computed\":true}}},{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"Identifier\",\"name\":\"newObj\"}}]},\"parenthesizedExpression\":true}}]},\"helper-interop-require-default\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"obj\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"ConditionalExpression\",\"test\":{\"type\":\"LogicalExpression\",\"left\":{\"type\":\"Identifier\",\"name\":\"obj\"},\"operator\":\"&&\",\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"obj\"},\"property\":{\"type\":\"Identifier\",\"name\":\"__esModule\"},\"computed\":false}},\"consequent\":{\"type\":\"Identifier\",\"name\":\"obj\"},\"alternate\":{\"type\":\"ObjectExpression\",\"properties\":[{\"type\":\"Property\",\"method\":false,\"shorthand\":false,\"computed\":false,\"key\":{\"type\":\"Literal\",\"value\":\"default\"},\"value\":{\"type\":\"Identifier\",\"name\":\"obj\"},\"kind\":\"init\"}]}}}]},\"parenthesizedExpression\":true}}]},\"helper-interop-require-wildcard\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"obj\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"IfStatement\",\"test\":{\"type\":\"LogicalExpression\",\"left\":{\"type\":\"Identifier\",\"name\":\"obj\"},\"operator\":\"&&\",\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"obj\"},\"property\":{\"type\":\"Identifier\",\"name\":\"__esModule\"},\"computed\":false}},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"Identifier\",\"name\":\"obj\"}}]},\"alternate\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"newObj\"},\"init\":{\"type\":\"ObjectExpression\",\"properties\":[]}}],\"kind\":\"var\"},{\"type\":\"IfStatement\",\"test\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"Identifier\",\"name\":\"obj\"},\"operator\":\"!=\",\"right\":{\"type\":\"Literal\",\"value\":null,\"rawValue\":null}},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ForInStatement\",\"left\":{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"key\"},\"init\":null}],\"kind\":\"var\"},\"right\":{\"type\":\"Identifier\",\"name\":\"obj\"},\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"IfStatement\",\"test\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Object\"},\"property\":{\"type\":\"Identifier\",\"name\":\"prototype\"},\"computed\":false},\"property\":{\"type\":\"Identifier\",\"name\":\"hasOwnProperty\"},\"computed\":false},\"property\":{\"type\":\"Identifier\",\"name\":\"call\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"obj\"},{\"type\":\"Identifier\",\"name\":\"key\"}]},\"consequent\":{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"newObj\"},\"property\":{\"type\":\"Identifier\",\"name\":\"key\"},\"computed\":true},\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"obj\"},\"property\":{\"type\":\"Identifier\",\"name\":\"key\"},\"computed\":true}}},\"alternate\":null}]}}]},\"alternate\":null},{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"newObj\"},\"property\":{\"type\":\"Literal\",\"value\":\"default\"},\"computed\":true},\"right\":{\"type\":\"Identifier\",\"name\":\"obj\"}}},{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"Identifier\",\"name\":\"newObj\"}}]}}]},\"parenthesizedExpression\":true}}]},\"helper-interop-require\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"obj\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"ConditionalExpression\",\"test\":{\"type\":\"LogicalExpression\",\"left\":{\"type\":\"Identifier\",\"name\":\"obj\"},\"operator\":\"&&\",\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"obj\"},\"property\":{\"type\":\"Identifier\",\"name\":\"__esModule\"},\"computed\":false}},\"consequent\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"obj\"},\"property\":{\"type\":\"Literal\",\"value\":\"default\"},\"computed\":true},\"alternate\":{\"type\":\"Identifier\",\"name\":\"obj\"}}}]},\"parenthesizedExpression\":true}}]},\"helper-new-arrow-check\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"innerThis\"},{\"type\":\"Identifier\",\"name\":\"boundThis\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"IfStatement\",\"test\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"Identifier\",\"name\":\"innerThis\"},\"operator\":\"!==\",\"right\":{\"type\":\"Identifier\",\"name\":\"boundThis\"}},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ThrowStatement\",\"argument\":{\"type\":\"NewExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"TypeError\"},\"arguments\":[{\"type\":\"Literal\",\"value\":\"Cannot instantiate an arrow function\"}]}}]},\"alternate\":null}]},\"parenthesizedExpression\":true}}]},\"helper-object-destructuring-empty\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"obj\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"IfStatement\",\"test\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"Identifier\",\"name\":\"obj\"},\"operator\":\"==\",\"right\":{\"type\":\"Literal\",\"value\":null,\"rawValue\":null}},\"consequent\":{\"type\":\"ThrowStatement\",\"argument\":{\"type\":\"NewExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"TypeError\"},\"arguments\":[{\"type\":\"Literal\",\"value\":\"Cannot destructure undefined\"}]}},\"alternate\":null}]},\"parenthesizedExpression\":true}}]},\"helper-object-without-properties\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"obj\"},{\"type\":\"Identifier\",\"name\":\"keys\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"target\"},\"init\":{\"type\":\"ObjectExpression\",\"properties\":[]}}],\"kind\":\"var\"},{\"type\":\"ForInStatement\",\"left\":{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"i\"},\"init\":null}],\"kind\":\"var\"},\"right\":{\"type\":\"Identifier\",\"name\":\"obj\"},\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"IfStatement\",\"test\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"keys\"},\"property\":{\"type\":\"Identifier\",\"name\":\"indexOf\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"i\"}]},\"operator\":\">=\",\"right\":{\"type\":\"Literal\",\"value\":0}},\"consequent\":{\"type\":\"ContinueStatement\",\"label\":null},\"alternate\":null},{\"type\":\"IfStatement\",\"test\":{\"type\":\"UnaryExpression\",\"operator\":\"!\",\"prefix\":true,\"argument\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Object\"},\"property\":{\"type\":\"Identifier\",\"name\":\"prototype\"},\"computed\":false},\"property\":{\"type\":\"Identifier\",\"name\":\"hasOwnProperty\"},\"computed\":false},\"property\":{\"type\":\"Identifier\",\"name\":\"call\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"obj\"},{\"type\":\"Identifier\",\"name\":\"i\"}]}},\"consequent\":{\"type\":\"ContinueStatement\",\"label\":null},\"alternate\":null},{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"target\"},\"property\":{\"type\":\"Identifier\",\"name\":\"i\"},\"computed\":true},\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"obj\"},\"property\":{\"type\":\"Identifier\",\"name\":\"i\"},\"computed\":true}}}]}},{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"Identifier\",\"name\":\"target\"}}]},\"parenthesizedExpression\":true}}]},\"helper-self-global\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"ConditionalExpression\",\"test\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"UnaryExpression\",\"operator\":\"typeof\",\"prefix\":true,\"argument\":{\"type\":\"Identifier\",\"name\":\"global\"}},\"operator\":\"===\",\"right\":{\"type\":\"Literal\",\"value\":\"undefined\"}},\"consequent\":{\"type\":\"Identifier\",\"name\":\"self\"},\"alternate\":{\"type\":\"Identifier\",\"name\":\"global\"}}}]},\"helper-set\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"FunctionExpression\",\"id\":{\"type\":\"Identifier\",\"name\":\"set\"},\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"object\"},{\"type\":\"Identifier\",\"name\":\"property\"},{\"type\":\"Identifier\",\"name\":\"value\"},{\"type\":\"Identifier\",\"name\":\"receiver\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"desc\"},\"init\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Object\"},\"property\":{\"type\":\"Identifier\",\"name\":\"getOwnPropertyDescriptor\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"object\"},{\"type\":\"Identifier\",\"name\":\"property\"}]}}],\"kind\":\"var\"},{\"type\":\"IfStatement\",\"test\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"Identifier\",\"name\":\"desc\"},\"operator\":\"===\",\"right\":{\"type\":\"Identifier\",\"name\":\"undefined\"}},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"parent\"},\"init\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Object\"},\"property\":{\"type\":\"Identifier\",\"name\":\"getPrototypeOf\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"object\"}]}}],\"kind\":\"var\"},{\"type\":\"IfStatement\",\"test\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"Identifier\",\"name\":\"parent\"},\"operator\":\"!==\",\"right\":{\"type\":\"Literal\",\"value\":null,\"rawValue\":null}},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"set\"},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"parent\"},{\"type\":\"Identifier\",\"name\":\"property\"},{\"type\":\"Identifier\",\"name\":\"value\"},{\"type\":\"Identifier\",\"name\":\"receiver\"}]}}]},\"alternate\":null}]},\"alternate\":{\"type\":\"IfStatement\",\"test\":{\"type\":\"LogicalExpression\",\"left\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"Literal\",\"value\":\"value\"},\"operator\":\"in\",\"right\":{\"type\":\"Identifier\",\"name\":\"desc\"}},\"operator\":\"&&\",\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"desc\"},\"property\":{\"type\":\"Identifier\",\"name\":\"writable\"},\"computed\":false}},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"desc\"},\"property\":{\"type\":\"Identifier\",\"name\":\"value\"},\"computed\":false},\"right\":{\"type\":\"Identifier\",\"name\":\"value\"}}}]},\"alternate\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"setter\"},\"init\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"desc\"},\"property\":{\"type\":\"Identifier\",\"name\":\"set\"},\"computed\":false}}],\"kind\":\"var\"},{\"type\":\"IfStatement\",\"test\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"Identifier\",\"name\":\"setter\"},\"operator\":\"!==\",\"right\":{\"type\":\"Identifier\",\"name\":\"undefined\"}},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"setter\"},\"property\":{\"type\":\"Identifier\",\"name\":\"call\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"receiver\"},{\"type\":\"Identifier\",\"name\":\"value\"}]}}]},\"alternate\":null}]}}},{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"Identifier\",\"name\":\"value\"}}]},\"parenthesizedExpression\":true}}]},\"helper-slice\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Array\"},\"property\":{\"type\":\"Identifier\",\"name\":\"prototype\"},\"computed\":false},\"property\":{\"type\":\"Identifier\",\"name\":\"slice\"},\"computed\":false}}]},\"helper-sliced-to-array-loose\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"arr\"},{\"type\":\"Identifier\",\"name\":\"i\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"IfStatement\",\"test\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Array\"},\"property\":{\"type\":\"Identifier\",\"name\":\"isArray\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"arr\"}]},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"Identifier\",\"name\":\"arr\"}}]},\"alternate\":{\"type\":\"IfStatement\",\"test\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Symbol\"},\"property\":{\"type\":\"Identifier\",\"name\":\"iterator\"},\"computed\":false},\"operator\":\"in\",\"right\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"Object\"},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"arr\"}]}},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"_arr\"},\"init\":{\"type\":\"ArrayExpression\",\"elements\":[]}}],\"kind\":\"var\"},{\"type\":\"ForStatement\",\"init\":{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"_iterator\"},\"init\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"arr\"},\"property\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Symbol\"},\"property\":{\"type\":\"Identifier\",\"name\":\"iterator\"},\"computed\":false},\"computed\":true},\"arguments\":[]}},{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"_step\"},\"init\":null}],\"kind\":\"var\"},\"test\":{\"type\":\"UnaryExpression\",\"operator\":\"!\",\"prefix\":true,\"argument\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"Identifier\",\"name\":\"_step\"},\"right\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"_iterator\"},\"property\":{\"type\":\"Identifier\",\"name\":\"next\"},\"computed\":false},\"arguments\":[]},\"parenthesizedExpression\":true},\"property\":{\"type\":\"Identifier\",\"name\":\"done\"},\"computed\":false}},\"update\":null,\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"_arr\"},\"property\":{\"type\":\"Identifier\",\"name\":\"push\"},\"computed\":false},\"arguments\":[{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"_step\"},\"property\":{\"type\":\"Identifier\",\"name\":\"value\"},\"computed\":false}]}},{\"type\":\"IfStatement\",\"test\":{\"type\":\"LogicalExpression\",\"left\":{\"type\":\"Identifier\",\"name\":\"i\"},\"operator\":\"&&\",\"right\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"_arr\"},\"property\":{\"type\":\"Identifier\",\"name\":\"length\"},\"computed\":false},\"operator\":\"===\",\"right\":{\"type\":\"Identifier\",\"name\":\"i\"}}},\"consequent\":{\"type\":\"BreakStatement\",\"label\":null},\"alternate\":null}]}},{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"Identifier\",\"name\":\"_arr\"}}]},\"alternate\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ThrowStatement\",\"argument\":{\"type\":\"NewExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"TypeError\"},\"arguments\":[{\"type\":\"Literal\",\"value\":\"Invalid attempt to destructure non-iterable instance\"}]}}]}}}]},\"parenthesizedExpression\":true}}]},\"helper-sliced-to-array\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"FunctionDeclaration\",\"id\":{\"type\":\"Identifier\",\"name\":\"sliceIterator\",\"leadingComments\":null},\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"arr\"},{\"type\":\"Identifier\",\"name\":\"i\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"_arr\",\"leadingComments\":null},\"init\":{\"type\":\"ArrayExpression\",\"elements\":[]},\"leadingComments\":null}],\"kind\":\"var\"},{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"_n\"},\"init\":{\"type\":\"Literal\",\"value\":true}}],\"kind\":\"var\"},{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"_d\"},\"init\":{\"type\":\"Literal\",\"value\":false}}],\"kind\":\"var\"},{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"_e\"},\"init\":{\"type\":\"Identifier\",\"name\":\"undefined\"}}],\"kind\":\"var\"},{\"type\":\"TryStatement\",\"block\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ForStatement\",\"init\":{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"_i\"},\"init\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"arr\"},\"property\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Symbol\"},\"property\":{\"type\":\"Identifier\",\"name\":\"iterator\"},\"computed\":false},\"computed\":true},\"arguments\":[]}},{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"_s\"},\"init\":null}],\"kind\":\"var\"},\"test\":{\"type\":\"UnaryExpression\",\"operator\":\"!\",\"prefix\":true,\"argument\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"Identifier\",\"name\":\"_n\"},\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"Identifier\",\"name\":\"_s\"},\"right\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"_i\"},\"property\":{\"type\":\"Identifier\",\"name\":\"next\"},\"computed\":false},\"arguments\":[]},\"parenthesizedExpression\":true},\"property\":{\"type\":\"Identifier\",\"name\":\"done\"},\"computed\":false},\"parenthesizedExpression\":true}},\"update\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"Identifier\",\"name\":\"_n\"},\"right\":{\"type\":\"Literal\",\"value\":true}},\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"_arr\"},\"property\":{\"type\":\"Identifier\",\"name\":\"push\"},\"computed\":false},\"arguments\":[{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"_s\"},\"property\":{\"type\":\"Identifier\",\"name\":\"value\"},\"computed\":false}]}},{\"type\":\"IfStatement\",\"test\":{\"type\":\"LogicalExpression\",\"left\":{\"type\":\"Identifier\",\"name\":\"i\"},\"operator\":\"&&\",\"right\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"_arr\"},\"property\":{\"type\":\"Identifier\",\"name\":\"length\"},\"computed\":false},\"operator\":\"===\",\"right\":{\"type\":\"Identifier\",\"name\":\"i\"}}},\"consequent\":{\"type\":\"BreakStatement\",\"label\":null},\"alternate\":null}]}}]},\"handler\":{\"type\":\"CatchClause\",\"param\":{\"type\":\"Identifier\",\"name\":\"err\"},\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"Identifier\",\"name\":\"_d\"},\"right\":{\"type\":\"Literal\",\"value\":true}}},{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"Identifier\",\"name\":\"_e\"},\"right\":{\"type\":\"Identifier\",\"name\":\"err\"}}}]}},\"guardedHandlers\":[],\"finalizer\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"TryStatement\",\"block\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"IfStatement\",\"test\":{\"type\":\"LogicalExpression\",\"left\":{\"type\":\"UnaryExpression\",\"operator\":\"!\",\"prefix\":true,\"argument\":{\"type\":\"Identifier\",\"name\":\"_n\"}},\"operator\":\"&&\",\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"_i\"},\"property\":{\"type\":\"Literal\",\"value\":\"return\"},\"computed\":true}},\"consequent\":{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"_i\"},\"property\":{\"type\":\"Literal\",\"value\":\"return\"},\"computed\":true},\"arguments\":[]}},\"alternate\":null}]},\"handler\":null,\"guardedHandlers\":[],\"finalizer\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"IfStatement\",\"test\":{\"type\":\"Identifier\",\"name\":\"_d\"},\"consequent\":{\"type\":\"ThrowStatement\",\"argument\":{\"type\":\"Identifier\",\"name\":\"_e\"}},\"alternate\":null}]}}]}},{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"Identifier\",\"name\":\"_arr\"}}]}},{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"arr\"},{\"type\":\"Identifier\",\"name\":\"i\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"IfStatement\",\"test\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Array\"},\"property\":{\"type\":\"Identifier\",\"name\":\"isArray\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"arr\"}]},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"Identifier\",\"name\":\"arr\"}}]},\"alternate\":{\"type\":\"IfStatement\",\"test\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Symbol\"},\"property\":{\"type\":\"Identifier\",\"name\":\"iterator\"},\"computed\":false},\"operator\":\"in\",\"right\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"Object\"},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"arr\"}]}},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"sliceIterator\"},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"arr\"},{\"type\":\"Identifier\",\"name\":\"i\"}]}}]},\"alternate\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ThrowStatement\",\"argument\":{\"type\":\"NewExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"TypeError\"},\"arguments\":[{\"type\":\"Literal\",\"value\":\"Invalid attempt to destructure non-iterable instance\"}]}}]}}}]}}}]},\"parenthesizedExpression\":true},\"arguments\":[]}}]},\"helper-tagged-template-literal-loose\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"strings\"},{\"type\":\"Identifier\",\"name\":\"raw\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"strings\"},\"property\":{\"type\":\"Identifier\",\"name\":\"raw\"},\"computed\":false},\"right\":{\"type\":\"Identifier\",\"name\":\"raw\"}}},{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"Identifier\",\"name\":\"strings\"}}]},\"parenthesizedExpression\":true}}]},\"helper-tagged-template-literal\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"strings\"},{\"type\":\"Identifier\",\"name\":\"raw\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Object\"},\"property\":{\"type\":\"Identifier\",\"name\":\"freeze\"},\"computed\":false},\"arguments\":[{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Object\"},\"property\":{\"type\":\"Identifier\",\"name\":\"defineProperties\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"strings\"},{\"type\":\"ObjectExpression\",\"properties\":[{\"type\":\"Property\",\"method\":false,\"shorthand\":false,\"computed\":false,\"key\":{\"type\":\"Identifier\",\"name\":\"raw\"},\"value\":{\"type\":\"ObjectExpression\",\"properties\":[{\"type\":\"Property\",\"method\":false,\"shorthand\":false,\"computed\":false,\"key\":{\"type\":\"Identifier\",\"name\":\"value\"},\"value\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Object\"},\"property\":{\"type\":\"Identifier\",\"name\":\"freeze\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"raw\"}]},\"kind\":\"init\"}]},\"kind\":\"init\"}]}]}]}}]},\"parenthesizedExpression\":true}}]},\"helper-temporal-assert-defined\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"val\"},{\"type\":\"Identifier\",\"name\":\"name\"},{\"type\":\"Identifier\",\"name\":\"undef\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"IfStatement\",\"test\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"Identifier\",\"name\":\"val\"},\"operator\":\"===\",\"right\":{\"type\":\"Identifier\",\"name\":\"undef\"}},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ThrowStatement\",\"argument\":{\"type\":\"NewExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"ReferenceError\"},\"arguments\":[{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"Identifier\",\"name\":\"name\"},\"operator\":\"+\",\"right\":{\"type\":\"Literal\",\"value\":\" is not defined - temporal dead zone\"}}]}}]},\"alternate\":null},{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"Literal\",\"value\":true}}]},\"parenthesizedExpression\":true}}]},\"helper-temporal-undefined\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"ObjectExpression\",\"properties\":[],\"parenthesizedExpression\":true}}]},\"helper-to-array\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"arr\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"ConditionalExpression\",\"test\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Array\"},\"property\":{\"type\":\"Identifier\",\"name\":\"isArray\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"arr\"}]},\"consequent\":{\"type\":\"Identifier\",\"name\":\"arr\"},\"alternate\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Array\"},\"property\":{\"type\":\"Identifier\",\"name\":\"from\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"arr\"}]}}}]},\"parenthesizedExpression\":true}}]},\"helper-to-consumable-array\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"arr\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"IfStatement\",\"test\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Array\"},\"property\":{\"type\":\"Identifier\",\"name\":\"isArray\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"arr\"}]},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ForStatement\",\"init\":{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"i\"},\"init\":{\"type\":\"Literal\",\"value\":0}},{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"arr2\"},\"init\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"Array\"},\"arguments\":[{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"arr\"},\"property\":{\"type\":\"Identifier\",\"name\":\"length\"},\"computed\":false}]}}],\"kind\":\"var\"},\"test\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"Identifier\",\"name\":\"i\"},\"operator\":\"<\",\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"arr\"},\"property\":{\"type\":\"Identifier\",\"name\":\"length\"},\"computed\":false}},\"update\":{\"type\":\"UpdateExpression\",\"operator\":\"++\",\"prefix\":false,\"argument\":{\"type\":\"Identifier\",\"name\":\"i\"}},\"body\":{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"arr2\"},\"property\":{\"type\":\"Identifier\",\"name\":\"i\"},\"computed\":true},\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"arr\"},\"property\":{\"type\":\"Identifier\",\"name\":\"i\"},\"computed\":true}}}},{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"Identifier\",\"name\":\"arr2\"}}]},\"alternate\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Array\"},\"property\":{\"type\":\"Identifier\",\"name\":\"from\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"arr\"}]}}]}}]},\"parenthesizedExpression\":true}}]},\"helper-typeof-react-element\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"LogicalExpression\",\"left\":{\"type\":\"LogicalExpression\",\"left\":{\"type\":\"LogicalExpression\",\"left\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"UnaryExpression\",\"operator\":\"typeof\",\"prefix\":true,\"argument\":{\"type\":\"Identifier\",\"name\":\"Symbol\"}},\"operator\":\"===\",\"right\":{\"type\":\"Literal\",\"value\":\"function\"}},\"operator\":\"&&\",\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Symbol\"},\"property\":{\"type\":\"Literal\",\"value\":\"for\"},\"computed\":true}},\"operator\":\"&&\",\"right\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"Symbol\"},\"property\":{\"type\":\"Literal\",\"value\":\"for\"},\"computed\":true},\"arguments\":[{\"type\":\"Literal\",\"value\":\"react.element\"}]}},\"operator\":\"||\",\"right\":{\"type\":\"Literal\",\"value\":60103}}}]},\"helper-typeof\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"obj\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"ConditionalExpression\",\"test\":{\"type\":\"LogicalExpression\",\"left\":{\"type\":\"Identifier\",\"name\":\"obj\"},\"operator\":\"&&\",\"right\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"obj\"},\"property\":{\"type\":\"Identifier\",\"name\":\"constructor\"},\"computed\":false},\"operator\":\"===\",\"right\":{\"type\":\"Identifier\",\"name\":\"Symbol\"}}},\"consequent\":{\"type\":\"Literal\",\"value\":\"symbol\"},\"alternate\":{\"type\":\"UnaryExpression\",\"operator\":\"typeof\",\"prefix\":true,\"argument\":{\"type\":\"Identifier\",\"name\":\"obj\"}}}}]},\"parenthesizedExpression\":true}}]},\"let-scoping-return\":{\"type\":\"Program\",\"body\":[{\"type\":\"IfStatement\",\"test\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"UnaryExpression\",\"operator\":\"typeof\",\"prefix\":true,\"argument\":{\"type\":\"Identifier\",\"name\":\"RETURN\"}},\"operator\":\"===\",\"right\":{\"type\":\"Literal\",\"value\":\"object\"}},\"consequent\":{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"RETURN\"},\"property\":{\"type\":\"Identifier\",\"name\":\"v\"},\"computed\":false}},\"alternate\":null}]},\"named-function\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"FunctionDeclaration\",\"id\":{\"type\":\"Identifier\",\"name\":\"GET_OUTER_ID\"},\"generator\":false,\"expression\":false,\"params\":[],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"Identifier\",\"name\":\"FUNCTION_ID\"}}]}},{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"Identifier\",\"name\":\"FUNCTION\"}}]},\"parenthesizedExpression\":true},\"arguments\":[]}}]},\"property-method-assignment-wrapper-generator\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"FUNCTION_KEY\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"FunctionDeclaration\",\"id\":{\"type\":\"Identifier\",\"name\":\"FUNCTION_ID\"},\"generator\":true,\"expression\":false,\"params\":[],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"YieldExpression\",\"delegate\":true,\"argument\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"FUNCTION_KEY\"},\"property\":{\"type\":\"Identifier\",\"name\":\"apply\"},\"computed\":false},\"arguments\":[{\"type\":\"ThisExpression\"},{\"type\":\"Identifier\",\"name\":\"arguments\"}]}}}]}},{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"FUNCTION_ID\"},\"property\":{\"type\":\"Identifier\",\"name\":\"toString\"},\"computed\":false},\"right\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"FUNCTION_KEY\"},\"property\":{\"type\":\"Identifier\",\"name\":\"toString\"},\"computed\":false},\"arguments\":[]}}]}}}},{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"Identifier\",\"name\":\"FUNCTION_ID\"}}]},\"parenthesizedExpression\":true},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"FUNCTION\"}]}}]},\"property-method-assignment-wrapper\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"FUNCTION_KEY\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"FunctionDeclaration\",\"id\":{\"type\":\"Identifier\",\"name\":\"FUNCTION_ID\"},\"generator\":false,\"expression\":false,\"params\":[],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"FUNCTION_KEY\"},\"property\":{\"type\":\"Identifier\",\"name\":\"apply\"},\"computed\":false},\"arguments\":[{\"type\":\"ThisExpression\"},{\"type\":\"Identifier\",\"name\":\"arguments\"}]}}]}},{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"FUNCTION_ID\"},\"property\":{\"type\":\"Identifier\",\"name\":\"toString\"},\"computed\":false},\"right\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"FUNCTION_KEY\"},\"property\":{\"type\":\"Identifier\",\"name\":\"toString\"},\"computed\":false},\"arguments\":[]}}]}}}},{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"Identifier\",\"name\":\"FUNCTION_ID\"}}]},\"parenthesizedExpression\":true},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"FUNCTION\"}]}}]},\"prototype-identifier\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"CLASS_NAME\"},\"property\":{\"type\":\"Identifier\",\"name\":\"prototype\"},\"computed\":false}}]},\"require-assign-key\":{\"type\":\"Program\",\"body\":[{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"VARIABLE_NAME\"},\"init\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"require\"},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"MODULE_NAME\"}]},\"property\":{\"type\":\"Identifier\",\"name\":\"KEY\"},\"computed\":false}}],\"kind\":\"var\"}]},\"require\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"require\"},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"MODULE_NAME\"}]}}]},\"rest\":{\"type\":\"Program\",\"body\":[{\"type\":\"ForStatement\",\"init\":{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"LEN\"},\"init\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"ARGUMENTS\"},\"property\":{\"type\":\"Identifier\",\"name\":\"length\"},\"computed\":false}},{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"ARRAY\"},\"init\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"Array\"},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"ARRAY_LEN\"}]}},{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"KEY\"},\"init\":{\"type\":\"Identifier\",\"name\":\"START\"}}],\"kind\":\"var\"},\"test\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"Identifier\",\"name\":\"KEY\"},\"operator\":\"<\",\"right\":{\"type\":\"Identifier\",\"name\":\"LEN\"}},\"update\":{\"type\":\"UpdateExpression\",\"operator\":\"++\",\"prefix\":false,\"argument\":{\"type\":\"Identifier\",\"name\":\"KEY\"}},\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"ARRAY\"},\"property\":{\"type\":\"Identifier\",\"name\":\"ARRAY_KEY\"},\"computed\":true},\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"ARGUMENTS\"},\"property\":{\"type\":\"Identifier\",\"name\":\"KEY\"},\"computed\":true}}}]}}]},\"self-contained-helpers-head\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"exports\"},\"property\":{\"type\":\"Literal\",\"value\":\"default\"},\"computed\":true},\"right\":{\"type\":\"Identifier\",\"name\":\"HELPER\"}}},{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"exports\"},\"property\":{\"type\":\"Identifier\",\"name\":\"__esModule\"},\"computed\":false},\"right\":{\"type\":\"Literal\",\"value\":true}}}]},\"system\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"System\"},\"property\":{\"type\":\"Identifier\",\"name\":\"register\"},\"computed\":false},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"MODULE_NAME\"},{\"type\":\"Identifier\",\"name\":\"MODULE_DEPENDENCIES\"},{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"EXPORT_IDENTIFIER\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ReturnStatement\",\"argument\":{\"type\":\"ObjectExpression\",\"properties\":[{\"type\":\"Property\",\"method\":false,\"shorthand\":false,\"computed\":false,\"key\":{\"type\":\"Identifier\",\"name\":\"setters\"},\"value\":{\"type\":\"Identifier\",\"name\":\"SETTERS\"},\"kind\":\"init\"},{\"type\":\"Property\",\"method\":false,\"shorthand\":false,\"computed\":false,\"key\":{\"type\":\"Identifier\",\"name\":\"execute\"},\"value\":{\"type\":\"Identifier\",\"name\":\"EXECUTE\"},\"kind\":\"init\"}]}}]}}]}}]},\"tail-call-body\":{\"type\":\"Program\",\"body\":[{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"AGAIN_ID\"},\"init\":{\"type\":\"Literal\",\"value\":true}}],\"kind\":\"var\"},{\"type\":\"LabeledStatement\",\"body\":{\"type\":\"WhileStatement\",\"test\":{\"type\":\"Identifier\",\"name\":\"AGAIN_ID\"},\"body\":{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"Identifier\",\"name\":\"BLOCK\"}}},\"label\":{\"type\":\"Identifier\",\"name\":\"FUNCTION_ID\"}}]}]},\"test-exports\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"UnaryExpression\",\"operator\":\"typeof\",\"prefix\":true,\"argument\":{\"type\":\"Identifier\",\"name\":\"exports\"}},\"operator\":\"!==\",\"right\":{\"type\":\"Literal\",\"value\":\"undefined\"}}}]},\"test-module\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"UnaryExpression\",\"operator\":\"typeof\",\"prefix\":true,\"argument\":{\"type\":\"Identifier\",\"name\":\"module\"}},\"operator\":\"!==\",\"right\":{\"type\":\"Literal\",\"value\":\"undefined\"}}}]},\"umd-commonjs-strict\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"root\"},{\"type\":\"Identifier\",\"name\":\"factory\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"IfStatement\",\"test\":{\"type\":\"LogicalExpression\",\"left\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"UnaryExpression\",\"operator\":\"typeof\",\"prefix\":true,\"argument\":{\"type\":\"Identifier\",\"name\":\"define\"}},\"operator\":\"===\",\"right\":{\"type\":\"Literal\",\"value\":\"function\"}},\"operator\":\"&&\",\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"define\"},\"property\":{\"type\":\"Identifier\",\"name\":\"amd\"},\"computed\":false}},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"define\"},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"AMD_ARGUMENTS\"},{\"type\":\"Identifier\",\"name\":\"factory\"}]}}]},\"alternate\":{\"type\":\"IfStatement\",\"test\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"UnaryExpression\",\"operator\":\"typeof\",\"prefix\":true,\"argument\":{\"type\":\"Identifier\",\"name\":\"exports\"}},\"operator\":\"===\",\"right\":{\"type\":\"Literal\",\"value\":\"object\"}},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"factory\"},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"COMMON_ARGUMENTS\"}]}}]},\"alternate\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"factory\"},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"BROWSER_ARGUMENTS\"}]}}]}}}]},\"parenthesizedExpression\":true},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"UMD_ROOT\"},{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"FACTORY_PARAMETERS\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"Identifier\",\"name\":\"FACTORY_BODY\"}}]}}]}}]},\"umd-runner-body\":{\"type\":\"Program\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"FunctionExpression\",\"id\":null,\"generator\":false,\"expression\":false,\"params\":[{\"type\":\"Identifier\",\"name\":\"global\"},{\"type\":\"Identifier\",\"name\":\"factory\"}],\"body\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"IfStatement\",\"test\":{\"type\":\"LogicalExpression\",\"left\":{\"type\":\"BinaryExpression\",\"left\":{\"type\":\"UnaryExpression\",\"operator\":\"typeof\",\"prefix\":true,\"argument\":{\"type\":\"Identifier\",\"name\":\"define\"}},\"operator\":\"===\",\"right\":{\"type\":\"Literal\",\"value\":\"function\"}},\"operator\":\"&&\",\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"define\"},\"property\":{\"type\":\"Identifier\",\"name\":\"amd\"},\"computed\":false}},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"define\"},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"AMD_ARGUMENTS\"},{\"type\":\"Identifier\",\"name\":\"factory\"}]}}]},\"alternate\":{\"type\":\"IfStatement\",\"test\":{\"type\":\"Identifier\",\"name\":\"COMMON_TEST\"},\"consequent\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"factory\"},\"arguments\":[{\"type\":\"Identifier\",\"name\":\"COMMON_ARGUMENTS\"}]}}]},\"alternate\":{\"type\":\"BlockStatement\",\"body\":[{\"type\":\"VariableDeclaration\",\"declarations\":[{\"type\":\"VariableDeclarator\",\"id\":{\"type\":\"Identifier\",\"name\":\"mod\"},\"init\":{\"type\":\"ObjectExpression\",\"properties\":[{\"type\":\"Property\",\"method\":false,\"shorthand\":false,\"computed\":false,\"key\":{\"type\":\"Identifier\",\"name\":\"exports\"},\"value\":{\"type\":\"ObjectExpression\",\"properties\":[]},\"kind\":\"init\"}]}}],\"kind\":\"var\"},{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"CallExpression\",\"callee\":{\"type\":\"Identifier\",\"name\":\"factory\"},\"arguments\":[{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"mod\"},\"property\":{\"type\":\"Identifier\",\"name\":\"exports\"},\"computed\":false},{\"type\":\"Identifier\",\"name\":\"BROWSER_ARGUMENTS\"}]}},{\"type\":\"ExpressionStatement\",\"expression\":{\"type\":\"AssignmentExpression\",\"operator\":\"=\",\"left\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"global\"},\"property\":{\"type\":\"Identifier\",\"name\":\"GLOBAL_ARG\"},\"computed\":false},\"right\":{\"type\":\"MemberExpression\",\"object\":{\"type\":\"Identifier\",\"name\":\"mod\"},\"property\":{\"type\":\"Identifier\",\"name\":\"exports\"},\"computed\":false}}}]}}}]},\"parenthesizedExpression\":true}}]}}","/**\n * This class is responsible for a binding inside of a scope.\n *\n * It tracks the following:\n *\n *  * Node path.\n *  * Amount of times referenced by other nodes.\n *  * Paths to nodes that reassign or modify this binding.\n *  * The kind of binding. (Is it a parameter, declaration etc)\n */\n\n\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Binding = (function () {\n  function Binding(_ref) {\n    var existing = _ref.existing;\n    var identifier = _ref.identifier;\n    var scope = _ref.scope;\n    var path = _ref.path;\n    var kind = _ref.kind;\n\n    _classCallCheck(this, Binding);\n\n    this.constantViolations = [];\n    this.constant = true;\n\n    this.identifier = identifier;\n    this.references = 0;\n    this.referenced = false;\n\n    this.scope = scope;\n    this.path = path;\n    this.kind = kind;\n\n    this.hasValue = false;\n    this.hasDeoptedValue = false;\n    this.value = null;\n\n    this.clearValue();\n\n    if (existing) {\n      this.constantViolations = [].concat(existing.path, existing.constantViolations, this.constantViolations);\n    }\n  }\n\n  /**\n   * [Please add a description.]\n   */\n\n  Binding.prototype.deoptValue = function deoptValue() {\n    this.clearValue();\n    this.hasDeoptedValue = true;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Binding.prototype.setValue = function setValue(value) {\n    if (this.hasDeoptedValue) return;\n    this.hasValue = true;\n    this.value = value;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Binding.prototype.clearValue = function clearValue() {\n    this.hasDeoptedValue = false;\n    this.hasValue = false;\n    this.value = null;\n  };\n\n  /**\n   * Register a constant violation with the provided `path`.\n   */\n\n  Binding.prototype.reassign = function reassign(path) {\n    this.constant = false;\n    this.constantViolations.push(path);\n  };\n\n  /**\n   * Increment the amount of references to this binding.\n   */\n\n  Binding.prototype.reference = function reference() {\n    this.referenced = true;\n    this.references++;\n  };\n\n  /**\n   * Decrement the amount of references to this binding.\n   */\n\n  Binding.prototype.dereference = function dereference() {\n    this.references--;\n    this.referenced = !!this.references;\n  };\n\n  return Binding;\n})();\n\nexports[\"default\"] = Binding;\nmodule.exports = exports[\"default\"];","/**\n * Create an object with a `null` prototype.\n */\n\n\n\nexports.__esModule = true;\n\nexports[\"default\"] = function () {\n  return Object.create(null);\n};\n\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\nexports.findParent = findParent;\nexports.getFunctionParent = getFunctionParent;\nexports.getStatementParent = getStatementParent;\nexports.getEarliestCommonAncestorFrom = getEarliestCommonAncestorFrom;\nexports.getDeepestCommonAncestorFrom = getDeepestCommonAncestorFrom;\nexports.getAncestry = getAncestry;\nexports.inType = inType;\nexports.inShadow = inShadow;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\nvar _index = require(\"./index\");\n\nvar _index2 = _interopRequireDefault(_index);\n\n/**\n * Call the provided `callback` with the `NodePath`s of all the parents.\n * When the `callback` returns a truthy value, we return that node path.\n */\n\nfunction findParent(callback) {\n  var path = this;\n  while (path = path.parentPath) {\n    if (callback(path)) return path;\n  }\n  return null;\n}\n\n/**\n * Get the parent function of the current path.\n */\n\nfunction getFunctionParent() {\n  return this.findParent(function (path) {\n    return path.isFunction() || path.isProgram();\n  });\n}\n\n/**\n * Walk up the tree until we hit a parent node path in a list.\n */\n\nfunction getStatementParent() {\n  var path = this;\n  do {\n    if (Array.isArray(path.container)) {\n      return path;\n    }\n  } while (path = path.parentPath);\n}\n\n/**\n * Get the deepest common ancestor and then from it, get the earliest relationship path\n * to that ancestor.\n *\n * Earliest is defined as being \"before\" all the other nodes in terms of list container\n * position and visiting key.\n */\n\nfunction getEarliestCommonAncestorFrom(paths) {\n  return this.getDeepestCommonAncestorFrom(paths, function (deepest, i, ancestries) {\n    var earliest;\n    var keys = t.VISITOR_KEYS[deepest.type];\n\n    var _arr = ancestries;\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var ancestry = _arr[_i];\n      var path = ancestry[i + 1];\n\n      // first path\n      if (!earliest) {\n        earliest = path;\n        continue;\n      }\n\n      // handle containers\n      if (path.listKey && earliest.listKey === path.listKey) {\n        // we're in the same container so check if we're earlier\n        if (path.key < earliest.key) {\n          earliest = path;\n          continue;\n        }\n      }\n\n      // handle keys\n      var earliestKeyIndex = keys.indexOf(earliest.parentKey);\n      var currentKeyIndex = keys.indexOf(path.parentKey);\n      if (earliestKeyIndex > currentKeyIndex) {\n        // key appears before so it's earlier\n        earliest = path;\n      }\n    }\n\n    return earliest;\n  });\n}\n\n/**\n * Get the earliest path in the tree where the provided `paths` intersect.\n *\n * TODO: Possible optimisation target.\n */\n\nfunction getDeepestCommonAncestorFrom(paths, filter) {\n  // istanbul ignore next\n\n  var _this = this;\n\n  if (!paths.length) {\n    return this;\n  }\n\n  if (paths.length === 1) {\n    return paths[0];\n  }\n\n  // minimum depth of the tree so we know the highest node\n  var minDepth = Infinity;\n\n  // last common ancestor\n  var lastCommonIndex, lastCommon;\n\n  // get the ancestors of the path, breaking when the parent exceeds ourselves\n  var ancestries = paths.map(function (path) {\n    var ancestry = [];\n\n    do {\n      ancestry.unshift(path);\n    } while ((path = path.parentPath) && path !== _this);\n\n    // save min depth to avoid going too far in\n    if (ancestry.length < minDepth) {\n      minDepth = ancestry.length;\n    }\n\n    return ancestry;\n  });\n\n  // get the first ancestry so we have a seed to assess all other ancestries with\n  var first = ancestries[0];\n\n  // check ancestor equality\n  depthLoop: for (var i = 0; i < minDepth; i++) {\n    var shouldMatch = first[i];\n\n    var _arr2 = ancestries;\n    for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n      var ancestry = _arr2[_i2];\n      if (ancestry[i] !== shouldMatch) {\n        // we've hit a snag\n        break depthLoop;\n      }\n    }\n\n    // next iteration may break so store these so they can be returned\n    lastCommonIndex = i;\n    lastCommon = shouldMatch;\n  }\n\n  if (lastCommon) {\n    if (filter) {\n      return filter(lastCommon, lastCommonIndex, ancestries);\n    } else {\n      return lastCommon;\n    }\n  } else {\n    throw new Error(\"Couldn't find intersection\");\n  }\n}\n\n/**\n * Build an array of node paths containing the entire ancestry of the current node path.\n *\n * NOTE: The current node path is included in this.\n */\n\nfunction getAncestry() {\n  var path = this;\n  var paths = [];\n  do {\n    paths.push(path);\n  } while (path = path.parentPath);\n  return paths;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction inType() {\n  var path = this;\n  while (path) {\n    var _arr3 = arguments;\n\n    for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n      var type = _arr3[_i3];\n      if (path.node.type === type) return true;\n    }\n    path = path.parentPath;\n  }\n\n  return false;\n}\n\n/**\n * Check if we're inside a shadowed function.\n */\n\nfunction inShadow(key) {\n  var path = this;\n  do {\n    if (path.isFunction()) {\n      var shadow = path.node.shadow;\n      if (shadow) {\n        // this is because sometimes we may have a `shadow` value of:\n        //\n        //   { this: false }\n        //\n        // we need to catch this case if `inShadow` has been passed a `key`\n        if (!key || shadow[key] !== false) {\n          return path;\n        }\n      } else if (path.isArrowFunctionExpression()) {\n        return path;\n      }\n\n      // normal function, we've found our function context\n      return null;\n    }\n  } while (path = path.parentPath);\n  return null;\n}","\n\nexports.__esModule = true;\nexports.getTypeAnnotation = getTypeAnnotation;\nexports._getTypeAnnotation = _getTypeAnnotation;\nexports.isBaseType = isBaseType;\nexports.couldBeBaseType = couldBeBaseType;\nexports.baseTypeStrictlyMatches = baseTypeStrictlyMatches;\nexports.isGenericType = isGenericType;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _inferers = require(\"./inferers\");\n\nvar inferers = _interopRequireWildcard(_inferers);\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * Infer the type of the current `NodePath`.\n */\n\nfunction getTypeAnnotation() {\n  if (this.typeAnnotation) return this.typeAnnotation;\n\n  var type = this._getTypeAnnotation() || t.anyTypeAnnotation();\n  if (t.isTypeAnnotation(type)) type = type.typeAnnotation;\n  return this.typeAnnotation = type;\n}\n\n/**\n * todo: split up this method\n */\n\nfunction _getTypeAnnotation() {\n  var node = this.node;\n\n  if (!node) {\n    // handle initializerless variables, add in checks for loop initializers too\n    if (this.key === \"init\" && this.parentPath.isVariableDeclarator()) {\n      var declar = this.parentPath.parentPath;\n      var declarParent = declar.parentPath;\n\n      // for (var NODE in bar) {}\n      if (declar.key === \"left\" && declarParent.isForInStatement()) {\n        return t.stringTypeAnnotation();\n      }\n\n      // for (var NODE of bar) {}\n      if (declar.key === \"left\" && declarParent.isForOfStatement()) {\n        return t.anyTypeAnnotation();\n      }\n\n      return t.voidTypeAnnotation();\n    } else {\n      return;\n    }\n  }\n\n  if (node.typeAnnotation) {\n    return node.typeAnnotation;\n  }\n\n  var inferer = inferers[node.type];\n  if (inferer) {\n    return inferer.call(this, node);\n  }\n\n  inferer = inferers[this.parentPath.type];\n  if (inferer && inferer.validParent) {\n    return this.parentPath.getTypeAnnotation();\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction isBaseType(baseName, soft) {\n  return _isBaseType(baseName, this.getTypeAnnotation(), soft);\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction _isBaseType(baseName, type, soft) {\n  if (baseName === \"string\") {\n    return t.isStringTypeAnnotation(type);\n  } else if (baseName === \"number\") {\n    return t.isNumberTypeAnnotation(type);\n  } else if (baseName === \"boolean\") {\n    return t.isBooleanTypeAnnotation(type);\n  } else if (baseName === \"any\") {\n    return t.isAnyTypeAnnotation(type);\n  } else if (baseName === \"mixed\") {\n    return t.isMixedTypeAnnotation(type);\n  } else if (baseName === \"void\") {\n    return t.isVoidTypeAnnotation(type);\n  } else {\n    if (soft) {\n      return false;\n    } else {\n      throw new Error(\"Unknown base type \" + baseName);\n    }\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction couldBeBaseType(name) {\n  var type = this.getTypeAnnotation();\n  if (t.isAnyTypeAnnotation(type)) return true;\n\n  if (t.isUnionTypeAnnotation(type)) {\n    var _arr = type.types;\n\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var type2 = _arr[_i];\n      if (t.isAnyTypeAnnotation(type2) || _isBaseType(name, type2, true)) {\n        return true;\n      }\n    }\n    return false;\n  } else {\n    return _isBaseType(name, type, true);\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction baseTypeStrictlyMatches(right) {\n  var left = this.getTypeAnnotation();\n  right = right.getTypeAnnotation();\n\n  if (!t.isAnyTypeAnnotation() && t.isFlowBaseAnnotation(left)) {\n    return right.type === left.type;\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction isGenericType(genericName) {\n  var type = this.getTypeAnnotation();\n  return t.isGenericTypeAnnotation(type) && t.isIdentifier(type.id, { name: genericName });\n}","\n\nexports.__esModule = true;\nexports.VariableDeclarator = VariableDeclarator;\nexports.TypeCastExpression = TypeCastExpression;\nexports.NewExpression = NewExpression;\nexports.TemplateLiteral = TemplateLiteral;\nexports.UnaryExpression = UnaryExpression;\nexports.BinaryExpression = BinaryExpression;\nexports.LogicalExpression = LogicalExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.Literal = Literal;\nexports.ObjectExpression = ObjectExpression;\nexports.ArrayExpression = ArrayExpression;\nexports.RestElement = RestElement;\nexports.CallExpression = CallExpression;\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\n// istanbul ignore next\n\nfunction _interopRequire(obj) { return obj && obj.__esModule ? obj[\"default\"] : obj; }\n\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\nvar _infererReference = require(\"./inferer-reference\");\n\nexports.Identifier = _interopRequire(_infererReference);\n\n/**\n * [Please add a description.]\n */\n\nfunction VariableDeclarator() {\n  var id = this.get(\"id\");\n\n  if (id.isIdentifier()) {\n    return this.get(\"init\").getTypeAnnotation();\n  } else {\n    return;\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction TypeCastExpression(node) {\n  return node.typeAnnotation;\n}\n\nTypeCastExpression.validParent = true;\n\n/**\n * [Please add a description.]\n */\n\nfunction NewExpression(node) {\n  if (this.get(\"callee\").isIdentifier()) {\n    // only resolve identifier callee\n    return t.genericTypeAnnotation(node.callee);\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction TemplateLiteral() {\n  return t.stringTypeAnnotation();\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction UnaryExpression(node) {\n  var operator = node.operator;\n\n  if (operator === \"void\") {\n    return t.voidTypeAnnotation();\n  } else if (t.NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.numberTypeAnnotation();\n  } else if (t.STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.stringTypeAnnotation();\n  } else if (t.BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.booleanTypeAnnotation();\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction BinaryExpression(node) {\n  var operator = node.operator;\n\n  if (t.NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.numberTypeAnnotation();\n  } else if (t.BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return t.booleanTypeAnnotation();\n  } else if (operator === \"+\") {\n    var right = this.get(\"right\");\n    var left = this.get(\"left\");\n\n    if (left.isBaseType(\"number\") && right.isBaseType(\"number\")) {\n      // both numbers so this will be a number\n      return t.numberTypeAnnotation();\n    } else if (left.isBaseType(\"string\") || right.isBaseType(\"string\")) {\n      // one is a string so the result will be a string\n      return t.stringTypeAnnotation();\n    }\n\n    // unsure if left and right are strings or numbers so stay on the safe side\n    return t.unionTypeAnnotation([t.stringTypeAnnotation(), t.numberTypeAnnotation()]);\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction LogicalExpression() {\n  return t.createUnionTypeAnnotation([this.get(\"left\").getTypeAnnotation(), this.get(\"right\").getTypeAnnotation()]);\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction ConditionalExpression() {\n  return t.createUnionTypeAnnotation([this.get(\"consequent\").getTypeAnnotation(), this.get(\"alternate\").getTypeAnnotation()]);\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction SequenceExpression() {\n  return this.get(\"expressions\").pop().getTypeAnnotation();\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction AssignmentExpression() {\n  return this.get(\"right\").getTypeAnnotation();\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction UpdateExpression(node) {\n  var operator = node.operator;\n  if (operator === \"++\" || operator === \"--\") {\n    return t.numberTypeAnnotation();\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction Literal(node) {\n  var value = node.value;\n  if (typeof value === \"string\") return t.stringTypeAnnotation();\n  if (typeof value === \"number\") return t.numberTypeAnnotation();\n  if (typeof value === \"boolean\") return t.booleanTypeAnnotation();\n  if (value === null) return t.voidTypeAnnotation();\n  if (node.regex) return t.genericTypeAnnotation(t.identifier(\"RegExp\"));\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction ObjectExpression() {\n  return t.genericTypeAnnotation(t.identifier(\"Object\"));\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction ArrayExpression() {\n  return t.genericTypeAnnotation(t.identifier(\"Array\"));\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction RestElement() {\n  return ArrayExpression();\n}\n\nRestElement.validParent = true;\n\n/**\n * [Please add a description.]\n */\n\nfunction Func() {\n  return t.genericTypeAnnotation(t.identifier(\"Function\"));\n}\n\nexports.Function = Func;\nexports.Class = Func;\n\n/**\n * [Please add a description.]\n */\n\nfunction CallExpression() {\n  return resolveCall(this.get(\"callee\"));\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction TaggedTemplateExpression() {\n  return resolveCall(this.get(\"tag\"));\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction resolveCall(callee) {\n  callee = callee.resolve();\n\n  if (callee.isFunction()) {\n    if (callee.is(\"async\")) {\n      if (callee.is(\"generator\")) {\n        return t.genericTypeAnnotation(t.identifier(\"AsyncIterator\"));\n      } else {\n        return t.genericTypeAnnotation(t.identifier(\"Promise\"));\n      }\n    } else {\n      if (callee.node.returnType) {\n        return callee.node.returnType;\n      } else {\n        // todo: get union type of all return arguments\n      }\n    }\n  }\n}","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nexports[\"default\"] = function (node) {\n  if (!this.isReferenced()) return;\n\n  // check if a binding exists of this value and if so then return a union type of all\n  // possible types that the binding could be\n  var binding = this.scope.getBinding(node.name);\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(this, node.name);\n    }\n  }\n\n  // built-in values\n  if (node.name === \"undefined\") {\n    return t.voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return t.numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {\n    // todo\n  }\n};\n\n/**\n * [Please add a description.]\n */\n\nfunction getTypeAnnotationBindingConstantViolations(path, name) {\n  var binding = path.scope.getBinding(name);\n\n  var types = [];\n  path.typeAnnotation = t.unionTypeAnnotation(types);\n\n  var functionConstantViolations = [];\n  var constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n\n  var testType = getConditionalAnnotation(path, name);\n  if (testType) {\n    var testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n\n    // remove constant violations observed before the IfStatement\n    constantViolations = constantViolations.filter(function (path) {\n      return testConstantViolations.indexOf(path) < 0;\n    });\n\n    // clear current types and add in observed test type\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    // pick one constant from each scope which will represent the last possible\n    // control flow path that it could've taken/been\n    var rawConstantViolations = constantViolations.reverse();\n    var visitedScopes = [];\n    constantViolations = [];\n    var _arr = rawConstantViolations;\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var violation = _arr[_i];\n      var violationScope = violation.scope;\n      if (visitedScopes.indexOf(violationScope) >= 0) continue;\n\n      visitedScopes.push(violationScope);\n      constantViolations.push(violation);\n\n      if (violationScope === path.scope) {\n        constantViolations = [violation];\n        break;\n      }\n    }\n\n    // add back on function constant violations since we can't track calls\n    constantViolations = constantViolations.concat(functionConstantViolations);\n\n    // push on inferred types of violated paths\n    var _arr2 = constantViolations;\n    for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n      var violation = _arr2[_i2];\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (types.length) {\n    return t.createUnionTypeAnnotation(types);\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction getConstantViolationsBefore(binding, path, functions) {\n  var violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(function (violation) {\n    violation = violation.resolve();\n    var status = violation._guessExecutionStatusRelativeTo(path);\n    if (functions && status === \"function\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  var operator = path.node.operator;\n\n  var right = path.get(\"right\").resolve();\n  var left = path.get(\"left\").resolve();\n\n  var target;\n  if (left.isIdentifier({ name: name })) {\n    target = right;\n  } else if (right.isIdentifier({ name: name })) {\n    target = left;\n  }\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    } else if (t.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return t.numberTypeAnnotation();\n    } else {\n      return;\n    }\n  } else {\n    if (operator !== \"===\") return;\n  }\n\n  //\n  var typeofPath;\n  var typePath;\n  if (left.isUnaryExpression({ operator: \"typeof\" })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({ operator: \"typeof\" })) {\n    typeofPath = right;\n    typePath = left;\n  }\n  if (!typePath && !typeofPath) return;\n\n  // ensure that the type path is a Literal\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n\n  // and that it's a string so we can infer it\n  var typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n\n  // and that the argument of the typeof path references us!\n  if (!typeofPath.get(\"argument\").isIdentifier({ name: name })) return;\n\n  // turn type value into a type annotation\n  return t.createTypeAnnotationBasedOnTypeof(typePath.node.value);\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction getParentConditionalPath(path) {\n  var parentPath;\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      } else {\n        return parentPath;\n      }\n    } else {\n      path = parentPath;\n    }\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction getConditionalAnnotation(path, name) {\n  var ifStatement = getParentConditionalPath(path);\n  if (!ifStatement) return;\n\n  var test = ifStatement.get(\"test\");\n  var paths = [test];\n  var types = [];\n\n  do {\n    var _path = paths.shift().resolve();\n\n    if (_path.isLogicalExpression()) {\n      paths.push(_path.get(\"left\"));\n      paths.push(_path.get(\"right\"));\n    }\n\n    if (_path.isBinaryExpression()) {\n      var type = inferAnnotationFromBinaryExpression(name, _path);\n      if (type) types.push(type);\n    }\n  } while (paths.length);\n\n  if (types.length) {\n    return {\n      typeAnnotation: t.createUnionTypeAnnotation(types),\n      ifStatement: ifStatement\n    };\n  } else {\n    return getConditionalAnnotation(ifStatement, name);\n  }\n}\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\nexports.replaceWithMultiple = replaceWithMultiple;\nexports.replaceWithSourceString = replaceWithSourceString;\nexports.replaceWith = replaceWith;\nexports.replaceExpressionWithStatements = replaceExpressionWithStatements;\nexports.replaceInline = replaceInline;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _helpersCodeFrame = require(\"../../helpers/code-frame\");\n\nvar _helpersCodeFrame2 = _interopRequireDefault(_helpersCodeFrame);\n\nvar _index = require(\"../index\");\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _index3 = require(\"./index\");\n\nvar _index4 = _interopRequireDefault(_index3);\n\nvar _helpersParse = require(\"../../helpers/parse\");\n\nvar _helpersParse2 = _interopRequireDefault(_helpersParse);\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nvar hoistVariablesVisitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  Function: function Function() {\n    this.skip();\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  VariableDeclaration: function VariableDeclaration(node, parent, scope) {\n    if (node.kind !== \"var\") return;\n\n    var bindings = this.getBindingIdentifiers();\n    for (var key in bindings) {\n      scope.push({ id: bindings[key] });\n    }\n\n    var exprs = [];\n\n    var _arr = node.declarations;\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var declar = _arr[_i];\n      if (declar.init) {\n        exprs.push(t.expressionStatement(t.assignmentExpression(\"=\", declar.id, declar.init)));\n      }\n    }\n\n    return exprs;\n  }\n};\n\n/**\n * Replace a node with an array of multiple. This method performs the following steps:\n *\n *  - Inherit the comments of first provided node with that of the current node.\n *  - Insert the provided nodes after the current node.\n *  - Remove the current node.\n */\n\nfunction replaceWithMultiple(nodes) {\n  this.resync();\n\n  nodes = this._verifyNodeList(nodes);\n  t.inheritLeadingComments(nodes[0], this.node);\n  t.inheritTrailingComments(nodes[nodes.length - 1], this.node);\n  this.node = this.container[this.key] = null;\n  this.insertAfter(nodes);\n  if (!this.node) this.dangerouslyRemove();\n}\n\n/**\n * Parse a string as an expression and replace the current node with the result.\n *\n * NOTE: This is typically not a good idea to use. Building source strings when\n * transforming ASTs is an antipattern and SHOULD NOT be encouraged. Even if it's\n * easier to use, your transforms will be extremely brittle.\n */\n\nfunction replaceWithSourceString(replacement) {\n  this.resync();\n\n  try {\n    replacement = \"(\" + replacement + \")\";\n    replacement = _helpersParse2[\"default\"](replacement);\n  } catch (err) {\n    var loc = err.loc;\n    if (loc) {\n      err.message += \" - make sure this is an expression.\";\n      err.message += \"\\n\" + _helpersCodeFrame2[\"default\"](replacement, loc.line, loc.column + 1);\n    }\n    throw err;\n  }\n\n  replacement = replacement.program.body[0].expression;\n  _index2[\"default\"].removeProperties(replacement);\n  return this.replaceWith(replacement);\n}\n\n/**\n * Replace the current node with another.\n */\n\nfunction replaceWith(replacement, whateverAllowed) {\n  this.resync();\n\n  if (this.removed) {\n    throw new Error(\"You can't replace this node, we've already removed it\");\n  }\n\n  if (replacement instanceof _index4[\"default\"]) {\n    replacement = replacement.node;\n  }\n\n  if (!replacement) {\n    throw new Error(\"You passed `path.replaceWith()` a falsy node, use `path.dangerouslyRemove()` instead\");\n  }\n\n  if (this.node === replacement) {\n    return;\n  }\n\n  if (this.isProgram() && !t.isProgram(replacement)) {\n    throw new Error(\"You can only replace a Program root node with another Program node\");\n  }\n\n  // normalise inserting an entire AST\n  if (t.isProgram(replacement) && !this.isProgram()) {\n    replacement = replacement.body;\n    whateverAllowed = true;\n  }\n\n  if (Array.isArray(replacement)) {\n    if (whateverAllowed) {\n      return this.replaceWithMultiple(replacement);\n    } else {\n      throw new Error(\"Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`\");\n    }\n  }\n\n  if (typeof replacement === \"string\") {\n    // triggers an error\n    return this.replaceWithSourceString();\n  }\n\n  if (this.isNodeType(\"Statement\") && t.isExpression(replacement)) {\n    if (!this.canHaveVariableDeclarationOrExpression() && !this.canSwapBetweenExpressionAndStatement(replacement)) {\n      // replacing a statement with an expression so wrap it in an expression statement\n      replacement = t.expressionStatement(replacement);\n    }\n  }\n\n  if (this.isNodeType(\"Expression\") && t.isStatement(replacement)) {\n    if (!this.canSwapBetweenExpressionAndStatement(replacement)) {\n      // replacing an expression with a statement so let's explode it\n      return this.replaceExpressionWithStatements([replacement]);\n    }\n  }\n\n  var oldNode = this.node;\n  if (oldNode) t.inheritsComments(replacement, oldNode);\n\n  // replace the node\n  this.node = this.container[this.key] = replacement;\n  this.type = replacement.type;\n\n  // potentially create new scope\n  this.setScope();\n}\n\n/**\n * This method takes an array of statements nodes and then explodes it\n * into expressions. This method retains completion records which is\n * extremely important to retain original semantics.\n */\n\nfunction replaceExpressionWithStatements(nodes) {\n  this.resync();\n\n  var toSequenceExpression = t.toSequenceExpression(nodes, this.scope);\n\n  if (toSequenceExpression) {\n    return this.replaceWith(toSequenceExpression);\n  } else {\n    var container = t.functionExpression(null, [], t.blockStatement(nodes));\n    container.shadow = true;\n\n    this.replaceWith(t.callExpression(container, []));\n    this.traverse(hoistVariablesVisitor);\n\n    // add implicit returns to all ending expression statements\n    var last = this.get(\"callee\").getCompletionRecords();\n    var _arr2 = last;\n    for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n      var lastNode = _arr2[_i2];\n      if (!lastNode.isExpressionStatement()) continue;\n\n      var loop = lastNode.findParent(function (path) {\n        return path.isLoop();\n      });\n      if (loop) {\n        var uid = this.get(\"callee\").scope.generateDeclaredUidIdentifier(\"ret\");\n        this.get(\"callee.body\").pushContainer(\"body\", t.returnStatement(uid));\n        lastNode.get(\"expression\").replaceWith(t.assignmentExpression(\"=\", uid, lastNode.node.expression));\n      } else {\n        lastNode.replaceWith(t.returnStatement(lastNode.node.expression));\n      }\n    }\n\n    return this.node;\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction replaceInline(nodes) {\n  this.resync();\n\n  if (Array.isArray(nodes)) {\n    if (Array.isArray(this.container)) {\n      nodes = this._verifyNodeList(nodes);\n      this._containerInsertAfter(nodes);\n      return this.dangerouslyRemove();\n    } else {\n      return this.replaceWithMultiple(nodes);\n    }\n  } else {\n    return this.replaceWith(nodes);\n  }\n}","//import lineNumbers from \"line-numbers\";\n\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _repeating = require(\"repeating\");\n\nvar _repeating2 = _interopRequireDefault(_repeating);\n\nvar _jsTokens = require(\"js-tokens\");\n\nvar _jsTokens2 = _interopRequireDefault(_jsTokens);\n\nvar _esutils = require(\"esutils\");\n\nvar _esutils2 = _interopRequireDefault(_esutils);\n\nvar _chalk = require(\"chalk\");\n\nvar _chalk2 = _interopRequireDefault(_chalk);\n\nfunction lineNumbers(lines) {\n  return lines;\n}\n\n/**\n * Chalk styles for token types.\n */\n\nvar defs = {\n  string: _chalk2[\"default\"].red,\n  punctuator: _chalk2[\"default\"].bold,\n  curly: _chalk2[\"default\"].green,\n  parens: _chalk2[\"default\"].blue.bold,\n  square: _chalk2[\"default\"].yellow,\n  keyword: _chalk2[\"default\"].cyan,\n  number: _chalk2[\"default\"].magenta,\n  regex: _chalk2[\"default\"].magenta,\n  comment: _chalk2[\"default\"].grey,\n  invalid: _chalk2[\"default\"].inverse\n};\n\n/**\n * RegExp to test for newlines in terminal.\n */\n\nvar NEWLINE = /\\r\\n|[\\n\\r\\u2028\\u2029]/;\n\n/**\n * Get the type of token, specifying punctuator type.\n */\n\nfunction getTokenType(match) {\n  var token = _jsTokens2[\"default\"].matchToToken(match);\n  if (token.type === \"name\" && _esutils2[\"default\"].keyword.isReservedWordES6(token.value)) {\n    return \"keyword\";\n  }\n\n  if (token.type === \"punctuator\") {\n    switch (token.value) {\n      case \"{\":\n      case \"}\":\n        return \"curly\";\n      case \"(\":\n      case \")\":\n        return \"parens\";\n      case \"[\":\n      case \"]\":\n        return \"square\";\n    }\n  }\n\n  return token.type;\n}\n\n/**\n * Highlight `text`.\n */\n\nfunction highlight(text) {\n  return text.replace(_jsTokens2[\"default\"], function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var type = getTokenType(args);\n    var colorize = defs[type];\n    if (colorize) {\n      return args[0].split(NEWLINE).map(function (str) {\n        return colorize(str);\n      }).join(\"\\n\");\n    } else {\n      return args[0];\n    }\n  });\n}\n\n/**\n * Create a code frame, adding line numbers, code highlighting, and pointing to a given position.\n */\n\nexports[\"default\"] = function (lines, lineNumber, colNumber) {\n  var opts = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];\n\n  colNumber = Math.max(colNumber, 0);\n\n  var highlighted = opts.highlightCode && _chalk2[\"default\"].supportsColor;\n  if (highlighted) lines = highlight(lines);\n\n  lines = lines.split(NEWLINE);\n\n  var start = Math.max(lineNumber - 3, 0);\n  var end = Math.min(lines.length, lineNumber + 3);\n\n  if (!lineNumber && !colNumber) {\n    start = 0;\n    end = lines.length;\n  }\n\n  var frame = lineNumbers(lines.slice(start, end), {\n    start: start + 1,\n    before: \"  \",\n    after: \" | \",\n    transform: function transform(params) {\n      if (params.number !== lineNumber) {\n        return;\n      }\n\n      if (colNumber) {\n        params.line += \"\\n\" + params.before + _repeating2[\"default\"](\" \", params.width) + params.after + _repeating2[\"default\"](\" \", colNumber - 1) + \"^\";\n      }\n\n      params.before = params.before.replace(/^./, \">\");\n    }\n  }).join(\"\\n\");\n\n  if (highlighted) {\n    return _chalk2[\"default\"].reset(frame);\n  } else {\n    return frame;\n  }\n};\n\nmodule.exports = exports[\"default\"];","/* eslint eqeqeq: 0 */\n\n\n\nexports.__esModule = true;\nexports.evaluateTruthy = evaluateTruthy;\nexports.evaluate = evaluate;\nvar VALID_CALLEES = [\"String\", \"Number\", \"Math\"];\n\n/**\n * Walk the input `node` and statically evaluate if it's truthy.\n *\n * Returning `true` when we're sure that the expression will evaluate to a\n * truthy value, `false` if we're sure that it will evaluate to a falsy\n * value and `undefined` if we aren't sure. Because of this please do not\n * rely on coercion when using this method and check with === if it's false.\n *\n * For example do:\n *\n *   if (t.evaluateTruthy(node) === false) falsyLogic();\n *\n * **AND NOT**\n *\n *   if (!t.evaluateTruthy(node)) falsyLogic();\n *\n */\n\nfunction evaluateTruthy() {\n  var res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\n/**\n * Walk the input `node` and statically evaluate it.\n *\n * Returns an object in the form `{ confident, value }`. `confident` indicates\n * whether or not we had to drop out of evaluating the expression because of\n * hitting an unknown node that we couldn't confidently find the value of.\n *\n * Example:\n *\n *   t.evaluate(parse(\"5 + 5\")) // { confident: true, value: 10 }\n *   t.evaluate(parse(\"!true\")) // { confident: true, value: false }\n *   t.evaluate(parse(\"foo + foo\")) // { confident: false, value: undefined }\n *\n */\n\nfunction evaluate() {\n  var confident = true;\n\n  var value = evaluate(this);\n  if (!confident) value = undefined;\n  return {\n    confident: confident,\n    value: value\n  };\n\n  function evaluate(path) {\n    if (!confident) return;\n\n    var node = path.node;\n\n    if (path.isSequenceExpression()) {\n      var exprs = path.get(\"expressions\");\n      return evaluate(exprs[exprs.length - 1]);\n    }\n\n    if (path.isLiteral()) {\n      if (node.regex) {\n        // we have a regex and we can't represent it natively\n      } else {\n          return node.value;\n        }\n    }\n\n    if (path.isConditionalExpression()) {\n      if (evaluate(path.get(\"test\"))) {\n        return evaluate(path.get(\"consequent\"));\n      } else {\n        return evaluate(path.get(\"alternate\"));\n      }\n    }\n\n    if (path.isTypeCastExpression()) {\n      return evaluate(path.get(\"expression\"));\n    }\n\n    if (path.isIdentifier() && !path.scope.hasBinding(node.name, true)) {\n      if (node.name === \"undefined\") {\n        return undefined;\n      } else if (node.name === \"Infinity\") {\n        return Infinity;\n      } else if (node.name === \"NaN\") {\n        return NaN;\n      }\n    }\n\n    // \"foo\".length\n    if (path.isMemberExpression() && !path.parentPath.isCallExpression({ callee: node })) {\n      var _property = path.get(\"property\");\n      var object = path.get(\"object\");\n\n      if (object.isLiteral() && _property.isIdentifier()) {\n        var _value = object.node.value;\n        var type = typeof _value;\n        if (type === \"number\" || type === \"string\") {\n          return _value[_property.node.name];\n        }\n      }\n    }\n\n    if (path.isReferencedIdentifier()) {\n      var binding = path.scope.getBinding(node.name);\n      if (binding && binding.hasValue) {\n        return binding.value;\n      } else {\n        var resolved = path.resolve();\n        if (resolved === path) {\n          return confident = false;\n        } else {\n          return evaluate(resolved);\n        }\n      }\n    }\n\n    if (path.isUnaryExpression({ prefix: true })) {\n      var argument = path.get(\"argument\");\n      var arg = evaluate(argument);\n      switch (node.operator) {\n        case \"void\":\n          return undefined;\n        case \"!\":\n          return !arg;\n        case \"+\":\n          return +arg;\n        case \"-\":\n          return -arg;\n        case \"~\":\n          return ~arg;\n        case \"typeof\":\n          if (argument.isFunction()) {\n            return \"function\";\n          } else {\n            return typeof arg;\n          }\n      }\n    }\n\n    if (path.isArrayExpression() || path.isObjectExpression()) {\n      // we could evaluate these but it's probably impractical and not very useful\n    }\n\n    if (path.isLogicalExpression()) {\n      // If we are confident that one side of an && is false, or one side of\n      // an || is true, we can be confident about the entire expression\n      var wasConfident = confident;\n      var left = evaluate(path.get(\"left\"));\n      var leftConfident = confident;\n      confident = wasConfident;\n      var right = evaluate(path.get(\"right\"));\n      var rightConfident = confident;\n      var uncertain = leftConfident !== rightConfident;\n      confident = leftConfident && rightConfident;\n\n      switch (node.operator) {\n        case \"||\":\n          if ((left || right) && uncertain) {\n            confident = true;\n          }\n          return left || right;\n        case \"&&\":\n          if (!left && leftConfident || !right && rightConfident) {\n            confident = true;\n          }\n          return left && right;\n      }\n    }\n\n    if (path.isBinaryExpression()) {\n      var left = evaluate(path.get(\"left\"));\n      var right = evaluate(path.get(\"right\"));\n\n      switch (node.operator) {\n        case \"-\":\n          return left - right;\n        case \"+\":\n          return left + right;\n        case \"/\":\n          return left / right;\n        case \"*\":\n          return left * right;\n        case \"%\":\n          return left % right;\n        case \"**\":\n          return Math.pow(left, right);\n        case \"<\":\n          return left < right;\n        case \">\":\n          return left > right;\n        case \"<=\":\n          return left <= right;\n        case \">=\":\n          return left >= right;\n        case \"==\":\n          return left == right;\n        case \"!=\":\n          return left != right;\n        case \"===\":\n          return left === right;\n        case \"!==\":\n          return left !== right;\n        case \"|\":\n          return left | right;\n        case \"&\":\n          return left & right;\n        case \"^\":\n          return left ^ right;\n        case \"<<\":\n          return left << right;\n        case \">>\":\n          return left >> right;\n        case \">>>\":\n          return left >>> right;\n      }\n    }\n\n    if (path.isCallExpression()) {\n      var callee = path.get(\"callee\");\n      var context;\n      var func;\n\n      // Number(1);\n      if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name, true) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {\n        func = global[node.callee.name];\n      }\n\n      if (callee.isMemberExpression()) {\n        var object = callee.get(\"object\");\n        var property = callee.get(\"property\");\n\n        // Math.min(1, 2)\n        if (object.isIdentifier() && property.isIdentifier() && VALID_CALLEES.indexOf(object.node.name) >= 0) {\n          context = global[object.node.name];\n          func = context[property.node.name];\n        }\n\n        // \"abc\".charCodeAt(4)\n        if (object.isLiteral() && property.isIdentifier()) {\n          var type = typeof object.node.value;\n          if (type === \"string\" || type === \"number\") {\n            context = object.node.value;\n            func = context[property.node.name];\n          }\n        }\n      }\n\n      if (func) {\n        var args = path.get(\"arguments\").map(evaluate);\n        if (!confident) return;\n\n        return func.apply(context, args);\n      }\n    }\n\n    confident = false;\n  }\n}","\n\nexports.__esModule = true;\nexports.toComputedKey = toComputedKey;\nexports.ensureBlock = ensureBlock;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nfunction toComputedKey() {\n  var node = this.node;\n\n  var key;\n  if (this.isMemberExpression()) {\n    key = node.property;\n  } else if (this.isProperty()) {\n    key = node.key;\n  } else {\n    throw new ReferenceError(\"todo\");\n  }\n\n  if (!node.computed) {\n    if (t.isIdentifier(key)) key = t.literal(key.name);\n  }\n\n  return key;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction ensureBlock() {\n  return t.ensureBlock(this.node);\n}","\n\nexports.__esModule = true;\nexports.matchesPattern = matchesPattern;\nexports.has = has;\nexports.isnt = isnt;\nexports.equals = equals;\nexports.isNodeType = isNodeType;\nexports.canHaveVariableDeclarationOrExpression = canHaveVariableDeclarationOrExpression;\nexports.canSwapBetweenExpressionAndStatement = canSwapBetweenExpressionAndStatement;\nexports.isCompletionRecord = isCompletionRecord;\nexports.isStatementOrBlock = isStatementOrBlock;\nexports.referencesImport = referencesImport;\nexports.getSource = getSource;\nexports.willIMaybeExecuteBefore = willIMaybeExecuteBefore;\nexports._guessExecutionStatusRelativeTo = _guessExecutionStatusRelativeTo;\nexports.resolve = resolve;\nexports._resolve = _resolve;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _lodashCollectionIncludes = require(\"lodash/collection/includes\");\n\nvar _lodashCollectionIncludes2 = _interopRequireDefault(_lodashCollectionIncludes);\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * Match the current node if it matches the provided `pattern`.\n *\n * For example, given the match `React.createClass` it would match the\n * parsed nodes of `React.createClass` and `React[\"createClass\"]`.\n */\n\nfunction matchesPattern(pattern, allowPartial) {\n  // not a member expression\n  if (!this.isMemberExpression()) return false;\n\n  var parts = pattern.split(\".\");\n  var search = [this.node];\n  var i = 0;\n\n  function matches(name) {\n    var part = parts[i];\n    return part === \"*\" || name === part;\n  }\n\n  while (search.length) {\n    var node = search.shift();\n\n    if (allowPartial && i === parts.length) {\n      return true;\n    }\n\n    if (t.isIdentifier(node)) {\n      // this part doesn't match\n      if (!matches(node.name)) return false;\n    } else if (t.isLiteral(node)) {\n      // this part doesn't match\n      if (!matches(node.value)) return false;\n    } else if (t.isMemberExpression(node)) {\n      if (node.computed && !t.isLiteral(node.property)) {\n        // we can't deal with this\n        return false;\n      } else {\n        search.unshift(node.property);\n        search.unshift(node.object);\n        continue;\n      }\n    } else if (t.isThisExpression(node)) {\n      if (!matches(\"this\")) return false;\n    } else {\n      // we can't deal with this\n      return false;\n    }\n\n    // too many parts\n    if (++i > parts.length) {\n      return false;\n    }\n  }\n\n  return i === parts.length;\n}\n\n/**\n * Check whether we have the input `key`. If the `key` references an array then we check\n * if the array has any items, otherwise we just check if it's falsy.\n */\n\nfunction has(key) {\n  var val = this.node[key];\n  if (val && Array.isArray(val)) {\n    return !!val.length;\n  } else {\n    return !!val;\n  }\n}\n\n/**\n * Alias of `has`.\n */\n\nvar is = has;\n\nexports.is = is;\n/**\n * Opposite of `has`.\n */\n\nfunction isnt(key) {\n  return !this.has(key);\n}\n\n/**\n * Check whether the path node `key` strict equals `value`.\n */\n\nfunction equals(key, value) {\n  return this.node[key] === value;\n}\n\n/**\n * Check the type against our stored internal type of the node. This is handy when a node has\n * been removed yet we still internally know the type and need it to calculate node replacement.\n */\n\nfunction isNodeType(type) {\n  return t.isType(this.type, type);\n}\n\n/**\n * This checks whether or not we're in one of the following positions:\n *\n *   for (KEY in right);\n *   for (KEY;;);\n *\n * This is because these spots allow VariableDeclarations AND normal expressions so we need\n * to tell the path replacement that it's ok to replace this with an expression.\n */\n\nfunction canHaveVariableDeclarationOrExpression() {\n  return (this.key === \"init\" || this.key === \"left\") && this.parentPath.isFor();\n}\n\n/**\n * This checks whether we are swapping an arrow function's body between an\n * expression and a block statement (or vice versa).\n *\n * This is because arrow functions may implicitly return an expression, which\n * is the same as containing a block statement.\n */\n\nfunction canSwapBetweenExpressionAndStatement(replacement) {\n  if (this.key !== \"body\" || !this.parentPath.isArrowFunctionExpression()) {\n    return false;\n  }\n\n  if (this.isExpression()) {\n    return t.isBlockStatement(replacement);\n  } else if (this.isBlockStatement()) {\n    return t.isExpression(replacement);\n  }\n\n  return false;\n}\n\n/**\n * Check whether the current path references a completion record\n */\n\nfunction isCompletionRecord(allowInsideFunction) {\n  var path = this;\n  var first = true;\n\n  do {\n    var container = path.container;\n\n    // we're in a function so can't be a completion record\n    if (path.isFunction() && !first) {\n      return !!allowInsideFunction;\n    }\n\n    first = false;\n\n    // check to see if we're the last item in the container and if we are\n    // we're a completion record!\n    if (Array.isArray(container) && path.key !== container.length - 1) {\n      return false;\n    }\n  } while ((path = path.parentPath) && !path.isProgram());\n\n  return true;\n}\n\n/**\n * Check whether or not the current `key` allows either a single statement or block statement\n * so we can explode it if necessary.\n */\n\nfunction isStatementOrBlock() {\n  if (this.parentPath.isLabeledStatement() || t.isBlockStatement(this.container)) {\n    return false;\n  } else {\n    return _lodashCollectionIncludes2[\"default\"](t.STATEMENT_OR_BLOCK_KEYS, this.key);\n  }\n}\n\n/**\n * Check if the currently assigned path references the `importName` of `moduleSource`.\n */\n\nfunction referencesImport(moduleSource, importName) {\n  if (!this.isReferencedIdentifier()) return false;\n\n  var binding = this.scope.getBinding(this.node.name);\n  if (!binding || binding.kind !== \"module\") return false;\n\n  var path = binding.path;\n  var parent = path.parentPath;\n  if (!parent.isImportDeclaration()) return false;\n\n  // check moduleSource\n  if (parent.node.source.value === moduleSource) {\n    if (!importName) return true;\n  } else {\n    return false;\n  }\n\n  if (path.isImportDefaultSpecifier() && importName === \"default\") {\n    return true;\n  }\n\n  if (path.isImportNamespaceSpecifier() && importName === \"*\") {\n    return true;\n  }\n\n  if (path.isImportSpecifier() && path.node.imported.name === importName) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Get the source code associated with this node.\n */\n\nfunction getSource() {\n  var node = this.node;\n  if (node.end) {\n    return this.hub.file.code.slice(node.start, node.end);\n  } else {\n    return \"\";\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction willIMaybeExecuteBefore(target) {\n  return this._guessExecutionStatusRelativeTo(target) !== \"after\";\n}\n\n/**\n * Given a `target` check the execution status of it relative to the current path.\n *\n * \"Execution status\" simply refers to where or not we **think** this will execuete\n * before or after the input `target` element.\n */\n\nfunction _guessExecutionStatusRelativeTo(target) {\n  // check if the two paths are in different functions, we can't track execution of these\n  var targetFuncParent = target.scope.getFunctionParent();\n  var selfFuncParent = this.scope.getFunctionParent();\n  if (targetFuncParent !== selfFuncParent) {\n    return \"function\";\n  }\n\n  var targetPaths = target.getAncestry();\n  //if (targetPaths.indexOf(this) >= 0) return \"after\";\n\n  var selfPaths = this.getAncestry();\n\n  // get ancestor where the branches intersect\n  var commonPath;\n  var targetIndex;\n  var selfIndex;\n  for (selfIndex = 0; selfIndex < selfPaths.length; selfIndex++) {\n    var selfPath = selfPaths[selfIndex];\n    targetIndex = targetPaths.indexOf(selfPath);\n    if (targetIndex >= 0) {\n      commonPath = selfPath;\n      break;\n    }\n  }\n  if (!commonPath) {\n    return \"before\";\n  }\n\n  // get the relationship paths that associate these nodes to their common ancestor\n  var targetRelationship = targetPaths[targetIndex - 1];\n  var selfRelationship = selfPaths[selfIndex - 1];\n  if (!targetRelationship || !selfRelationship) {\n    return \"before\";\n  }\n\n  // container list so let's see which one is after the other\n  if (targetRelationship.listKey && targetRelationship.container === selfRelationship.container) {\n    return targetRelationship.key > selfRelationship.key ? \"before\" : \"after\";\n  }\n\n  // otherwise we're associated by a parent node, check which key comes before the other\n  var targetKeyPosition = t.VISITOR_KEYS[targetRelationship.type].indexOf(targetRelationship.key);\n  var selfKeyPosition = t.VISITOR_KEYS[selfRelationship.type].indexOf(selfRelationship.key);\n  return targetKeyPosition > selfKeyPosition ? \"before\" : \"after\";\n}\n\n/**\n * Resolve a \"pointer\" `NodePath` to it's absolute path.\n */\n\nfunction resolve(dangerous, resolved) {\n  return this._resolve(dangerous, resolved) || this;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction _resolve(dangerous, resolved) {\n  // detect infinite recursion\n  // todo: possibly have a max length on this just to be safe\n  if (resolved && resolved.indexOf(this) >= 0) return;\n\n  // we store all the paths we've \"resolved\" in this array to prevent infinite recursion\n  resolved = resolved || [];\n  resolved.push(this);\n\n  if (this.isVariableDeclarator()) {\n    if (this.get(\"id\").isIdentifier()) {\n      return this.get(\"init\").resolve(dangerous, resolved);\n    } else {\n      // otherwise it's a request for a pattern and that's a bit more tricky\n    }\n  } else if (this.isReferencedIdentifier()) {\n      var binding = this.scope.getBinding(this.node.name);\n      if (!binding) return;\n\n      // reassigned so we can't really resolve it\n      if (!binding.constant) return;\n\n      // todo - lookup module in dependency graph\n      if (binding.kind === \"module\") return;\n\n      if (binding.path !== this) {\n        return binding.path.resolve(dangerous, resolved);\n      }\n    } else if (this.isTypeCastExpression()) {\n      return this.get(\"expression\").resolve(dangerous, resolved);\n    } else if (dangerous && this.isMemberExpression()) {\n      // this is dangerous, as non-direct target assignments will mutate it's state\n      // making this resolution inaccurate\n\n      var targetKey = this.toComputedKey();\n      if (!t.isLiteral(targetKey)) return;\n\n      var targetName = targetKey.value;\n\n      var target = this.get(\"object\").resolve(dangerous, resolved);\n\n      if (target.isObjectExpression()) {\n        var props = target.get(\"properties\");\n        var _arr = props;\n        for (var _i = 0; _i < _arr.length; _i++) {\n          var prop = _arr[_i];\n          if (!prop.isProperty()) continue;\n\n          var key = prop.get(\"key\");\n\n          // { foo: obj }\n          var match = prop.isnt(\"computed\") && key.isIdentifier({ name: targetName });\n\n          // { \"foo\": \"obj\" } or { [\"foo\"]: \"obj\" }\n          match = match || key.isLiteral({ value: targetName });\n\n          if (match) return prop.get(\"value\").resolve(dangerous, resolved);\n        }\n      } else if (target.isArrayExpression() && !isNaN(+targetName)) {\n        var elems = target.get(\"elements\");\n        var elem = elems[targetName];\n        if (elem) return elem.resolve(dangerous, resolved);\n      }\n    }\n}","\n\nexports.__esModule = true;\nexports.call = call;\nexports.isBlacklisted = isBlacklisted;\nexports.visit = visit;\nexports.skip = skip;\nexports.skipKey = skipKey;\nexports.stop = stop;\nexports.setScope = setScope;\nexports.setContext = setContext;\nexports.resync = resync;\nexports._resyncParent = _resyncParent;\nexports._resyncKey = _resyncKey;\nexports._resyncList = _resyncList;\nexports._resyncRemoved = _resyncRemoved;\nexports.shiftContext = shiftContext;\nexports.unshiftContext = unshiftContext;\nexports.setup = setup;\nexports.setKey = setKey;\nexports.queueNode = queueNode;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _index = require(\"../index\");\n\nvar _index2 = _interopRequireDefault(_index);\n\n/**\n * [Please add a description.]\n */\n\nfunction call(key) {\n  var node = this.node;\n  if (!node) return;\n\n  var opts = this.opts;\n\n  var _arr = [opts[key], opts[node.type] && opts[node.type][key]];\n  for (var _i = 0; _i < _arr.length; _i++) {\n    var fns = _arr[_i];\n    if (!fns) continue;\n\n    var _arr2 = fns;\n    for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n      var fn = _arr2[_i2];\n      if (!fn) continue;\n\n      var _node = this.node;\n      if (!_node) return;\n\n      var previousType = this.type;\n\n      // call the function with the params (node, parent, scope, state)\n      var replacement = fn.call(this, _node, this.parent, this.scope, this.state);\n\n      if (replacement) {\n        this.replaceWith(replacement, true);\n      }\n\n      if (this.shouldStop || this.shouldSkip || this.removed) return;\n\n      if (previousType !== this.type) {\n        this.queueNode(this);\n        return;\n      }\n    }\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction isBlacklisted() {\n  var blacklist = this.opts.blacklist;\n  return blacklist && blacklist.indexOf(this.node.type) > -1;\n}\n\n/**\n * Visits a node and calls appropriate enter and exit callbacks\n * as required.\n */\n\nfunction visit() {\n  if (this.isBlacklisted()) return false;\n  if (this.opts.shouldSkip && this.opts.shouldSkip(this)) return false;\n\n  this.call(\"enter\");\n\n  if (this.shouldSkip) {\n    return this.shouldStop;\n  }\n\n  var node = this.node;\n  var opts = this.opts;\n\n  if (node) {\n    if (Array.isArray(node)) {\n      // traverse over these replacement nodes we purposely don't call exitNode\n      // as the original node has been destroyed\n      for (var i = 0; i < node.length; i++) {\n        _index2[\"default\"].node(node[i], opts, this.scope, this.state, this, this.skipKeys);\n      }\n    } else {\n      _index2[\"default\"].node(node, opts, this.scope, this.state, this, this.skipKeys);\n      this.call(\"exit\");\n    }\n  }\n\n  return this.shouldStop;\n}\n\n/**\n * Sets shouldSkip flag true so that this node will be skipped while visiting.\n */\n\nfunction skip() {\n  this.shouldSkip = true;\n}\n\n/**\n * Adds given key to the list of keys to be skipped.\n */\n\nfunction skipKey(key) {\n  this.skipKeys[key] = true;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction stop() {\n  this.shouldStop = true;\n  this.shouldSkip = true;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction setScope() {\n  if (this.opts && this.opts.noScope) return;\n\n  var target = this.context || this.parentPath;\n  this.scope = this.getScope(target && target.scope);\n  if (this.scope) this.scope.init();\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction setContext(context) {\n  this.shouldSkip = false;\n  this.shouldStop = false;\n  this.removed = false;\n  this.skipKeys = {};\n\n  if (context) {\n    this.context = context;\n    this.state = context.state;\n    this.opts = context.opts;\n  }\n\n  this.setScope();\n\n  return this;\n}\n\n/**\n * Here we resync the node paths `key` and `container`. If they've changed according\n * to what we have stored internally then we attempt to resync by crawling and looking\n * for the new values.\n */\n\nfunction resync() {\n  if (this.removed) return;\n\n  this._resyncParent();\n  this._resyncList();\n  this._resyncKey();\n  //this._resyncRemoved();\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction _resyncParent() {\n  if (this.parentPath) {\n    this.parent = this.parentPath.node;\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction _resyncKey() {\n  if (!this.container) return;\n\n  if (this.node === this.container[this.key]) return;\n\n  // grrr, path key is out of sync. this is likely due to a modification to the AST\n  // not done through our path APIs\n\n  if (Array.isArray(this.container)) {\n    for (var i = 0; i < this.container.length; i++) {\n      if (this.container[i] === this.node) {\n        return this.setKey(i);\n      }\n    }\n  } else {\n    for (var key in this.container) {\n      if (this.container[key] === this.node) {\n        return this.setKey(key);\n      }\n    }\n  }\n\n  this.key = null;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction _resyncList() {\n  var listKey = this.listKey;\n  var parentPath = this.parentPath;\n  if (!listKey || !parentPath) return;\n\n  var newContainer = parentPath.node[listKey];\n  if (this.container === newContainer) return;\n\n  // container is out of sync. this is likely the result of it being reassigned\n\n  if (newContainer) {\n    this.container = newContainer;\n  } else {\n    this.container = null;\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction _resyncRemoved() {\n  if (this.key == null || !this.container || this.container[this.key] !== this.node) {\n    this._markRemoved();\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction shiftContext() {\n  this.contexts.shift();\n  this.setContext(this.contexts[0]);\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction unshiftContext(context) {\n  this.contexts.unshift(context);\n  this.setContext(context);\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction setup(parentPath, container, listKey, key) {\n  this.inList = !!listKey;\n  this.listKey = listKey;\n  this.parentKey = listKey || key;\n  this.container = container;\n\n  this.parentPath = parentPath || this.parentPath;\n  this.setKey(key);\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction setKey(key) {\n  this.key = key;\n  this.node = this.container[this.key];\n  this.type = this.node && this.node.type;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction queueNode(path) {\n  var _arr3 = this.contexts;\n\n  for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n    var context = _arr3[_i3];\n    if (context.queue) {\n      context.queue.push(path);\n    }\n  }\n}","\n\nexports.__esModule = true;\nexports.remove = remove;\nexports.dangerouslyRemove = dangerouslyRemove;\nexports._callRemovalHooks = _callRemovalHooks;\nexports._remove = _remove;\nexports._markRemoved = _markRemoved;\nexports._assertUnremoved = _assertUnremoved;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _libRemovalHooks = require(\"./lib/removal-hooks\");\n\nvar removalHooks = _interopRequireWildcard(_libRemovalHooks);\n\n/**\n * Deprecated in favor of `dangerouslyRemove` as it's far more scary and more accurately portrays\n * the risk.\n */\n\nfunction remove() {\n  console.trace(\"Path#remove has been renamed to Path#dangerouslyRemove, removing a node is extremely dangerous so please refrain using it.\");\n  return this.dangerouslyRemove();\n}\n\n/**\n * Dangerously remove the current node. This may sometimes result in a tainted\n * invalid AST so use with caution.\n */\n\nfunction dangerouslyRemove() {\n  this._assertUnremoved();\n\n  this.resync();\n\n  if (this._callRemovalHooks(\"pre\")) {\n    this._markRemoved();\n    return;\n  }\n\n  this.shareCommentsWithSiblings();\n  this._remove();\n  this._markRemoved();\n\n  this._callRemovalHooks(\"post\");\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction _callRemovalHooks(position) {\n  var _arr = removalHooks[position];\n\n  for (var _i = 0; _i < _arr.length; _i++) {\n    var fn = _arr[_i];\n    if (fn(this, this.parentPath)) return true;\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction _remove() {\n  if (Array.isArray(this.container)) {\n    this.container.splice(this.key, 1);\n    this.updateSiblingKeys(this.key, -1);\n  } else {\n    this.container[this.key] = null;\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction _markRemoved() {\n  this.shouldSkip = true;\n  this.removed = true;\n  this.node = null;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction _assertUnremoved() {\n  if (this.removed) {\n    throw this.errorWithNode(\"NodePath has been removed so is read-only.\");\n  }\n}","// this file contains hooks that handle ancestry cleanup of parent nodes when removing children\n\n\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * Pre hooks should be used for either rejecting removal or delegating removal\n */\n\nvar pre = [\n\n/**\n * [Please add a description.]\n */\n\nfunction (self) {\n  if (self.key === \"body\" && (self.isBlockStatement() || self.isClassBody())) {\n    // function () NODE\n    // class NODE\n    // attempting to remove a block statement that's someones body so let's just clear all the inner\n    // statements instead\n    self.node.body = [];\n    return true;\n  }\n},\n\n/**\n * [Please add a description.]\n */\n\nfunction (self, parent) {\n  var replace = false;\n\n  // () => NODE;\n  // removing the body of an arrow function\n  replace = replace || self.key === \"body\" && parent.isArrowFunctionExpression();\n\n  // throw NODE;\n  // removing a throw statement argument\n  replace = replace || self.key === \"argument\" && parent.isThrowStatement();\n\n  if (replace) {\n    self.replaceWith(t.identifier(\"undefined\"));\n    return true;\n  }\n}];\n\nexports.pre = pre;\n/**\n * Post hooks should be used for cleaning up parents\n */\n\nvar post = [\n\n/**\n * [Please add a description.]\n */\n\nfunction (self, parent) {\n  var removeParent = false;\n\n  // while (NODE);\n  // removing the test of a while/switch, we can either just remove it entirely *or* turn the `test` into `true`\n  // unlikely that the latter will ever be what's wanted so we just remove the loop to avoid infinite recursion\n  removeParent = removeParent || self.key === \"test\" && (parent.isWhile() || parent.isSwitchCase());\n\n  // export NODE;\n  // just remove a declaration for an export as this is no longer valid\n  removeParent = removeParent || self.key === \"declaration\" && parent.isExportDeclaration();\n\n  // label: NODE\n  // stray labeled statement with no body\n  removeParent = removeParent || self.key === \"body\" && parent.isLabeledStatement();\n\n  // var NODE;\n  // remove an entire declaration if there are no declarators left\n  removeParent = removeParent || self.listKey === \"declarations\" && parent.isVariableDeclaration() && parent.node.declarations.length === 0;\n\n  // NODE;\n  // remove the entire expression statement if there's no expression\n  removeParent = removeParent || self.key === \"expression\" && parent.isExpressionStatement();\n\n  // if (NODE);\n  // remove the entire if since the consequent is never going to be hit, if there's an alternate then it's already been\n  // handled with the `pre` hook\n  removeParent = removeParent || self.key === \"test\" && parent.isIfStatement();\n\n  if (removeParent) {\n    parent.dangerouslyRemove();\n    return true;\n  }\n},\n\n/**\n * [Please add a description.]\n */\n\nfunction (self, parent) {\n  if (parent.isSequenceExpression() && parent.node.expressions.length === 1) {\n    // (node, NODE);\n    // we've just removed the second element of a sequence expression so let's turn that sequence\n    // expression into a regular expression\n    parent.replaceWith(parent.node.expressions[0]);\n    return true;\n  }\n},\n\n/**\n * [Please add a description.]\n */\n\nfunction (self, parent) {\n  if (parent.isBinary()) {\n    // left + NODE;\n    // NODE + right;\n    // we're in a binary expression, better remove it and replace it with the last expression\n    if (self.key === \"left\") {\n      parent.replaceWith(parent.node.right);\n    } else {\n      // key === \"right\"\n      parent.replaceWith(parent.node.left);\n    }\n    return true;\n  }\n}];\nexports.post = post;","\n\nexports.__esModule = true;\nexports.insertBefore = insertBefore;\nexports._containerInsert = _containerInsert;\nexports._containerInsertBefore = _containerInsertBefore;\nexports._containerInsertAfter = _containerInsertAfter;\nexports._maybePopFromStatements = _maybePopFromStatements;\nexports.insertAfter = insertAfter;\nexports.updateSiblingKeys = updateSiblingKeys;\nexports._verifyNodeList = _verifyNodeList;\nexports.unshiftContainer = unshiftContainer;\nexports.pushContainer = pushContainer;\nexports.hoist = hoist;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _libHoister = require(\"./lib/hoister\");\n\nvar _libHoister2 = _interopRequireDefault(_libHoister);\n\nvar _index = require(\"./index\");\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * Insert the provided nodes before the current one.\n */\n\nfunction insertBefore(nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  if (this.parentPath.isExpressionStatement() || this.parentPath.isLabeledStatement()) {\n    return this.parentPath.insertBefore(nodes);\n  } else if (this.isNodeType(\"Expression\") || this.parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) nodes.push(this.node);\n    this.replaceExpressionWithStatements(nodes);\n  } else {\n    this._maybePopFromStatements(nodes);\n    if (Array.isArray(this.container)) {\n      return this._containerInsertBefore(nodes);\n    } else if (this.isStatementOrBlock()) {\n      if (this.node) nodes.push(this.node);\n      this.node = this.container[this.key] = t.blockStatement(nodes);\n    } else {\n      throw new Error(\"We don't know what to do with this node type. We were previously a Statement but we can't fit in here?\");\n    }\n  }\n\n  return [this];\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction _containerInsert(from, nodes) {\n  this.updateSiblingKeys(from, nodes.length);\n\n  var paths = [];\n\n  for (var i = 0; i < nodes.length; i++) {\n    var to = from + i;\n    var node = nodes[i];\n    this.container.splice(to, 0, node);\n\n    if (this.context) {\n      var path = this.context.create(this.parent, this.container, to, this.listKey);\n      paths.push(path);\n      this.queueNode(path);\n    } else {\n      paths.push(_index2[\"default\"].get({\n        parentPath: this,\n        parent: node,\n        container: this.container,\n        listKey: this.listKey,\n        key: to\n      }));\n    }\n  }\n\n  return paths;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction _containerInsertBefore(nodes) {\n  return this._containerInsert(this.key, nodes);\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction _containerInsertAfter(nodes) {\n  return this._containerInsert(this.key + 1, nodes);\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction _maybePopFromStatements(nodes) {\n  var last = nodes[nodes.length - 1];\n  if (t.isExpressionStatement(last) && t.isIdentifier(last.expression) && !this.isCompletionRecord()) {\n    nodes.pop();\n  }\n}\n\n/**\n * Insert the provided nodes after the current one. When inserting nodes after an\n * expression, ensure that the completion record is correct by pushing the current node.\n */\n\nfunction insertAfter(nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  if (this.parentPath.isExpressionStatement() || this.parentPath.isLabeledStatement()) {\n    return this.parentPath.insertAfter(nodes);\n  } else if (this.isNodeType(\"Expression\") || this.parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) {\n      var temp = this.scope.generateDeclaredUidIdentifier();\n      nodes.unshift(t.expressionStatement(t.assignmentExpression(\"=\", temp, this.node)));\n      nodes.push(t.expressionStatement(temp));\n    }\n    this.replaceExpressionWithStatements(nodes);\n  } else {\n    this._maybePopFromStatements(nodes);\n    if (Array.isArray(this.container)) {\n      return this._containerInsertAfter(nodes);\n    } else if (this.isStatementOrBlock()) {\n      if (this.node) nodes.unshift(this.node);\n      this.node = this.container[this.key] = t.blockStatement(nodes);\n    } else {\n      throw new Error(\"We don't know what to do with this node type. We were previously a Statement but we can't fit in here?\");\n    }\n  }\n\n  return [this];\n}\n\n/**\n * Update all sibling node paths after `fromIndex` by `incrementBy`.\n */\n\nfunction updateSiblingKeys(fromIndex, incrementBy) {\n  var paths = this.parent._paths;\n  for (var i = 0; i < paths.length; i++) {\n    var path = paths[i];\n    if (path.key >= fromIndex) {\n      path.key += incrementBy;\n    }\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction _verifyNodeList(nodes) {\n  if (nodes.constructor !== Array) {\n    nodes = [nodes];\n  }\n\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n    if (!node) {\n      throw new Error(\"Node list has falsy node with the index of \" + i);\n    } else if (typeof node !== \"object\") {\n      throw new Error(\"Node list contains a non-object node with the index of \" + i);\n    } else if (!node.type) {\n      throw new Error(\"Node list contains a node without a type with the index of \" + i);\n    } else if (node instanceof _index2[\"default\"]) {\n      nodes[i] = node.node;\n    }\n  }\n\n  return nodes;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction unshiftContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  // get the first path and insert our nodes before it, if it doesn't exist then it\n  // doesn't matter, our nodes will be inserted anyway\n\n  var container = this.node[listKey];\n  var path = _index2[\"default\"].get({\n    parentPath: this,\n    parent: this.node,\n    container: container,\n    listKey: listKey,\n    key: 0\n  });\n\n  return path.insertBefore(nodes);\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction pushContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  // get an invisible path that represents the last node + 1 and replace it with our\n  // nodes, effectively inlining it\n\n  var container = this.node[listKey];\n  var i = container.length;\n  var path = _index2[\"default\"].get({\n    parentPath: this,\n    parent: this.node,\n    container: container,\n    listKey: listKey,\n    key: i\n  });\n\n  return path.replaceWith(nodes, true);\n}\n\n/**\n * Hoist the current node to the highest scope possible and return a UID\n * referencing it.\n */\n\nfunction hoist() {\n  var scope = arguments.length <= 0 || arguments[0] === undefined ? this.scope : arguments[0];\n\n  var hoister = new _libHoister2[\"default\"](this, scope);\n  return hoister.run();\n}","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _transformationHelpersReact = require(\"../../../transformation/helpers/react\");\n\nvar react = _interopRequireWildcard(_transformationHelpersReact);\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nvar referenceVisitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope, state) {\n    if (this.isJSXIdentifier() && react.isCompatTag(node.name)) {\n      return;\n    }\n\n    // direct references that we need to track to hoist this to the highest scope we can\n    var binding = scope.getBinding(node.name);\n    if (!binding) return;\n\n    // this binding isn't accessible from the parent scope so we can safely ignore it\n    // eg. it's in a closure etc\n    if (binding !== state.scope.getBinding(node.name)) return;\n\n    if (binding.constant) {\n      state.bindings[node.name] = binding;\n    } else {\n      var _arr = binding.constantViolations;\n\n      for (var _i = 0; _i < _arr.length; _i++) {\n        var violationPath = _arr[_i];\n        state.breakOnScopePaths = state.breakOnScopePaths.concat(violationPath.getAncestry());\n      }\n    }\n  }\n};\n\n/**\n * [Please add a description.]\n */\n\nvar PathHoister = (function () {\n  function PathHoister(path, scope) {\n    _classCallCheck(this, PathHoister);\n\n    this.breakOnScopePaths = [];\n    this.bindings = {};\n    this.scopes = [];\n    this.scope = scope;\n    this.path = path;\n  }\n\n  /**\n   * [Please add a description.]\n   */\n\n  PathHoister.prototype.isCompatibleScope = function isCompatibleScope(scope) {\n    for (var key in this.bindings) {\n      var binding = this.bindings[key];\n      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  PathHoister.prototype.getCompatibleScopes = function getCompatibleScopes() {\n    var scope = this.path.scope;\n    do {\n      if (this.isCompatibleScope(scope)) {\n        this.scopes.push(scope);\n      } else {\n        break;\n      }\n\n      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {\n        break;\n      }\n    } while (scope = scope.parent);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  PathHoister.prototype.getAttachmentPath = function getAttachmentPath() {\n    var scopes = this.scopes;\n\n    var scope = scopes.pop();\n    if (!scope) return;\n\n    if (scope.path.isFunction()) {\n      if (this.hasOwnParamBindings(scope)) {\n        // should ignore this scope since it's ourselves\n        if (this.scope === scope) return;\n\n        // needs to be attached to the body\n        return scope.path.get(\"body\").get(\"body\")[0];\n      } else {\n        // doesn't need to be be attached to this scope\n        return this.getNextScopeStatementParent();\n      }\n    } else if (scope.path.isProgram()) {\n      return this.getNextScopeStatementParent();\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  PathHoister.prototype.getNextScopeStatementParent = function getNextScopeStatementParent() {\n    var scope = this.scopes.pop();\n    if (scope) return scope.path.getStatementParent();\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  PathHoister.prototype.hasOwnParamBindings = function hasOwnParamBindings(scope) {\n    for (var name in this.bindings) {\n      if (!scope.hasOwnBinding(name)) continue;\n\n      var binding = this.bindings[name];\n      if (binding.kind === \"param\") return true;\n    }\n    return false;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  PathHoister.prototype.run = function run() {\n    var node = this.path.node;\n    if (node._hoisted) return;\n    node._hoisted = true;\n\n    this.path.traverse(referenceVisitor, this);\n\n    this.getCompatibleScopes();\n\n    var attachTo = this.getAttachmentPath();\n    if (!attachTo) return;\n\n    // don't bother hoisting to the same function as this will cause multiple branches to be evaluated more than once leading to a bad optimisation\n    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n\n    var uid = attachTo.scope.generateUidIdentifier(\"ref\");\n\n    attachTo.insertBefore([t.variableDeclaration(\"var\", [t.variableDeclarator(uid, this.path.node)])]);\n\n    var parent = this.path.parentPath;\n\n    if (parent.isJSXElement() && this.path.container === parent.node.children) {\n      // turning the `span` in `<div><span /></div>` to an expression so we need to wrap it with\n      // an expression container\n      uid = t.JSXExpressionContainer(uid);\n    }\n\n    this.path.replaceWith(uid);\n  };\n\n  return PathHoister;\n})();\n\nexports[\"default\"] = PathHoister;\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\nexports.getStatementParent = getStatementParent;\nexports.getOpposite = getOpposite;\nexports.getCompletionRecords = getCompletionRecords;\nexports.getSibling = getSibling;\nexports.get = get;\nexports._getKey = _getKey;\nexports._getPattern = _getPattern;\nexports.getBindingIdentifiers = getBindingIdentifiers;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _index = require(\"./index\");\n\nvar _index2 = _interopRequireDefault(_index);\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nfunction getStatementParent() {\n  var path = this;\n\n  do {\n    if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n      break;\n    } else {\n      path = path.parentPath;\n    }\n  } while (path);\n\n  if (path && (path.isProgram() || path.isFile())) {\n    throw new Error(\"File/Program node, we can't possibly find a statement parent to this\");\n  }\n\n  return path;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction getOpposite() {\n  if (this.key === \"left\") {\n    return this.getSibling(\"right\");\n  } else if (this.key === \"right\") {\n    return this.getSibling(\"left\");\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction getCompletionRecords() {\n  var paths = [];\n\n  var add = function add(path) {\n    if (path) paths = paths.concat(path.getCompletionRecords());\n  };\n\n  if (this.isIfStatement()) {\n    add(this.get(\"consequent\"));\n    add(this.get(\"alternate\"));\n  } else if (this.isDoExpression() || this.isFor() || this.isWhile()) {\n    add(this.get(\"body\"));\n  } else if (this.isProgram() || this.isBlockStatement()) {\n    add(this.get(\"body\").pop());\n  } else if (this.isFunction()) {\n    return this.get(\"body\").getCompletionRecords();\n  } else if (this.isTryStatement()) {\n    add(this.get(\"block\"));\n    add(this.get(\"handler\"));\n    add(this.get(\"finalizer\"));\n  } else {\n    paths.push(this);\n  }\n\n  return paths;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction getSibling(key) {\n  return _index2[\"default\"].get({\n    parentPath: this.parentPath,\n    parent: this.parent,\n    container: this.container,\n    listKey: this.listKey,\n    key: key\n  });\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction get(key, context) {\n  if (context === true) context = this.context;\n  var parts = key.split(\".\");\n  if (parts.length === 1) {\n    // \"foo\"\n    return this._getKey(key, context);\n  } else {\n    // \"foo.bar\"\n    return this._getPattern(parts, context);\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction _getKey(key, context) {\n  // istanbul ignore next\n\n  var _this = this;\n\n  var node = this.node;\n  var container = node[key];\n\n  if (Array.isArray(container)) {\n    // requested a container so give them all the paths\n    return container.map(function (_, i) {\n      return _index2[\"default\"].get({\n        listKey: key,\n        parentPath: _this,\n        parent: node,\n        container: container,\n        key: i\n      }).setContext(context);\n    });\n  } else {\n    return _index2[\"default\"].get({\n      parentPath: this,\n      parent: node,\n      container: node,\n      key: key\n    }).setContext(context);\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction _getPattern(parts, context) {\n  var path = this;\n  var _arr = parts;\n  for (var _i = 0; _i < _arr.length; _i++) {\n    var part = _arr[_i];\n    if (part === \".\") {\n      path = path.parentPath;\n    } else {\n      if (Array.isArray(path)) {\n        path = path[part];\n      } else {\n        path = path.get(part, context);\n      }\n    }\n  }\n  return path;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction getBindingIdentifiers(duplicates) {\n  return t.getBindingIdentifiers(this.node, duplicates);\n}","/**\n * Share comments amongst siblings.\n */\n\n\n\nexports.__esModule = true;\nexports.shareCommentsWithSiblings = shareCommentsWithSiblings;\nexports.addComment = addComment;\nexports.addComments = addComments;\n\nfunction shareCommentsWithSiblings() {\n  var node = this.node;\n  if (!node) return;\n\n  var trailing = node.trailingComments;\n  var leading = node.leadingComments;\n  if (!trailing && !leading) return;\n\n  var prev = this.getSibling(this.key - 1);\n  var next = this.getSibling(this.key + 1);\n\n  if (!prev.node) prev = next;\n  if (!next.node) next = prev;\n\n  prev.addComments(\"trailing\", leading);\n  next.addComments(\"leading\", trailing);\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction addComment(type, content, line) {\n  this.addComments(type, [{\n    type: line ? \"CommentLine\" : \"CommentBlock\",\n    value: content\n  }]);\n}\n\n/**\n * Give node `comments` of the specified `type`.\n */\n\nfunction addComments(type, comments) {\n  if (!comments) return;\n\n  var node = this.node;\n  if (!node) return;\n\n  var key = type + \"Comments\";\n\n  if (node[key]) {\n    node[key] = node[key].concat(comments);\n  } else {\n    node[key] = comments;\n  }\n}","\n\nexports.__esModule = true;\nexports.explode = explode;\nexports.verify = verify;\nexports.merge = merge;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _pathLibVirtualTypes = require(\"./path/lib/virtual-types\");\n\nvar virtualTypes = _interopRequireWildcard(_pathLibVirtualTypes);\n\nvar _messages = require(\"../messages\");\n\nvar messages = _interopRequireWildcard(_messages);\n\nvar _types = require(\"../types\");\n\nvar t = _interopRequireWildcard(_types);\n\nvar _lodashLangClone = require(\"lodash/lang/clone\");\n\nvar _lodashLangClone2 = _interopRequireDefault(_lodashLangClone);\n\n/**\n * [Please add a description.]\n */\n\nfunction explode(visitor) {\n  if (visitor._exploded) return visitor;\n  visitor._exploded = true;\n\n  // normalise pipes\n  for (var nodeType in visitor) {\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    var parts = nodeType.split(\"|\");\n    if (parts.length === 1) continue;\n\n    var fns = visitor[nodeType];\n    delete visitor[nodeType];\n\n    var _arr = parts;\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var part = _arr[_i];\n      visitor[part] = fns;\n    }\n  }\n\n  // verify data structure\n  verify(visitor);\n\n  // make sure there's no __esModule type since this is because we're using loose mode\n  // and it sets __esModule to be enumerable on all modules :(\n  delete visitor.__esModule;\n\n  // ensure visitors are objects\n  ensureEntranceObjects(visitor);\n\n  // ensure enter/exit callbacks are arrays\n  ensureCallbackArrays(visitor);\n\n  // add type wrappers\n\n  var _arr2 = Object.keys(visitor);\n\n  for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n    var nodeType = _arr2[_i2];\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    var wrapper = virtualTypes[nodeType];\n    if (!wrapper) continue;\n\n    // wrap all the functions\n    var fns = visitor[nodeType];\n    for (var type in fns) {\n      fns[type] = wrapCheck(wrapper, fns[type]);\n    }\n\n    // clear it from the visitor\n    delete visitor[nodeType];\n\n    if (wrapper.types) {\n      var _arr4 = wrapper.types;\n\n      for (var _i4 = 0; _i4 < _arr4.length; _i4++) {\n        var type = _arr4[_i4];\n        // merge the visitor if necessary or just put it back in\n        if (visitor[type]) {\n          mergePair(visitor[type], fns);\n        } else {\n          visitor[type] = fns;\n        }\n      }\n    } else {\n      mergePair(visitor, fns);\n    }\n  }\n\n  // add aliases\n  for (var nodeType in visitor) {\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    var fns = visitor[nodeType];\n\n    var aliases = t.FLIPPED_ALIAS_KEYS[nodeType];\n    if (!aliases) continue;\n\n    // clear it from the visitor\n    delete visitor[nodeType];\n\n    var _arr3 = aliases;\n    for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n      var alias = _arr3[_i3];\n      var existing = visitor[alias];\n      if (existing) {\n        mergePair(existing, fns);\n      } else {\n        visitor[alias] = _lodashLangClone2[\"default\"](fns);\n      }\n    }\n  }\n\n  for (var nodeType in visitor) {\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    ensureCallbackArrays(visitor[nodeType]);\n  }\n\n  return visitor;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction verify(visitor) {\n  if (visitor._verified) return;\n\n  if (typeof visitor === \"function\") {\n    throw new Error(messages.get(\"traverseVerifyRootFunction\"));\n  }\n\n  for (var nodeType in visitor) {\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    if (t.TYPES.indexOf(nodeType) < 0) {\n      throw new Error(messages.get(\"traverseVerifyNodeType\", nodeType));\n    }\n\n    var visitors = visitor[nodeType];\n    if (typeof visitors === \"object\") {\n      for (var visitorKey in visitors) {\n        if (visitorKey === \"enter\" || visitorKey === \"exit\") continue;\n        throw new Error(messages.get(\"traverseVerifyVisitorProperty\", nodeType, visitorKey));\n      }\n    }\n  }\n\n  visitor._verified = true;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction merge(visitors) {\n  var rootVisitor = {};\n\n  var _arr5 = visitors;\n  for (var _i5 = 0; _i5 < _arr5.length; _i5++) {\n    var visitor = _arr5[_i5];\n    explode(visitor);\n\n    for (var type in visitor) {\n      var nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};\n      mergePair(nodeVisitor, visitor[type]);\n    }\n  }\n\n  return rootVisitor;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction ensureEntranceObjects(obj) {\n  for (var key in obj) {\n    if (shouldIgnoreKey(key)) continue;\n\n    var fns = obj[key];\n    if (typeof fns === \"function\") {\n      obj[key] = { enter: fns };\n    }\n  }\n}\n\n/**\n * Makes sure that enter and exit callbacks are arrays.\n */\n\nfunction ensureCallbackArrays(obj) {\n  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];\n  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction wrapCheck(wrapper, fn) {\n  return function () {\n    if (wrapper.checkPath(this)) {\n      return fn.apply(this, arguments);\n    }\n  };\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction shouldIgnoreKey(key) {\n  // internal/hidden key\n  if (key[0] === \"_\") return true;\n\n  // ignore function keys\n  if (key === \"enter\" || key === \"exit\" || key === \"shouldSkip\") return true;\n\n  // ignore other options\n  if (key === \"blacklist\" || key === \"noScope\" || key === \"skipKeys\") return true;\n\n  return false;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction mergePair(dest, src) {\n  for (var key in src) {\n    dest[key] = [].concat(dest[key] || [], src[key]);\n  }\n}","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// istanbul ignore next\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _convertSourceMap = require(\"convert-source-map\");\n\nvar _convertSourceMap2 = _interopRequireDefault(_convertSourceMap);\n\nvar _modules = require(\"../modules\");\n\nvar _modules2 = _interopRequireDefault(_modules);\n\nvar _optionsOptionManager = require(\"./options/option-manager\");\n\nvar _optionsOptionManager2 = _interopRequireDefault(_optionsOptionManager);\n\nvar _pluginManager = require(\"./plugin-manager\");\n\nvar _pluginManager2 = _interopRequireDefault(_pluginManager);\n\nvar _shebangRegex = require(\"shebang-regex\");\n\nvar _shebangRegex2 = _interopRequireDefault(_shebangRegex);\n\nvar _traversalPath = require(\"../../traversal/path\");\n\nvar _traversalPath2 = _interopRequireDefault(_traversalPath);\n\nvar _lodashLangIsFunction = require(\"lodash/lang/isFunction\");\n\nvar _lodashLangIsFunction2 = _interopRequireDefault(_lodashLangIsFunction);\n\nvar _sourceMap = require(\"source-map\");\n\nvar _sourceMap2 = _interopRequireDefault(_sourceMap);\n\nvar _generation = require(\"../../generation\");\n\nvar _generation2 = _interopRequireDefault(_generation);\n\nvar _helpersCodeFrame = require(\"../../helpers/code-frame\");\n\nvar _helpersCodeFrame2 = _interopRequireDefault(_helpersCodeFrame);\n\nvar _lodashObjectDefaults = require(\"lodash/object/defaults\");\n\nvar _lodashObjectDefaults2 = _interopRequireDefault(_lodashObjectDefaults);\n\nvar _lodashCollectionIncludes = require(\"lodash/collection/includes\");\n\nvar _lodashCollectionIncludes2 = _interopRequireDefault(_lodashCollectionIncludes);\n\nvar _traversal = require(\"../../traversal\");\n\nvar _traversal2 = _interopRequireDefault(_traversal);\n\nvar _tryResolve = require(\"try-resolve\");\n\nvar _tryResolve2 = _interopRequireDefault(_tryResolve);\n\nvar _logger = require(\"./logger\");\n\nvar _logger2 = _interopRequireDefault(_logger);\n\nvar _plugin = require(\"../plugin\");\n\nvar _plugin2 = _interopRequireDefault(_plugin);\n\nvar _helpersParse = require(\"../../helpers/parse\");\n\nvar _helpersParse2 = _interopRequireDefault(_helpersParse);\n\nvar _traversalHub = require(\"../../traversal/hub\");\n\nvar _traversalHub2 = _interopRequireDefault(_traversalHub);\n\nvar _util = require(\"../../util\");\n\nvar util = _interopRequireWildcard(_util);\n\nvar _path = require(\"path\");\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nvar File = (function () {\n  function File(opts, pipeline) {\n    if (opts === undefined) opts = {};\n\n    _classCallCheck(this, File);\n\n    this.transformerDependencies = {};\n    this.dynamicImportTypes = {};\n    this.dynamicImportIds = {};\n    this.dynamicImports = [];\n    this.declarations = {};\n    this.usedHelpers = {};\n    this.dynamicData = {};\n    this.data = {};\n    this.ast = {};\n    this.metadata = {\n      modules: {\n        imports: [],\n        exports: {\n          exported: [],\n          specifiers: []\n        }\n      }\n    };\n    this.hub = new _traversalHub2[\"default\"](this);\n\n    this.pipeline = pipeline;\n\n    this.log = new _logger2[\"default\"](this, opts.filename || \"unknown\");\n    this.opts = this.initOptions(opts);\n\n    this.buildTransformers();\n  }\n\n  /**\n   * [Please add a description.]\n   */\n\n  File.prototype.initOptions = function initOptions(opts) {\n    opts = new _optionsOptionManager2[\"default\"](this.log, this.pipeline).init(opts);\n\n    if (opts.inputSourceMap) {\n      opts.sourceMaps = true;\n    }\n\n    if (opts.moduleId) {\n      opts.moduleIds = true;\n    }\n\n    opts.basename = _path2[\"default\"].basename(opts.filename, _path2[\"default\"].extname(opts.filename));\n\n    opts.ignore = util.arrayify(opts.ignore, util.regexify);\n\n    if (opts.only) opts.only = util.arrayify(opts.only, util.regexify);\n\n    _lodashObjectDefaults2[\"default\"](opts, {\n      moduleRoot: opts.sourceRoot\n    });\n\n    _lodashObjectDefaults2[\"default\"](opts, {\n      sourceRoot: opts.moduleRoot\n    });\n\n    _lodashObjectDefaults2[\"default\"](opts, {\n      filenameRelative: opts.filename\n    });\n\n    _lodashObjectDefaults2[\"default\"](opts, {\n      sourceFileName: opts.filenameRelative,\n      sourceMapTarget: opts.filenameRelative\n    });\n\n    //\n\n    if (opts.externalHelpers) {\n      this.set(\"helpersNamespace\", t.identifier(\"babelHelpers\"));\n    }\n\n    return opts;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  File.prototype.isLoose = function isLoose(key) {\n    return _lodashCollectionIncludes2[\"default\"](this.opts.loose, key);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  File.prototype.buildTransformers = function buildTransformers() {\n    var file = this;\n\n    var transformers = this.transformers = {};\n\n    var secondaryStack = [];\n    var stack = [];\n\n    // build internal transformers\n    for (var key in this.pipeline.transformers) {\n      var transformer = this.pipeline.transformers[key];\n      var pass = transformers[key] = transformer.buildPass(file);\n\n      if (pass.canTransform()) {\n        stack.push(pass);\n\n        if (transformer.metadata.secondPass) {\n          secondaryStack.push(pass);\n        }\n\n        if (transformer.manipulateOptions) {\n          transformer.manipulateOptions(file.opts, file);\n        }\n      }\n    }\n\n    // init plugins!\n    var beforePlugins = [];\n    var afterPlugins = [];\n    var pluginManager = new _pluginManager2[\"default\"]({\n      file: this,\n      transformers: this.transformers,\n      before: beforePlugins,\n      after: afterPlugins\n    });\n    for (var i = 0; i < file.opts.plugins.length; i++) {\n      pluginManager.add(file.opts.plugins[i]);\n    }\n    stack = beforePlugins.concat(stack, afterPlugins);\n\n    // build transformer stack\n    this.uncollapsedTransformerStack = stack = stack.concat(secondaryStack);\n\n    // build dependency graph\n    var _arr = stack;\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var pass = _arr[_i];var _arr2 = pass.plugin.dependencies;\n\n      for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n        var dep = _arr2[_i2];\n        this.transformerDependencies[dep] = pass.key;\n      }\n    }\n\n    // collapse stack categories\n    this.transformerStack = this.collapseStack(stack);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  File.prototype.collapseStack = function collapseStack(_stack) {\n    var stack = [];\n    var ignore = [];\n\n    var _arr3 = _stack;\n    for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n      var pass = _arr3[_i3];\n      // been merged\n      if (ignore.indexOf(pass) >= 0) continue;\n\n      var group = pass.plugin.metadata.group;\n\n      // can't merge\n      if (!pass.canTransform() || !group) {\n        stack.push(pass);\n        continue;\n      }\n\n      var mergeStack = [];\n      var _arr4 = _stack;\n      for (var _i4 = 0; _i4 < _arr4.length; _i4++) {\n        var _pass = _arr4[_i4];\n        if (_pass.plugin.metadata.group === group) {\n          mergeStack.push(_pass);\n          ignore.push(_pass);\n        }\n      }\n\n      var visitors = [];\n      var _arr5 = mergeStack;\n      for (var _i5 = 0; _i5 < _arr5.length; _i5++) {\n        var _pass2 = _arr5[_i5];\n        visitors.push(_pass2.plugin.visitor);\n      }\n      var visitor = _traversal2[\"default\"].visitors.merge(visitors);\n      var mergePlugin = new _plugin2[\"default\"](group, { visitor: visitor });\n      stack.push(mergePlugin.buildPass(this));\n    }\n\n    return stack;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  File.prototype.set = function set(key, val) {\n    return this.data[key] = val;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  File.prototype.setDynamic = function setDynamic(key, fn) {\n    this.dynamicData[key] = fn;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  File.prototype.get = function get(key) {\n    var data = this.data[key];\n    if (data) {\n      return data;\n    } else {\n      var dynamic = this.dynamicData[key];\n      if (dynamic) {\n        return this.set(key, dynamic());\n      }\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  File.prototype.resolveModuleSource = function resolveModuleSource(source) {\n    var resolveModuleSource = this.opts.resolveModuleSource;\n    if (resolveModuleSource) source = resolveModuleSource(source, this.opts.filename);\n    return source;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  File.prototype.addImport = function addImport(source, name, type) {\n    name = name || source;\n    var id = this.dynamicImportIds[name];\n\n    if (!id) {\n      source = this.resolveModuleSource(source);\n      id = this.dynamicImportIds[name] = this.scope.generateUidIdentifier(name);\n\n      var specifiers = [t.importDefaultSpecifier(id)];\n      var declar = t.importDeclaration(specifiers, t.literal(source));\n      declar._blockHoist = 3;\n\n      if (type) {\n        var modules = this.dynamicImportTypes[type] = this.dynamicImportTypes[type] || [];\n        modules.push(declar);\n      }\n\n      if (this.transformers[\"es6.modules\"].canTransform()) {\n        this.moduleFormatter.importSpecifier(specifiers[0], declar, this.dynamicImports, this.scope);\n        this.moduleFormatter.hasLocalImports = true;\n      } else {\n        this.dynamicImports.push(declar);\n      }\n    }\n\n    return id;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  File.prototype.attachAuxiliaryComment = function attachAuxiliaryComment(node) {\n    var beforeComment = this.opts.auxiliaryCommentBefore;\n    if (beforeComment) {\n      node.leadingComments = node.leadingComments || [];\n      node.leadingComments.push({\n        type: \"CommentLine\",\n        value: \" \" + beforeComment\n      });\n    }\n\n    var afterComment = this.opts.auxiliaryCommentAfter;\n    if (afterComment) {\n      node.trailingComments = node.trailingComments || [];\n      node.trailingComments.push({\n        type: \"CommentLine\",\n        value: \" \" + afterComment\n      });\n    }\n\n    return node;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  File.prototype.addHelper = function addHelper(name) {\n    var isSolo = _lodashCollectionIncludes2[\"default\"](File.soloHelpers, name);\n\n    if (!isSolo && !_lodashCollectionIncludes2[\"default\"](File.helpers, name)) {\n      throw new ReferenceError(\"Unknown helper \" + name);\n    }\n\n    var declar = this.declarations[name];\n    if (declar) return declar;\n\n    this.usedHelpers[name] = true;\n\n    if (!isSolo) {\n      var generator = this.get(\"helperGenerator\");\n      var runtime = this.get(\"helpersNamespace\");\n      if (generator) {\n        return generator(name);\n      } else if (runtime) {\n        var id = t.identifier(t.toIdentifier(name));\n        return t.memberExpression(runtime, id);\n      }\n    }\n\n    var ref = util.template(\"helper-\" + name);\n\n    var uid = this.declarations[name] = this.scope.generateUidIdentifier(name);\n\n    if (t.isFunctionExpression(ref) && !ref.id) {\n      ref.body._compact = true;\n      ref._generated = true;\n      ref.id = uid;\n      ref.type = \"FunctionDeclaration\";\n      this.attachAuxiliaryComment(ref);\n      this.path.unshiftContainer(\"body\", ref);\n    } else {\n      ref._compact = true;\n      this.scope.push({\n        id: uid,\n        init: ref,\n        unique: true\n      });\n    }\n\n    return uid;\n  };\n\n  File.prototype.addTemplateObject = function addTemplateObject(helperName, strings, raw) {\n    // Generate a unique name based on the string literals so we dedupe\n    // identical strings used in the program.\n    var stringIds = raw.elements.map(function (string) {\n      return string.value;\n    });\n    var name = helperName + \"_\" + raw.elements.length + \"_\" + stringIds.join(\",\");\n\n    var declar = this.declarations[name];\n    if (declar) return declar;\n\n    var uid = this.declarations[name] = this.scope.generateUidIdentifier(\"templateObject\");\n\n    var helperId = this.addHelper(helperName);\n    var init = t.callExpression(helperId, [strings, raw]);\n    init._compact = true;\n    this.scope.push({\n      id: uid,\n      init: init,\n      _blockHoist: 1.9 // This ensures that we don't fail if not using function expression helpers\n    });\n    return uid;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  File.prototype.errorWithNode = function errorWithNode(node, msg) {\n    var Error = arguments.length <= 2 || arguments[2] === undefined ? SyntaxError : arguments[2];\n\n    var err;\n    var loc = node && (node.loc || node._loc);\n    if (loc) {\n      err = new Error(\"Line \" + loc.start.line + \": \" + msg);\n      err.loc = loc.start;\n    } else {\n      // todo: find errors with nodes inside to at least point to something\n      err = new Error(\"There's been an error on a dynamic node. This is almost certainly an internal error. Please report it.\");\n    }\n    return err;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  File.prototype.mergeSourceMap = function mergeSourceMap(map) {\n    var opts = this.opts;\n\n    var inputMap = opts.inputSourceMap;\n\n    if (inputMap) {\n      map.sources[0] = inputMap.file;\n\n      var inputMapConsumer = new _sourceMap2[\"default\"].SourceMapConsumer(inputMap);\n      var outputMapConsumer = new _sourceMap2[\"default\"].SourceMapConsumer(map);\n      var outputMapGenerator = _sourceMap2[\"default\"].SourceMapGenerator.fromSourceMap(outputMapConsumer);\n      outputMapGenerator.applySourceMap(inputMapConsumer);\n\n      var mergedMap = outputMapGenerator.toJSON();\n      mergedMap.sources = inputMap.sources;\n      mergedMap.file = inputMap.file;\n      return mergedMap;\n    }\n\n    return map;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  File.prototype.getModuleFormatter = function getModuleFormatter(type) {\n    if (_lodashLangIsFunction2[\"default\"](type) || !_modules2[\"default\"][type]) {\n      this.log.deprecate(\"Custom module formatters are deprecated and will be removed in the next major. Please use Babel plugins instead.\");\n    }\n\n    var ModuleFormatter = _lodashLangIsFunction2[\"default\"](type) ? type : _modules2[\"default\"][type];\n\n    if (!ModuleFormatter) {\n      var loc = _tryResolve2[\"default\"].relative(type);\n      if (loc) ModuleFormatter = require(loc);\n    }\n\n    if (!ModuleFormatter) {\n      throw new ReferenceError(\"Unknown module formatter type \" + JSON.stringify(type));\n    }\n\n    return new ModuleFormatter(this);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  File.prototype.parse = function parse(code) {\n    var opts = this.opts;\n\n    //\n\n    var parseOpts = {\n      highlightCode: opts.highlightCode,\n      nonStandard: opts.nonStandard,\n      sourceType: opts.sourceType,\n      filename: opts.filename,\n      plugins: {}\n    };\n\n    var features = parseOpts.features = {};\n    for (var key in this.transformers) {\n      var transformer = this.transformers[key];\n      features[key] = transformer.canTransform();\n    }\n\n    parseOpts.looseModules = this.isLoose(\"es6.modules\");\n    parseOpts.strictMode = features.strict;\n\n    this.log.debug(\"Parse start\");\n    var ast = _helpersParse2[\"default\"](code, parseOpts);\n    this.log.debug(\"Parse stop\");\n    return ast;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  File.prototype._addAst = function _addAst(ast) {\n    this.path = _traversalPath2[\"default\"].get({\n      hub: this.hub,\n      parentPath: null,\n      parent: ast,\n      container: ast,\n      key: \"program\"\n    }).setContext();\n    this.scope = this.path.scope;\n    this.ast = ast;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  File.prototype.addAst = function addAst(ast) {\n    this.log.debug(\"Start set AST\");\n    this._addAst(ast);\n    this.log.debug(\"End set AST\");\n\n    this.log.debug(\"Start module formatter init\");\n    var modFormatter = this.moduleFormatter = this.getModuleFormatter(this.opts.modules);\n    if (modFormatter.init && this.transformers[\"es6.modules\"].canTransform()) {\n      modFormatter.init();\n    }\n    this.log.debug(\"End module formatter init\");\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  File.prototype.transform = function transform() {\n    this.call(\"pre\");\n    var _arr6 = this.transformerStack;\n    for (var _i6 = 0; _i6 < _arr6.length; _i6++) {\n      var pass = _arr6[_i6];\n      pass.transform();\n    }\n    this.call(\"post\");\n\n    return this.generate();\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  File.prototype.wrap = function wrap(code, callback) {\n    code = code + \"\";\n\n    try {\n      if (this.shouldIgnore()) {\n        return this.makeResult({ code: code, ignored: true });\n      } else {\n        return callback();\n      }\n    } catch (err) {\n      if (err._babel) {\n        throw err;\n      } else {\n        err._babel = true;\n      }\n\n      var message = err.message = this.opts.filename + \": \" + err.message;\n\n      var loc = err.loc;\n      if (loc) {\n        err.codeFrame = _helpersCodeFrame2[\"default\"](code, loc.line, loc.column + 1, this.opts);\n        message += \"\\n\" + err.codeFrame;\n      }\n\n      if (process.browser) {\n        // chrome has it's own pretty stringifier which doesn't use the stack property\n        // https://github.com/babel/babel/issues/2175\n        err.message = message;\n      }\n\n      if (err.stack) {\n        var newStack = err.stack.replace(err.message, message);\n        try {\n          err.stack = newStack;\n        } catch (e) {\n          // `err.stack` may be a readonly property in some environments\n        }\n      }\n\n      throw err;\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  File.prototype.addCode = function addCode(code) {\n    code = (code || \"\") + \"\";\n    code = this.parseInputSourceMap(code);\n    this.code = code;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  File.prototype.parseCode = function parseCode() {\n    this.parseShebang();\n    var ast = this.parse(this.code);\n    this.addAst(ast);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  File.prototype.shouldIgnore = function shouldIgnore() {\n    var opts = this.opts;\n    return util.shouldIgnore(opts.filename, opts.ignore, opts.only);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  File.prototype.call = function call(key) {\n    var _arr7 = this.uncollapsedTransformerStack;\n\n    for (var _i7 = 0; _i7 < _arr7.length; _i7++) {\n      var pass = _arr7[_i7];\n      var fn = pass.plugin[key];\n      if (fn) fn(this);\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  File.prototype.parseInputSourceMap = function parseInputSourceMap(code) {\n    var opts = this.opts;\n\n    if (opts.inputSourceMap !== false) {\n      var inputMap = _convertSourceMap2[\"default\"].fromSource(code);\n      if (inputMap) {\n        opts.inputSourceMap = inputMap.toObject();\n        code = _convertSourceMap2[\"default\"].removeComments(code);\n      }\n    }\n\n    return code;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  File.prototype.parseShebang = function parseShebang() {\n    var shebangMatch = _shebangRegex2[\"default\"].exec(this.code);\n    if (shebangMatch) {\n      this.shebang = shebangMatch[0];\n      this.code = this.code.replace(_shebangRegex2[\"default\"], \"\");\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  File.prototype.makeResult = function makeResult(_ref) {\n    var code = _ref.code;\n    var _ref$map = _ref.map;\n    var map = _ref$map === undefined ? null : _ref$map;\n    var ast = _ref.ast;\n    var ignored = _ref.ignored;\n\n    var result = {\n      metadata: null,\n      ignored: !!ignored,\n      code: null,\n      ast: null,\n      map: map\n    };\n\n    if (this.opts.code) {\n      result.code = code;\n    }\n\n    if (this.opts.ast) {\n      result.ast = ast;\n    }\n\n    if (this.opts.metadata) {\n      result.metadata = this.metadata;\n      result.metadata.usedHelpers = Object.keys(this.usedHelpers);\n    }\n\n    return result;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  File.prototype.generate = function generate() {\n    var opts = this.opts;\n    var ast = this.ast;\n\n    var result = { ast: ast };\n    if (!opts.code) return this.makeResult(result);\n\n    this.log.debug(\"Generation start\");\n\n    var _result = _generation2[\"default\"](ast, opts, this.code);\n    result.code = _result.code;\n    result.map = _result.map;\n\n    this.log.debug(\"Generation end\");\n\n    if (this.shebang) {\n      // add back shebang\n      result.code = this.shebang + \"\\n\" + result.code;\n    }\n\n    if (result.map) {\n      result.map = this.mergeSourceMap(result.map);\n    }\n\n    if (opts.sourceMaps === \"inline\" || opts.sourceMaps === \"both\") {\n      result.code += \"\\n\" + _convertSourceMap2[\"default\"].fromObject(result.map).toComment();\n    }\n\n    if (opts.sourceMaps === \"inline\") {\n      result.map = null;\n    }\n\n    return this.makeResult(result);\n  };\n\n  _createClass(File, null, [{\n    key: \"helpers\",\n\n    /**\n     * [Please add a description.]\n     */\n\n    value: [\"inherits\", \"defaults\", \"create-class\", \"create-decorated-class\", \"create-decorated-object\", \"define-decorated-property-descriptor\", \"tagged-template-literal\", \"tagged-template-literal-loose\", \"to-array\", \"to-consumable-array\", \"sliced-to-array\", \"sliced-to-array-loose\", \"object-without-properties\", \"has-own\", \"slice\", \"bind\", \"define-property\", \"async-to-generator\", \"interop-export-wildcard\", \"interop-require-wildcard\", \"interop-require-default\", \"typeof\", \"extends\", \"get\", \"set\", \"new-arrow-check\", \"class-call-check\", \"object-destructuring-empty\", \"temporal-undefined\", \"temporal-assert-defined\", \"self-global\", \"typeof-react-element\", \"default-props\", \"instanceof\",\n\n    // legacy\n    \"interop-require\"],\n\n    /**\n     * [Please add a description.]\n     */\n\n    enumerable: true\n  }, {\n    key: \"soloHelpers\",\n    value: [],\n    enumerable: true\n  }]);\n\n  return File;\n})();\n\nexports[\"default\"] = File;\nmodule.exports = exports[\"default\"];","/**\n * [Please add a description.]\n */\n\n\n\nexports.__esModule = true;\nexports[\"default\"] = {\n  commonStrict: require(\"./common-strict\"),\n  amdStrict: require(\"./amd-strict\"),\n  umdStrict: require(\"./umd-strict\"),\n  common: require(\"./common\"),\n  system: require(\"./system\"),\n  ignore: require(\"./ignore\"),\n  amd: require(\"./amd\"),\n  umd: require(\"./umd\")\n};\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _common = require(\"./common\");\n\nvar _common2 = _interopRequireDefault(_common);\n\nvar _strict = require(\"./_strict\");\n\nvar _strict2 = _interopRequireDefault(_strict);\n\n/**\n * [Please add a description.]\n */\n\nexports[\"default\"] = _strict2[\"default\"](_common2[\"default\"]);\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// istanbul ignore next\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// istanbul ignore next\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _default = require(\"./_default\");\n\nvar _default2 = _interopRequireDefault(_default);\n\nvar _util = require(\"../../util\");\n\nvar util = _interopRequireWildcard(_util);\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nvar CommonJSFormatter = (function (_DefaultFormatter) {\n  _inherits(CommonJSFormatter, _DefaultFormatter);\n\n  function CommonJSFormatter() {\n    _classCallCheck(this, CommonJSFormatter);\n\n    _DefaultFormatter.apply(this, arguments);\n  }\n\n  /**\n   * [Please add a description.]\n   */\n\n  CommonJSFormatter.prototype.setup = function setup() {\n    this._setup(this.hasLocalExports);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  CommonJSFormatter.prototype._setup = function _setup(conditional) {\n    var file = this.file;\n    var scope = file.scope;\n\n    scope.rename(\"module\");\n    scope.rename(\"exports\");\n\n    if (!this.noInteropRequireImport && conditional) {\n      var templateName = \"exports-module-declaration\";\n      if (this.file.isLoose(\"es6.modules\")) templateName += \"-loose\";\n      var declar = util.template(templateName, true);\n      declar._blockHoist = 3;\n      file.path.unshiftContainer(\"body\", [declar]);\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  CommonJSFormatter.prototype.transform = function transform(program) {\n    _default2[\"default\"].prototype.transform.apply(this, arguments);\n\n    if (this.hasDefaultOnlyExport) {\n      program.body.push(t.expressionStatement(t.assignmentExpression(\"=\", t.memberExpression(t.identifier(\"module\"), t.identifier(\"exports\")), t.memberExpression(t.identifier(\"exports\"), t.identifier(\"default\")))));\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  CommonJSFormatter.prototype.importSpecifier = function importSpecifier(specifier, node, nodes, scope) {\n    var variableName = specifier.local;\n\n    var ref = this.getExternalReference(node, nodes);\n\n    // import foo from \"foo\";\n    if (t.isSpecifierDefault(specifier)) {\n      if (this.isModuleType(node, \"absolute\")) {\n        // absolute module reference\n      } else if (this.isModuleType(node, \"absoluteDefault\")) {\n          this.remaps.add(scope, variableName.name, ref);\n        } else if (this.noInteropRequireImport) {\n          this.remaps.add(scope, variableName.name, t.memberExpression(ref, t.identifier(\"default\")));\n        } else {\n          var uid = this.scope.generateUidIdentifierBasedOnNode(node, \"import\");\n\n          nodes.push(t.variableDeclaration(\"var\", [t.variableDeclarator(uid, t.callExpression(this.file.addHelper(\"interop-require-default\"), [ref]))]));\n\n          this.remaps.add(scope, variableName.name, t.memberExpression(uid, t.identifier(\"default\")));\n        }\n    } else {\n      if (t.isImportNamespaceSpecifier(specifier)) {\n        if (!this.noInteropRequireImport) {\n          ref = t.callExpression(this.file.addHelper(\"interop-require-wildcard\"), [ref]);\n        }\n\n        // import * as bar from \"foo\";\n        nodes.push(t.variableDeclaration(\"var\", [t.variableDeclarator(variableName, ref)]));\n      } else {\n        // import { foo } from \"foo\";\n        this.remaps.add(scope, variableName.name, t.memberExpression(ref, t.identifier(specifier.imported.name)));\n      }\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  CommonJSFormatter.prototype.importDeclaration = function importDeclaration(node, nodes) {\n    // import \"foo\";\n    nodes.push(util.template(\"require\", {\n      MODULE_NAME: node.source\n    }, true));\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  CommonJSFormatter.prototype.exportSpecifier = function exportSpecifier(specifier) {\n    if (this.doDefaultExportInterop(specifier)) {\n      this.hasDefaultOnlyExport = true;\n    }\n\n    _default2[\"default\"].prototype.exportSpecifier.apply(this, arguments);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  CommonJSFormatter.prototype.exportDeclaration = function exportDeclaration(node) {\n    if (this.doDefaultExportInterop(node)) {\n      this.hasDefaultOnlyExport = true;\n    }\n\n    _default2[\"default\"].prototype.exportDeclaration.apply(this, arguments);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  CommonJSFormatter.prototype._getExternalReference = function _getExternalReference(node, nodes) {\n    var call = t.callExpression(t.identifier(\"require\"), [node.source]);\n    var uid;\n\n    if (this.isModuleType(node, \"absolute\")) {\n      // absolute module reference\n    } else if (this.isModuleType(node, \"absoluteDefault\")) {\n        call = t.memberExpression(call, t.identifier(\"default\"));\n      } else {\n        uid = this.scope.generateUidIdentifierBasedOnNode(node, \"import\");\n      }\n\n    uid = uid || node.specifiers[0].local;\n\n    var declar = t.variableDeclaration(\"var\", [t.variableDeclarator(uid, call)]);\n    nodes.push(declar);\n    return uid;\n  };\n\n  return CommonJSFormatter;\n})(_default2[\"default\"]);\n\nexports[\"default\"] = CommonJSFormatter;\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _libMetadata = require(\"./lib/metadata\");\n\nvar metadataVisitor = _interopRequireWildcard(_libMetadata);\n\nvar _messages = require(\"../../messages\");\n\nvar messages = _interopRequireWildcard(_messages);\n\nvar _libRemaps = require(\"./lib/remaps\");\n\nvar _libRemaps2 = _interopRequireDefault(_libRemaps);\n\nvar _helpersObject = require(\"../../helpers/object\");\n\nvar _helpersObject2 = _interopRequireDefault(_helpersObject);\n\nvar _util = require(\"../../util\");\n\nvar util = _interopRequireWildcard(_util);\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nvar DefaultFormatter = (function () {\n  function DefaultFormatter(file) {\n    _classCallCheck(this, DefaultFormatter);\n\n    // object containg all module sources with the scope that they're contained in\n    this.sourceScopes = _helpersObject2[\"default\"]();\n\n    // ids for use in module ids\n    this.defaultIds = _helpersObject2[\"default\"]();\n    this.ids = _helpersObject2[\"default\"]();\n\n    // contains reference aliases for live bindings\n    this.remaps = new _libRemaps2[\"default\"](file, this);\n\n    this.scope = file.scope;\n    this.file = file;\n\n    this.hasNonDefaultExports = false;\n\n    this.hasLocalExports = false;\n    this.hasLocalImports = false;\n\n    this.localExports = _helpersObject2[\"default\"]();\n    this.localImports = _helpersObject2[\"default\"]();\n\n    this.metadata = file.metadata.modules;\n    this.getMetadata();\n  }\n\n  /**\n   * [Please add a description.]\n   */\n\n  DefaultFormatter.prototype.addScope = function addScope(path) {\n    var source = path.node.source && path.node.source.value;\n    if (!source) return;\n\n    var existingScope = this.sourceScopes[source];\n    if (existingScope && existingScope !== path.scope) {\n      throw path.errorWithNode(messages.get(\"modulesDuplicateDeclarations\"));\n    }\n\n    this.sourceScopes[source] = path.scope;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  DefaultFormatter.prototype.isModuleType = function isModuleType(node, type) {\n    var modules = this.file.dynamicImportTypes[type];\n    return modules && modules.indexOf(node) >= 0;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  DefaultFormatter.prototype.transform = function transform() {\n    this.remapAssignments();\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  DefaultFormatter.prototype.doDefaultExportInterop = function doDefaultExportInterop(node) {\n    return (t.isExportDefaultDeclaration(node) || t.isSpecifierDefault(node)) && !this.noInteropRequireExport && !this.hasNonDefaultExports;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  DefaultFormatter.prototype.getMetadata = function getMetadata() {\n    var has = false;\n    var _arr = this.file.ast.program.body;\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var node = _arr[_i];\n      if (t.isModuleDeclaration(node)) {\n        has = true;\n        break;\n      }\n    }\n    if (has || this.isLoose()) {\n      this.file.path.traverse(metadataVisitor, this);\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  DefaultFormatter.prototype.remapAssignments = function remapAssignments() {\n    if (this.hasLocalExports || this.hasLocalImports) {\n      this.remaps.run();\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  DefaultFormatter.prototype.remapExportAssignment = function remapExportAssignment(node, exported) {\n    var assign = node;\n\n    for (var i = 0; i < exported.length; i++) {\n      assign = t.assignmentExpression(\"=\", t.memberExpression(t.identifier(\"exports\"), exported[i]), assign);\n    }\n\n    return assign;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  DefaultFormatter.prototype._addExport = function _addExport(name, exported) {\n    var info = this.localExports[name] = this.localExports[name] || {\n      binding: this.scope.getBindingIdentifier(name),\n      exported: []\n    };\n    info.exported.push(exported);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  DefaultFormatter.prototype.getExport = function getExport(node, scope) {\n    if (!t.isIdentifier(node)) return;\n\n    var local = this.localExports[node.name];\n    if (local && local.binding === scope.getBindingIdentifier(node.name)) {\n      return local.exported;\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  DefaultFormatter.prototype.getModuleName = function getModuleName() {\n    var opts = this.file.opts;\n    // moduleId is n/a if a `getModuleId()` is provided\n    if (opts.moduleId != null && !opts.getModuleId) {\n      return opts.moduleId;\n    }\n\n    var filenameRelative = opts.filenameRelative;\n    var moduleName = \"\";\n\n    if (opts.moduleRoot != null) {\n      moduleName = opts.moduleRoot + \"/\";\n    }\n\n    if (!opts.filenameRelative) {\n      return moduleName + opts.filename.replace(/^\\//, \"\");\n    }\n\n    if (opts.sourceRoot != null) {\n      // remove sourceRoot from filename\n      var sourceRootRegEx = new RegExp(\"^\" + opts.sourceRoot + \"\\/?\");\n      filenameRelative = filenameRelative.replace(sourceRootRegEx, \"\");\n    }\n\n    if (!opts.keepModuleIdExtensions) {\n      // remove extension\n      filenameRelative = filenameRelative.replace(/\\.(\\w*?)$/, \"\");\n    }\n\n    moduleName += filenameRelative;\n\n    // normalize path separators\n    moduleName = moduleName.replace(/\\\\/g, \"/\");\n\n    if (opts.getModuleId) {\n      // If return is falsy, assume they want us to use our generated default name\n      return opts.getModuleId(moduleName) || moduleName;\n    } else {\n      return moduleName;\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  DefaultFormatter.prototype._pushStatement = function _pushStatement(ref, nodes) {\n    if (t.isClass(ref) || t.isFunction(ref)) {\n      if (ref.id) {\n        nodes.push(t.toStatement(ref));\n        ref = ref.id;\n      }\n    }\n\n    return ref;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  DefaultFormatter.prototype._hoistExport = function _hoistExport(declar, assign, priority) {\n    if (t.isFunctionDeclaration(declar)) {\n      assign._blockHoist = priority || 2;\n    }\n\n    return assign;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  DefaultFormatter.prototype.getExternalReference = function getExternalReference(node, nodes) {\n    var ids = this.ids;\n    var id = node.source.value;\n\n    if (ids[id]) {\n      return ids[id];\n    } else {\n      return this.ids[id] = this._getExternalReference(node, nodes);\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  DefaultFormatter.prototype.checkExportIdentifier = function checkExportIdentifier(node) {\n    if (t.isIdentifier(node, { name: \"__esModule\" })) {\n      throw this.file.errorWithNode(node, messages.get(\"modulesIllegalExportName\", node.name));\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  DefaultFormatter.prototype.exportAllDeclaration = function exportAllDeclaration(node, nodes) {\n    var ref = this.getExternalReference(node, nodes);\n    nodes.push(this.buildExportsWildcard(ref, node));\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  DefaultFormatter.prototype.isLoose = function isLoose() {\n    return this.file.isLoose(\"es6.modules\");\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  DefaultFormatter.prototype.exportSpecifier = function exportSpecifier(specifier, node, nodes) {\n    if (node.source) {\n      var ref = this.getExternalReference(node, nodes);\n\n      if (specifier.local.name === \"default\" && !this.noInteropRequireExport) {\n        // importing a default so we need to normalize it\n        ref = t.callExpression(this.file.addHelper(\"interop-require\"), [ref]);\n      } else {\n        ref = t.memberExpression(ref, specifier.local);\n\n        if (!this.isLoose()) {\n          nodes.push(this.buildExportsFromAssignment(specifier.exported, ref, node));\n          return;\n        }\n      }\n\n      // export { foo } from \"test\";\n      nodes.push(this.buildExportsAssignment(specifier.exported, ref, node));\n    } else {\n      // export { foo };\n      nodes.push(this.buildExportsAssignment(specifier.exported, specifier.local, node));\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  DefaultFormatter.prototype.buildExportsWildcard = function buildExportsWildcard(objectIdentifier) {\n    return t.expressionStatement(t.callExpression(this.file.addHelper(\"defaults\"), [t.identifier(\"exports\"), t.callExpression(this.file.addHelper(\"interop-export-wildcard\"), [objectIdentifier, this.file.addHelper(\"defaults\")])]));\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  DefaultFormatter.prototype.buildExportsFromAssignment = function buildExportsFromAssignment(id, init) {\n    this.checkExportIdentifier(id);\n    return util.template(\"exports-from-assign\", {\n      INIT: init,\n      ID: t.literal(id.name)\n    }, true);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  DefaultFormatter.prototype.buildExportsAssignment = function buildExportsAssignment(id, init) {\n    this.checkExportIdentifier(id);\n    return util.template(\"exports-assign\", {\n      VALUE: init,\n      KEY: id\n    }, true);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  DefaultFormatter.prototype.exportDeclaration = function exportDeclaration(node, nodes) {\n    var declar = node.declaration;\n\n    var id = declar.id;\n\n    if (t.isExportDefaultDeclaration(node)) {\n      id = t.identifier(\"default\");\n    }\n\n    var assign;\n\n    if (t.isVariableDeclaration(declar)) {\n      for (var i = 0; i < declar.declarations.length; i++) {\n        var decl = declar.declarations[i];\n\n        decl.init = this.buildExportsAssignment(decl.id, decl.init, node).expression;\n\n        var newDeclar = t.variableDeclaration(declar.kind, [decl]);\n        if (i === 0) t.inherits(newDeclar, declar);\n        nodes.push(newDeclar);\n      }\n    } else {\n      var ref = declar;\n\n      if (t.isFunctionDeclaration(declar) || t.isClassDeclaration(declar)) {\n        ref = declar.id;\n        nodes.push(declar);\n      }\n\n      assign = this.buildExportsAssignment(id, ref, node);\n\n      nodes.push(assign);\n\n      this._hoistExport(declar, assign);\n    }\n  };\n\n  return DefaultFormatter;\n})();\n\nexports[\"default\"] = DefaultFormatter;\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\nexports.ExportDeclaration = ExportDeclaration;\nexports.Scope = Scope;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _lodashObjectExtend = require(\"lodash/object/extend\");\n\nvar _lodashObjectExtend2 = _interopRequireDefault(_lodashObjectExtend);\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nvar ModuleDeclaration = {\n  enter: function enter(node, parent, scope, formatter) {\n    if (node.source) {\n      node.source.value = formatter.file.resolveModuleSource(node.source.value);\n      formatter.addScope(this);\n    }\n  }\n};\n\nexports.ModuleDeclaration = ModuleDeclaration;\n/**\n * [Please add a description.]\n */\n\nvar ImportDeclaration = {\n  exit: function exit(node, parent, scope, formatter) {\n    formatter.hasLocalImports = true;\n\n    var specifiers = [];\n    var imported = [];\n    formatter.metadata.imports.push({\n      source: node.source.value,\n      imported: imported,\n      specifiers: specifiers\n    });\n\n    var _arr = this.get(\"specifiers\");\n\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var specifier = _arr[_i];\n      var ids = specifier.getBindingIdentifiers();\n      _lodashObjectExtend2[\"default\"](formatter.localImports, ids);\n\n      var local = specifier.node.local.name;\n\n      if (specifier.isImportDefaultSpecifier()) {\n        imported.push(\"default\");\n        specifiers.push({\n          kind: \"named\",\n          imported: \"default\",\n          local: local\n        });\n      }\n\n      if (specifier.isImportSpecifier()) {\n        var importedName = specifier.node.imported.name;\n        imported.push(importedName);\n        specifiers.push({\n          kind: \"named\",\n          imported: importedName,\n          local: local\n        });\n      }\n\n      if (specifier.isImportNamespaceSpecifier()) {\n        imported.push(\"*\");\n        specifiers.push({\n          kind: \"namespace\",\n          local: local\n        });\n      }\n    }\n  }\n};\n\nexports.ImportDeclaration = ImportDeclaration;\n/**\n * [Please add a description.]\n */\n\nfunction ExportDeclaration(node, parent, scope, formatter) {\n  formatter.hasLocalExports = true;\n\n  var source = node.source ? node.source.value : null;\n  var exports = formatter.metadata.exports;\n\n  // export function foo() {}\n  // export var foo = \"bar\";\n  var declar = this.get(\"declaration\");\n  if (declar.isStatement()) {\n    var bindings = declar.getBindingIdentifiers();\n\n    for (var name in bindings) {\n      var binding = bindings[name];\n      formatter._addExport(name, binding);\n\n      exports.exported.push(name);\n      exports.specifiers.push({\n        kind: \"local\",\n        local: name,\n        exported: this.isExportDefaultDeclaration() ? \"default\" : name\n      });\n    }\n  }\n\n  if (this.isExportNamedDeclaration() && node.specifiers) {\n    var _arr2 = node.specifiers;\n\n    for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n      var specifier = _arr2[_i2];\n      var exported = specifier.exported.name;\n      exports.exported.push(exported);\n\n      // export foo from \"bar\";\n      if (t.isExportDefaultSpecifier(specifier)) {\n        exports.specifiers.push({\n          kind: \"external\",\n          local: exported,\n          exported: exported,\n          source: source\n        });\n      }\n\n      // export * as foo from \"bar\";\n      if (t.isExportNamespaceSpecifier(specifier)) {\n        exports.specifiers.push({\n          kind: \"external-namespace\",\n          exported: exported,\n          source: source\n        });\n      }\n\n      var local = specifier.local;\n      if (!local) continue;\n\n      formatter._addExport(local.name, specifier.exported);\n\n      // export { foo } from \"bar\";\n      // export { foo as bar } from \"bar\";\n      if (source) {\n        exports.specifiers.push({\n          kind: \"external\",\n          local: local.name,\n          exported: exported,\n          source: source\n        });\n      }\n\n      // export { foo };\n      // export { foo as bar };\n      if (!source) {\n        exports.specifiers.push({\n          kind: \"local\",\n          local: local.name,\n          exported: exported\n        });\n      }\n    }\n  }\n\n  // export * from \"bar\";\n  if (this.isExportAllDeclaration()) {\n    exports.specifiers.push({\n      kind: \"external-all\",\n      source: source\n    });\n  }\n\n  if (!t.isExportDefaultDeclaration(node) && !declar.isTypeAlias()) {\n    var onlyDefault = node.specifiers && node.specifiers.length === 1 && t.isSpecifierDefault(node.specifiers[0]);\n    if (!onlyDefault) {\n      formatter.hasNonDefaultExports = true;\n    }\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction Scope(node, parent, scope, formatter) {\n  if (!formatter.isLoose()) {\n    this.skip();\n  }\n}","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nvar remapVisitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  enter: function enter(node) {\n    if (node._skipModulesRemap) {\n      return this.skip();\n    }\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope, remaps) {\n    var formatter = remaps.formatter;\n\n    var remap = remaps.get(scope, node.name);\n    if (!remap || node === remap) return;\n\n    if (!scope.hasBinding(node.name) || scope.bindingIdentifierEquals(node.name, formatter.localImports[node.name])) {\n      if (!formatter.isLoose() && this.key === \"callee\" && this.parentPath.isCallExpression()) {\n        return t.sequenceExpression([t.literal(0), remap]);\n      } else {\n        return remap;\n      }\n    }\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  AssignmentExpression: {\n    exit: function exit(node, parent, scope, _ref) {\n      var formatter = _ref.formatter;\n\n      if (!node._ignoreModulesRemap) {\n        var exported = formatter.getExport(node.left, scope);\n        if (exported) {\n          return formatter.remapExportAssignment(node, exported);\n        }\n      }\n    }\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  UpdateExpression: function UpdateExpression(node, parent, scope, _ref2) {\n    var formatter = _ref2.formatter;\n\n    var exported = formatter.getExport(node.argument, scope);\n    if (!exported) return;\n\n    this.skip();\n\n    // expand to long file assignment expression\n    var assign = t.assignmentExpression(node.operator[0] + \"=\", node.argument, t.literal(1));\n\n    // remap this assignment expression\n    var remapped = formatter.remapExportAssignment(assign, exported);\n\n    // we don't need to change the result\n    if (t.isExpressionStatement(parent) || node.prefix) {\n      return remapped;\n    }\n\n    var nodes = [];\n    nodes.push(remapped);\n\n    var operator;\n    if (node.operator === \"--\") {\n      operator = \"+\";\n    } else {\n      // \"++\"\n      operator = \"-\";\n    }\n    nodes.push(t.binaryExpression(operator, node.argument, t.literal(1)));\n\n    return t.sequenceExpression(nodes);\n  }\n};\n\n/**\n * [Please add a description.]\n */\n\nvar Remaps = (function () {\n  function Remaps(file, formatter) {\n    _classCallCheck(this, Remaps);\n\n    this.formatter = formatter;\n    this.file = file;\n  }\n\n  /**\n   * [Please add a description.]\n   */\n\n  Remaps.prototype.run = function run() {\n    this.file.path.traverse(remapVisitor, this);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Remaps.prototype._getKey = function _getKey(name) {\n    return name + \":moduleRemap\";\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Remaps.prototype.get = function get(scope, name) {\n    return scope.getData(this._getKey(name));\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Remaps.prototype.add = function add(scope, name, val) {\n    if (this.all) {\n      this.all.push({\n        name: name,\n        scope: scope,\n        node: val\n      });\n    }\n\n    return scope.setData(this._getKey(name), val);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Remaps.prototype.remove = function remove(scope, name) {\n    return scope.removeData(this._getKey(name));\n  };\n\n  /**\n   * These methods are used by the system module formatter who needs access to all the remaps\n   * so it can process them into it's specific setter method. We don't do this by default since\n   * no other module formatters need access to this.\n   */\n\n  Remaps.prototype.getAll = function getAll() {\n    return this.all;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Remaps.prototype.clearAll = function clearAll() {\n    if (this.all) {\n      var _arr = this.all;\n\n      for (var _i = 0; _i < _arr.length; _i++) {\n        var remap = _arr[_i];\n        remap.scope.removeData(this._getKey(remap.name));\n      }\n    }\n\n    this.all = [];\n  };\n\n  return Remaps;\n})();\n\nexports[\"default\"] = Remaps;\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _util = require(\"../../util\");\n\nvar util = _interopRequireWildcard(_util);\n\n/**\n * [Please add a description.]\n */\n\nexports[\"default\"] = function (Parent) {\n  var Constructor = function Constructor() {\n    this.noInteropRequireImport = true;\n    this.noInteropRequireExport = true;\n    Parent.apply(this, arguments);\n  };\n\n  util.inherits(Constructor, Parent);\n\n  return Constructor;\n};\n\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _amd = require(\"./amd\");\n\nvar _amd2 = _interopRequireDefault(_amd);\n\nvar _strict = require(\"./_strict\");\n\nvar _strict2 = _interopRequireDefault(_strict);\n\n/**\n * [Please add a description.]\n */\n\nexports[\"default\"] = _strict2[\"default\"](_amd2[\"default\"]);\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// istanbul ignore next\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// istanbul ignore next\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _default = require(\"./_default\");\n\nvar _default2 = _interopRequireDefault(_default);\n\nvar _common = require(\"./common\");\n\nvar _common2 = _interopRequireDefault(_common);\n\nvar _lodashCollectionIncludes = require(\"lodash/collection/includes\");\n\nvar _lodashCollectionIncludes2 = _interopRequireDefault(_lodashCollectionIncludes);\n\nvar _lodashObjectValues = require(\"lodash/object/values\");\n\nvar _lodashObjectValues2 = _interopRequireDefault(_lodashObjectValues);\n\nvar _util = require(\"../../util\");\n\nvar util = _interopRequireWildcard(_util);\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nvar AMDFormatter = (function (_DefaultFormatter) {\n  _inherits(AMDFormatter, _DefaultFormatter);\n\n  function AMDFormatter() {\n    _classCallCheck(this, AMDFormatter);\n\n    _DefaultFormatter.apply(this, arguments);\n  }\n\n  /**\n   * [Please add a description.]\n   */\n\n  AMDFormatter.prototype.setup = function setup() {\n    _common2[\"default\"].prototype._setup.call(this, this.hasNonDefaultExports);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  AMDFormatter.prototype.buildDependencyLiterals = function buildDependencyLiterals() {\n    var names = [];\n    for (var name in this.ids) {\n      names.push(t.literal(name));\n    }\n    return names;\n  };\n\n  /**\n   * Wrap the entire body in a `define` wrapper.\n   */\n\n  AMDFormatter.prototype.transform = function transform(program) {\n    _common2[\"default\"].prototype.transform.apply(this, arguments);\n\n    var body = program.body;\n\n    // build an array of module names\n\n    var names = [t.literal(\"exports\")];\n    if (this.passModuleArg) names.push(t.literal(\"module\"));\n    names = names.concat(this.buildDependencyLiterals());\n    names = t.arrayExpression(names);\n\n    // build up define container\n\n    var params = _lodashObjectValues2[\"default\"](this.ids);\n    if (this.passModuleArg) params.unshift(t.identifier(\"module\"));\n    params.unshift(t.identifier(\"exports\"));\n\n    var container = t.functionExpression(null, params, t.blockStatement(body));\n\n    var defineArgs = [names, container];\n    var moduleName = this.getModuleName();\n    if (moduleName) defineArgs.unshift(t.literal(moduleName));\n\n    var call = t.callExpression(t.identifier(\"define\"), defineArgs);\n\n    program.body = [t.expressionStatement(call)];\n  };\n\n  /**\n   * Get the AMD module name that we'll prepend to the wrapper\n   * to define this module\n   */\n\n  AMDFormatter.prototype.getModuleName = function getModuleName() {\n    if (this.file.opts.moduleIds) {\n      return _default2[\"default\"].prototype.getModuleName.apply(this, arguments);\n    } else {\n      return null;\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  AMDFormatter.prototype._getExternalReference = function _getExternalReference(node) {\n    return this.scope.generateUidIdentifier(node.source.value);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  AMDFormatter.prototype.importDeclaration = function importDeclaration(node) {\n    this.getExternalReference(node);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  AMDFormatter.prototype.importSpecifier = function importSpecifier(specifier, node, nodes, scope) {\n    var key = node.source.value;\n    var ref = this.getExternalReference(node);\n\n    if (t.isImportNamespaceSpecifier(specifier) || t.isImportDefaultSpecifier(specifier)) {\n      this.defaultIds[key] = specifier.local;\n    }\n\n    if (this.isModuleType(node, \"absolute\")) {\n      // absolute module reference\n    } else if (this.isModuleType(node, \"absoluteDefault\")) {\n        // prevent unnecessary renaming of dynamic imports\n        this.ids[node.source.value] = ref;\n        ref = t.memberExpression(ref, t.identifier(\"default\"));\n      } else if (t.isImportNamespaceSpecifier(specifier)) {\n        // import * as bar from \"foo\";\n      } else if (!_lodashCollectionIncludes2[\"default\"](this.file.dynamicImported, node) && t.isSpecifierDefault(specifier) && !this.noInteropRequireImport) {\n          // import foo from \"foo\";\n          var uid = scope.generateUidIdentifier(specifier.local.name);\n          nodes.push(t.variableDeclaration(\"var\", [t.variableDeclarator(uid, t.callExpression(this.file.addHelper(\"interop-require-default\"), [ref]))]));\n          ref = t.memberExpression(uid, t.identifier(\"default\"));\n        } else {\n          // import { foo } from \"foo\";\n          var imported = specifier.imported;\n          if (t.isSpecifierDefault(specifier)) imported = t.identifier(\"default\");\n          ref = t.memberExpression(ref, imported);\n        }\n\n    this.remaps.add(scope, specifier.local.name, ref);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  AMDFormatter.prototype.exportSpecifier = function exportSpecifier(specifier, node, nodes) {\n    if (this.doDefaultExportInterop(specifier)) {\n      this.passModuleArg = true;\n\n      if (specifier.exported !== specifier.local && !node.source) {\n        nodes.push(util.template(\"exports-default-assign\", {\n          VALUE: specifier.local\n        }, true));\n        return;\n      }\n    }\n\n    _common2[\"default\"].prototype.exportSpecifier.apply(this, arguments);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  AMDFormatter.prototype.exportDeclaration = function exportDeclaration(node, nodes) {\n    if (this.doDefaultExportInterop(node)) {\n      this.passModuleArg = true;\n\n      var declar = node.declaration;\n      var assign = util.template(\"exports-default-assign\", {\n        VALUE: this._pushStatement(declar, nodes)\n      }, true);\n\n      if (t.isFunctionDeclaration(declar)) {\n        // we can hoist this assignment to the top of the file\n        assign._blockHoist = 3;\n      }\n\n      nodes.push(assign);\n      return;\n    }\n\n    _default2[\"default\"].prototype.exportDeclaration.apply(this, arguments);\n  };\n\n  return AMDFormatter;\n})(_default2[\"default\"]);\n\nexports[\"default\"] = AMDFormatter;\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _umd = require(\"./umd\");\n\nvar _umd2 = _interopRequireDefault(_umd);\n\nvar _strict = require(\"./_strict\");\n\nvar _strict2 = _interopRequireDefault(_strict);\n\n/**\n * [Please add a description.]\n */\n\nexports[\"default\"] = _strict2[\"default\"](_umd2[\"default\"]);\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// istanbul ignore next\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// istanbul ignore next\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _default = require(\"./_default\");\n\nvar _default2 = _interopRequireDefault(_default);\n\nvar _amd = require(\"./amd\");\n\nvar _amd2 = _interopRequireDefault(_amd);\n\nvar _lodashObjectValues = require(\"lodash/object/values\");\n\nvar _lodashObjectValues2 = _interopRequireDefault(_lodashObjectValues);\n\nvar _path = require(\"path\");\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _util = require(\"../../util\");\n\nvar util = _interopRequireWildcard(_util);\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nvar UMDFormatter = (function (_AMDFormatter) {\n  _inherits(UMDFormatter, _AMDFormatter);\n\n  function UMDFormatter() {\n    _classCallCheck(this, UMDFormatter);\n\n    _AMDFormatter.apply(this, arguments);\n  }\n\n  /**\n   * [Please add a description.]\n   */\n\n  UMDFormatter.prototype.transform = function transform(program) {\n    _default2[\"default\"].prototype.transform.apply(this, arguments);\n\n    var body = program.body;\n\n    // build an array of module names\n\n    var names = [];\n    for (var _name in this.ids) {\n      names.push(t.literal(_name));\n    }\n\n    // factory\n\n    var ids = _lodashObjectValues2[\"default\"](this.ids);\n    var args = [t.identifier(\"exports\")];\n    if (this.passModuleArg) args.push(t.identifier(\"module\"));\n    args = args.concat(ids);\n\n    var factory = t.functionExpression(null, args, t.blockStatement(body));\n\n    // amd\n\n    var defineArgs = [t.literal(\"exports\")];\n    if (this.passModuleArg) defineArgs.push(t.literal(\"module\"));\n    defineArgs = defineArgs.concat(names);\n    defineArgs = [t.arrayExpression(defineArgs)];\n\n    // common\n\n    var testExports = util.template(\"test-exports\");\n    var testModule = util.template(\"test-module\");\n    var commonTests = this.passModuleArg ? t.logicalExpression(\"&&\", testExports, testModule) : testExports;\n\n    var commonArgs = [t.identifier(\"exports\")];\n    if (this.passModuleArg) commonArgs.push(t.identifier(\"module\"));\n    commonArgs = commonArgs.concat(names.map(function (name) {\n      return t.callExpression(t.identifier(\"require\"), [name]);\n    }));\n\n    // globals\n\n    var browserArgs = [];\n    if (this.passModuleArg) browserArgs.push(t.identifier(\"mod\"));\n\n    for (var _name2 in this.ids) {\n      var id = this.defaultIds[_name2] || t.identifier(t.toIdentifier(_path2[\"default\"].basename(_name2, _path2[\"default\"].extname(_name2))));\n      browserArgs.push(t.memberExpression(t.identifier(\"global\"), id));\n    }\n\n    //\n\n    var moduleName = this.getModuleName();\n    if (moduleName) defineArgs.unshift(t.literal(moduleName));\n\n    //\n    var globalArg = this.file.opts.basename;\n    if (moduleName) globalArg = moduleName;\n    globalArg = t.identifier(t.toIdentifier(globalArg));\n\n    var runner = util.template(\"umd-runner-body\", {\n      AMD_ARGUMENTS: defineArgs,\n      COMMON_TEST: commonTests,\n      COMMON_ARGUMENTS: commonArgs,\n      BROWSER_ARGUMENTS: browserArgs,\n      GLOBAL_ARG: globalArg\n    });\n\n    //\n\n    program.body = [t.expressionStatement(t.callExpression(runner, [t.thisExpression(), factory]))];\n  };\n\n  return UMDFormatter;\n})(_amd2[\"default\"]);\n\nexports[\"default\"] = UMDFormatter;\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// istanbul ignore next\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// istanbul ignore next\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _default = require(\"./_default\");\n\nvar _default2 = _interopRequireDefault(_default);\n\nvar _amd = require(\"./amd\");\n\nvar _amd2 = _interopRequireDefault(_amd);\n\nvar _util = require(\"../../util\");\n\nvar util = _interopRequireWildcard(_util);\n\nvar _lodashArrayLast = require(\"lodash/array/last\");\n\nvar _lodashArrayLast2 = _interopRequireDefault(_lodashArrayLast);\n\nvar _lodashCollectionMap = require(\"lodash/collection/map\");\n\nvar _lodashCollectionMap2 = _interopRequireDefault(_lodashCollectionMap);\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nvar hoistVariablesVisitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  Function: function Function() {\n    // nothing inside is accessible\n    this.skip();\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  VariableDeclaration: function VariableDeclaration(node, parent, scope, state) {\n    if (node.kind !== \"var\" && !t.isProgram(parent)) {\n      // let, const\n      // can't be accessed\n      return;\n    }\n\n    // ignore block hoisted nodes as these can be left in\n    if (state.formatter._canHoist(node)) return;\n\n    var nodes = [];\n\n    for (var i = 0; i < node.declarations.length; i++) {\n      var declar = node.declarations[i];\n      state.hoistDeclarators.push(t.variableDeclarator(declar.id));\n      if (declar.init) {\n        // no initializer so we can just hoist it as-is\n        var assign = t.expressionStatement(t.assignmentExpression(\"=\", declar.id, declar.init));\n        nodes.push(assign);\n      }\n    }\n\n    // for (var i in test)\n    if (t.isFor(parent) && parent.left === node) {\n      return node.declarations[0].id;\n    }\n\n    return nodes;\n  }\n};\n\n/**\n * [Please add a description.]\n */\n\nvar hoistFunctionsVisitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  Function: function Function() {\n    this.skip();\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  enter: function enter(node, parent, scope, state) {\n    if (t.isFunctionDeclaration(node) || state.formatter._canHoist(node)) {\n      state.handlerBody.push(node);\n      this.dangerouslyRemove();\n    }\n  }\n};\n\n/**\n * [Please add a description.]\n */\n\nvar runnerSettersVisitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  enter: function enter(node, parent, scope, state) {\n    if (node._importSource === state.source) {\n      if (t.isVariableDeclaration(node)) {\n        var _arr = node.declarations;\n\n        for (var _i = 0; _i < _arr.length; _i++) {\n          var declar = _arr[_i];\n          state.hoistDeclarators.push(t.variableDeclarator(declar.id));\n          state.nodes.push(t.expressionStatement(t.assignmentExpression(\"=\", declar.id, declar.init)));\n        }\n      } else {\n        state.nodes.push(node);\n      }\n\n      this.dangerouslyRemove();\n    }\n  }\n};\n\n/**\n * [Please add a description.]\n */\n\nvar SystemFormatter = (function (_AMDFormatter) {\n  _inherits(SystemFormatter, _AMDFormatter);\n\n  function SystemFormatter(file) {\n    _classCallCheck(this, SystemFormatter);\n\n    _AMDFormatter.call(this, file);\n\n    this._setters = null;\n    this.exportIdentifier = file.scope.generateUidIdentifier(\"export\");\n    this.noInteropRequireExport = true;\n    this.noInteropRequireImport = true;\n\n    this.remaps.clearAll();\n  }\n\n  /**\n   * [Please add a description.]\n   */\n\n  SystemFormatter.prototype._addImportSource = function _addImportSource(node, exportNode) {\n    if (node) node._importSource = exportNode.source && exportNode.source.value;\n    return node;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  SystemFormatter.prototype.buildExportsWildcard = function buildExportsWildcard(objectIdentifier, node) {\n    var leftIdentifier = this.scope.generateUidIdentifier(\"key\");\n    var valIdentifier = t.memberExpression(objectIdentifier, leftIdentifier, true);\n\n    var left = t.variableDeclaration(\"var\", [t.variableDeclarator(leftIdentifier)]);\n\n    var right = objectIdentifier;\n\n    var block = t.blockStatement([t.ifStatement(t.binaryExpression(\"!==\", leftIdentifier, t.literal(\"default\")), t.expressionStatement(this._buildExportCall(leftIdentifier, valIdentifier)))]);\n\n    return this._addImportSource(t.forInStatement(left, right, block), node);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  SystemFormatter.prototype.buildExportsAssignment = function buildExportsAssignment(id, init, node) {\n    var call = this._buildExportCall(t.literal(id.name), init, true);\n    return this._addImportSource(call, node);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  SystemFormatter.prototype.buildExportsFromAssignment = function buildExportsFromAssignment() {\n    return this.buildExportsAssignment.apply(this, arguments);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  SystemFormatter.prototype.remapExportAssignment = function remapExportAssignment(node, exported) {\n    var assign = node;\n\n    for (var i = 0; i < exported.length; i++) {\n      assign = this._buildExportCall(t.literal(exported[i].name), assign);\n    }\n\n    return assign;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  SystemFormatter.prototype._buildExportCall = function _buildExportCall(id, init, isStatement) {\n    var call = t.callExpression(this.exportIdentifier, [id, init]);\n    if (isStatement) {\n      return t.expressionStatement(call);\n    } else {\n      return call;\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  SystemFormatter.prototype.importSpecifier = function importSpecifier(specifier, node, nodes) {\n    _amd2[\"default\"].prototype.importSpecifier.apply(this, arguments);\n\n    var _arr2 = this.remaps.getAll();\n\n    for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n      var remap = _arr2[_i2];\n      nodes.push(t.variableDeclaration(\"var\", [t.variableDeclarator(t.identifier(remap.name), remap.node)]));\n    }\n\n    this.remaps.clearAll();\n\n    this._addImportSource(_lodashArrayLast2[\"default\"](nodes), node);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  SystemFormatter.prototype._buildRunnerSetters = function _buildRunnerSetters(block, hoistDeclarators) {\n    var scope = this.file.scope;\n\n    return t.arrayExpression(_lodashCollectionMap2[\"default\"](this.ids, function (uid, source) {\n      var state = {\n        hoistDeclarators: hoistDeclarators,\n        source: source,\n        nodes: []\n      };\n\n      scope.traverse(block, runnerSettersVisitor, state);\n\n      return t.functionExpression(null, [uid], t.blockStatement(state.nodes));\n    }));\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  SystemFormatter.prototype._canHoist = function _canHoist(node) {\n    return node._blockHoist && !this.file.dynamicImports.length;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  SystemFormatter.prototype.transform = function transform(program) {\n    _default2[\"default\"].prototype.transform.apply(this, arguments);\n\n    var hoistDeclarators = [];\n    var moduleName = this.getModuleName();\n    var moduleNameLiteral = t.literal(moduleName);\n\n    var block = t.blockStatement(program.body);\n\n    var setterListNode = this._buildRunnerSetters(block, hoistDeclarators);\n    this._setters = setterListNode;\n\n    var runner = util.template(\"system\", {\n      MODULE_DEPENDENCIES: t.arrayExpression(this.buildDependencyLiterals()),\n      EXPORT_IDENTIFIER: this.exportIdentifier,\n      MODULE_NAME: moduleNameLiteral,\n      SETTERS: setterListNode,\n      EXECUTE: t.functionExpression(null, [], block)\n    }, true);\n\n    var handlerBody = runner.expression.arguments[2].body.body;\n    if (!moduleName) runner.expression.arguments.shift();\n\n    var returnStatement = handlerBody.pop();\n\n    // hoist up all variable declarations\n    this.file.scope.traverse(block, hoistVariablesVisitor, {\n      formatter: this,\n      hoistDeclarators: hoistDeclarators\n    });\n\n    if (hoistDeclarators.length) {\n      var hoistDeclar = t.variableDeclaration(\"var\", hoistDeclarators);\n      hoistDeclar._blockHoist = true;\n      handlerBody.unshift(hoistDeclar);\n    }\n\n    // hoist up function declarations for circular references\n    this.file.scope.traverse(block, hoistFunctionsVisitor, {\n      formatter: this,\n      handlerBody: handlerBody\n    });\n\n    handlerBody.push(returnStatement);\n\n    program.body = [runner];\n  };\n\n  return SystemFormatter;\n})(_amd2[\"default\"]);\n\nexports[\"default\"] = SystemFormatter;\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// istanbul ignore next\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// istanbul ignore next\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _default = require(\"./_default\");\n\nvar _default2 = _interopRequireDefault(_default);\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nvar IgnoreFormatter = (function (_DefaultFormatter) {\n  _inherits(IgnoreFormatter, _DefaultFormatter);\n\n  function IgnoreFormatter() {\n    _classCallCheck(this, IgnoreFormatter);\n\n    _DefaultFormatter.apply(this, arguments);\n  }\n\n  /**\n   * [Please add a description.]\n   */\n\n  IgnoreFormatter.prototype.exportDeclaration = function exportDeclaration(node, nodes) {\n    var declar = t.toStatement(node.declaration, true);\n    if (declar) nodes.push(t.inherits(declar, node));\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  IgnoreFormatter.prototype.exportAllDeclaration = function exportAllDeclaration() {};\n\n  IgnoreFormatter.prototype.importDeclaration = function importDeclaration() {};\n\n  IgnoreFormatter.prototype.importSpecifier = function importSpecifier() {};\n\n  IgnoreFormatter.prototype.exportSpecifier = function exportSpecifier() {};\n\n  IgnoreFormatter.prototype.transform = function transform() {};\n\n  return IgnoreFormatter;\n})(_default2[\"default\"]);\n\nexports[\"default\"] = IgnoreFormatter;\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// istanbul ignore next\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _index = require(\"./index\");\n\nvar _json5 = require(\"json5\");\n\nvar _json52 = _interopRequireDefault(_json5);\n\nvar _pathIsAbsolute = require(\"path-is-absolute\");\n\nvar _pathIsAbsolute2 = _interopRequireDefault(_pathIsAbsolute);\n\nvar _pathExists = require(\"path-exists\");\n\nvar _pathExists2 = _interopRequireDefault(_pathExists);\n\nvar _lodashLangClone = require(\"lodash/lang/clone\");\n\nvar _lodashLangClone2 = _interopRequireDefault(_lodashLangClone);\n\nvar _helpersMerge = require(\"../../../helpers/merge\");\n\nvar _helpersMerge2 = _interopRequireDefault(_helpersMerge);\n\nvar _config = require(\"./config\");\n\nvar _config2 = _interopRequireDefault(_config);\n\nvar _path = require(\"path\");\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _fs = require(\"fs\");\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar existsCache = {};\nvar jsonCache = {};\n\nvar BABELIGNORE_FILENAME = \".babelignore\";\nvar BABELRC_FILENAME = \".babelrc\";\nvar PACKAGE_FILENAME = \"package.json\";\n\nfunction exists(filename) {\n  var cached = existsCache[filename];\n  if (cached != null) {\n    return cached;\n  } else {\n    return existsCache[filename] = _pathExists2[\"default\"].sync(filename);\n  }\n}\n\nvar OptionManager = (function () {\n  function OptionManager(log, pipeline) {\n    _classCallCheck(this, OptionManager);\n\n    this.resolvedConfigs = [];\n    this.options = OptionManager.createBareOptions();\n    this.pipeline = pipeline;\n    this.log = log;\n  }\n\n  /**\n   * [Please add a description.]\n   */\n\n  OptionManager.createBareOptions = function createBareOptions() {\n    var opts = {};\n\n    for (var key in _config2[\"default\"]) {\n      var opt = _config2[\"default\"][key];\n      opts[key] = _lodashLangClone2[\"default\"](opt[\"default\"]);\n    }\n\n    return opts;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  OptionManager.prototype.addConfig = function addConfig(loc, key) {\n    var json = arguments.length <= 2 || arguments[2] === undefined ? _json52[\"default\"] : arguments[2];\n\n    if (this.resolvedConfigs.indexOf(loc) >= 0) return;\n\n    var content = _fs2[\"default\"].readFileSync(loc, \"utf8\");\n    var opts;\n\n    try {\n      opts = jsonCache[content] = jsonCache[content] || json.parse(content);\n      if (key) opts = opts[key];\n    } catch (err) {\n      err.message = loc + \": Error while parsing JSON - \" + err.message;\n      throw err;\n    }\n\n    this.mergeOptions(opts, loc);\n    this.resolvedConfigs.push(loc);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  OptionManager.prototype.mergeOptions = function mergeOptions(opts) {\n    var alias = arguments.length <= 1 || arguments[1] === undefined ? \"foreign\" : arguments[1];\n\n    if (!opts) return;\n\n    for (var key in opts) {\n      if (key[0] === \"_\") continue;\n\n      var option = _config2[\"default\"][key];\n\n      // check for an unknown option\n      if (!option) this.log.error(\"Unknown option: \" + alias + \".\" + key, ReferenceError);\n    }\n\n    // normalise options\n    _index.normaliseOptions(opts);\n\n    // merge them into this current files options\n    _helpersMerge2[\"default\"](this.options, opts);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  OptionManager.prototype.addIgnoreConfig = function addIgnoreConfig(loc) {\n    var file = _fs2[\"default\"].readFileSync(loc, \"utf8\");\n    var lines = file.split(\"\\n\");\n\n    lines = lines.map(function (line) {\n      return line.replace(/#(.*?)$/, \"\").trim();\n    }).filter(function (line) {\n      return !!line;\n    });\n\n    this.mergeOptions({ ignore: lines }, loc);\n  };\n\n  /**\n   * Description\n   */\n\n  OptionManager.prototype.findConfigs = function findConfigs(loc) {\n    if (!loc) return;\n\n    if (!_pathIsAbsolute2[\"default\"](loc)) {\n      loc = _path2[\"default\"].join(process.cwd(), loc);\n    }\n\n    while (loc !== (loc = _path2[\"default\"].dirname(loc))) {\n      if (this.options.breakConfig) return;\n\n      var configLoc = _path2[\"default\"].join(loc, BABELRC_FILENAME);\n      if (exists(configLoc)) this.addConfig(configLoc);\n\n      var pkgLoc = _path2[\"default\"].join(loc, PACKAGE_FILENAME);\n      if (exists(pkgLoc)) this.addConfig(pkgLoc, \"babel\", JSON);\n\n      var ignoreLoc = _path2[\"default\"].join(loc, BABELIGNORE_FILENAME);\n      if (exists(ignoreLoc)) this.addIgnoreConfig(ignoreLoc);\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  OptionManager.prototype.normaliseOptions = function normaliseOptions() {\n    var opts = this.options;\n\n    for (var key in _config2[\"default\"]) {\n      var option = _config2[\"default\"][key];\n      var val = opts[key];\n\n      // optional\n      if (!val && option.optional) continue;\n\n      // deprecated\n      if (this.log && val && option.deprecated) {\n        this.log.deprecate(\"Deprecated option \" + key + \": \" + option.deprecated);\n      }\n\n      // validate\n      if (this.pipeline && val) {\n        val = _index.validateOption(key, val, this.pipeline);\n      }\n\n      // aaliases\n      if (option.alias) {\n        opts[option.alias] = opts[option.alias] || val;\n      } else {\n        opts[key] = val;\n      }\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  OptionManager.prototype.init = function init(opts) {\n    this.mergeOptions(opts, \"direct\");\n\n    // babelrc option\n    if (opts.babelrc) {\n      var _arr = opts.babelrc;\n\n      for (var _i = 0; _i < _arr.length; _i++) {\n        var loc = _arr[_i];this.addConfig(loc);\n      }\n    }\n\n    // resolve all .babelrc files\n    if (opts.babelrc !== false) {\n      this.findConfigs(opts.filename);\n    }\n\n    // merge in env\n    var envKey = process.env.BABEL_ENV || process.env.NODE_ENV || \"development\";\n    if (this.options.env) {\n      this.mergeOptions(this.options.env[envKey], \"direct.env.\" + envKey);\n    }\n\n    // normalise\n    this.normaliseOptions(opts);\n\n    return this.options;\n  };\n\n  return OptionManager;\n})();\n\nexports[\"default\"] = OptionManager;\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\nexports.validateOption = validateOption;\nexports.normaliseOptions = normaliseOptions;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _parsers = require(\"./parsers\");\n\nvar parsers = _interopRequireWildcard(_parsers);\n\nvar _config = require(\"./config\");\n\nvar _config2 = _interopRequireDefault(_config);\n\nexports.config = _config2[\"default\"];\n\n/**\n * Validate an option.\n */\n\nfunction validateOption(key, val, pipeline) {\n  var opt = _config2[\"default\"][key];\n  var parser = opt && parsers[opt.type];\n  if (parser && parser.validate) {\n    return parser.validate(key, val, pipeline);\n  } else {\n    return val;\n  }\n}\n\n/**\n * Normalize all options.\n */\n\nfunction normaliseOptions() {\n  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n  for (var key in options) {\n    var val = options[key];\n    if (val == null) continue;\n\n    var opt = _config2[\"default\"][key];\n    if (!opt) continue;\n\n    var parser = parsers[opt.type];\n    if (parser) val = parser(val);\n\n    options[key] = val;\n  }\n\n  return options;\n}","\n\nexports.__esModule = true;\nexports.transformerList = transformerList;\nexports.number = number;\nexports.boolean = boolean;\nexports.booleanString = booleanString;\nexports.list = list;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _slash = require(\"slash\");\n\nvar _slash2 = _interopRequireDefault(_slash);\n\nvar _util = require(\"../../../util\");\n\nvar util = _interopRequireWildcard(_util);\n\n/**\n * Get a transformer list from a value.\n */\n\nfunction transformerList(val) {\n  return util.arrayify(val);\n}\n\n/**\n * Validate transformer list. Maps \"all\" to all transformer names.\n */\n\ntransformerList.validate = function (key, val, pipeline) {\n  if (val.indexOf(\"all\") >= 0 || val.indexOf(true) >= 0) {\n    val = Object.keys(pipeline.transformers);\n  }\n\n  return pipeline._ensureTransformerNames(key, val);\n};\n\n/**\n * Cast a value to a number.\n */\n\nfunction number(val) {\n  return +val;\n}\n\n/**\n * Cast a value to a boolean.\n */\n\nvar filename = _slash2[\"default\"];\n\nexports.filename = filename;\n/**\n * [Please add a description.]\n */\n\nfunction boolean(val) {\n  return !!val;\n}\n\n/**\n * Cast a boolean-like string to a boolean.\n */\n\nfunction booleanString(val) {\n  return util.booleanify(val);\n}\n\n/**\n * Cast a value to an array, splitting strings by \",\".\n */\n\nfunction list(val) {\n  return util.list(val);\n}","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _lodashObjectMerge = require(\"lodash/object/merge\");\n\nvar _lodashObjectMerge2 = _interopRequireDefault(_lodashObjectMerge);\n\n/**\n * Merge options.\n */\n\nexports[\"default\"] = function (dest, src) {\n  if (!dest || !src) return;\n\n  return _lodashObjectMerge2[\"default\"](dest, src, function (a, b) {\n    if (b && Array.isArray(a)) {\n      var c = a.slice(0);\n      for (var _iterator = b, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n        var _ref;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref = _i.value;\n        }\n\n        var v = _ref;\n\n        if (a.indexOf(v) < 0) {\n          c.push(v);\n        }\n      }\n      return c;\n    }\n  });\n};\n\nmodule.exports = exports[\"default\"];","\n\n// istanbul ignore next\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// istanbul ignore next\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _detectIndent = require(\"detect-indent\");\n\nvar _detectIndent2 = _interopRequireDefault(_detectIndent);\n\nvar _whitespace = require(\"./whitespace\");\n\nvar _whitespace2 = _interopRequireDefault(_whitespace);\n\nvar _nodePrinter = require(\"./node/printer\");\n\nvar _nodePrinter2 = _interopRequireDefault(_nodePrinter);\n\nvar _repeating = require(\"repeating\");\n\nvar _repeating2 = _interopRequireDefault(_repeating);\n\nvar _sourceMap = require(\"./source-map\");\n\nvar _sourceMap2 = _interopRequireDefault(_sourceMap);\n\nvar _position = require(\"./position\");\n\nvar _position2 = _interopRequireDefault(_position);\n\nvar _messages = require(\"../messages\");\n\nvar messages = _interopRequireWildcard(_messages);\n\nvar _buffer = require(\"./buffer\");\n\nvar _buffer2 = _interopRequireDefault(_buffer);\n\nvar _lodashObjectExtend = require(\"lodash/object/extend\");\n\nvar _lodashObjectExtend2 = _interopRequireDefault(_lodashObjectExtend);\n\nvar _lodashCollectionEach = require(\"lodash/collection/each\");\n\nvar _lodashCollectionEach2 = _interopRequireDefault(_lodashCollectionEach);\n\nvar _node2 = require(\"./node\");\n\nvar _node3 = _interopRequireDefault(_node2);\n\nvar _types = require(\"../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * Babel's code generator, turns an ast into code, maintaining sourcemaps,\n * user preferences, and valid output.\n */\n\nvar CodeGenerator = (function () {\n  function CodeGenerator(ast, opts, code) {\n    _classCallCheck(this, CodeGenerator);\n\n    opts = opts || {};\n\n    this.comments = ast.comments || [];\n    this.tokens = ast.tokens || [];\n    this.format = CodeGenerator.normalizeOptions(code, opts, this.tokens);\n    this.opts = opts;\n    this.ast = ast;\n\n    this.whitespace = new _whitespace2[\"default\"](this.tokens);\n    this.position = new _position2[\"default\"]();\n    this.map = new _sourceMap2[\"default\"](this.position, opts, code);\n    this.buffer = new _buffer2[\"default\"](this.position, this.format);\n  }\n\n  /**\n   * [Please add a description.]\n   */\n\n  /**\n   * Normalize generator options, setting defaults.\n   *\n   * - Detects code indentation.\n   * - If `opts.compact = \"auto\"` and the code is over 100KB, `compact` will be set to `true`.\n   */\n\n  CodeGenerator.normalizeOptions = function normalizeOptions(code, opts, tokens) {\n    var style = \"  \";\n    if (code) {\n      var indent = _detectIndent2[\"default\"](code).indent;\n      if (indent && indent !== \" \") style = indent;\n    }\n\n    var format = {\n      shouldPrintComment: opts.shouldPrintComment,\n      retainLines: opts.retainLines,\n      comments: opts.comments == null || opts.comments,\n      compact: opts.compact,\n      quotes: CodeGenerator.findCommonStringDelimiter(code, tokens),\n      indent: {\n        adjustMultilineComment: true,\n        style: style,\n        base: 0\n      }\n    };\n\n    if (format.compact === \"auto\") {\n      format.compact = code.length > 100000; // 100KB\n\n      if (format.compact) {\n        console.error(\"[BABEL] \" + messages.get(\"codeGeneratorDeopt\", opts.filename, \"100KB\"));\n      }\n    }\n\n    if (format.compact) {\n      format.indent.adjustMultilineComment = false;\n    }\n\n    return format;\n  };\n\n  /**\n   * Determine if input code uses more single or double quotes.\n   */\n\n  CodeGenerator.findCommonStringDelimiter = function findCommonStringDelimiter(code, tokens) {\n    var occurences = {\n      single: 0,\n      double: 0\n    };\n\n    var checked = 0;\n\n    for (var i = 0; i < tokens.length; i++) {\n      var token = tokens[i];\n      if (token.type.label !== \"string\") continue;\n\n      var raw = code.slice(token.start, token.end);\n      if (raw[0] === \"'\") {\n        occurences.single++;\n      } else {\n        occurences.double++;\n      }\n\n      checked++;\n      if (checked >= 3) break;\n    }\n    if (occurences.single > occurences.double) {\n      return \"single\";\n    } else {\n      return \"double\";\n    }\n  };\n\n  /**\n   * All node generators.\n   */\n\n  /**\n   * Generate code and sourcemap from ast.\n   *\n   * Appends comments that weren't attached to any node to the end of the generated output.\n   */\n\n  CodeGenerator.prototype.generate = function generate() {\n    var ast = this.ast;\n\n    this.print(ast);\n\n    if (ast.comments) {\n      var comments = [];\n      var _arr = ast.comments;\n      for (var _i = 0; _i < _arr.length; _i++) {\n        var comment = _arr[_i];\n        if (!comment._displayed) comments.push(comment);\n      }\n      this._printComments(comments);\n    }\n\n    return {\n      map: this.map.get(),\n      code: this.buffer.get()\n    };\n  };\n\n  /**\n   * Build NodePrinter.\n   */\n\n  CodeGenerator.prototype.buildPrint = function buildPrint(parent) {\n    return new _nodePrinter2[\"default\"](this, parent);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  CodeGenerator.prototype.catchUp = function catchUp(node) {\n    // catch up to this nodes newline if we're behind\n    if (node.loc && this.format.retainLines && this.buffer.buf) {\n      while (this.position.line < node.loc.start.line) {\n        this._push(\"\\n\");\n      }\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  CodeGenerator.prototype._printNewline = function _printNewline(leading, node, parent, opts) {\n    if (!opts.statement && !_node3[\"default\"].isUserWhitespacable(node, parent)) {\n      return;\n    }\n\n    var lines = 0;\n\n    if (node.start != null && !node._ignoreUserWhitespace) {\n      // user node\n      if (leading) {\n        lines = this.whitespace.getNewlinesBefore(node);\n      } else {\n        lines = this.whitespace.getNewlinesAfter(node);\n      }\n    } else {\n      // generated node\n      if (!leading) lines++; // always include at least a single line after\n      if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;\n\n      var needs = _node3[\"default\"].needsWhitespaceAfter;\n      if (leading) needs = _node3[\"default\"].needsWhitespaceBefore;\n      if (needs(node, parent)) lines++;\n\n      // generated nodes can't add starting file whitespace\n      if (!this.buffer.buf) lines = 0;\n    }\n\n    this.newline(lines);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  CodeGenerator.prototype.print = function print(node, parent) {\n    var opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n    if (!node) return;\n\n    if (parent && parent._compact) {\n      node._compact = true;\n    }\n\n    var oldConcise = this.format.concise;\n    if (node._compact) {\n      this.format.concise = true;\n    }\n\n    if (!this[node.type]) {\n      throw new ReferenceError(\"unknown node of type \" + JSON.stringify(node.type) + \" with constructor \" + JSON.stringify(node && node.constructor.name));\n    }\n\n    var needsParens = _node3[\"default\"].needsParens(node, parent);\n    if (needsParens) this.push(\"(\");\n\n    this.printLeadingComments(node, parent);\n\n    this.catchUp(node);\n\n    this._printNewline(true, node, parent, opts);\n\n    if (opts.before) opts.before();\n    this.map.mark(node, \"start\");\n\n    this[node.type](node, this.buildPrint(node), parent);\n\n    if (needsParens) this.push(\")\");\n\n    this.map.mark(node, \"end\");\n    if (opts.after) opts.after();\n\n    this.format.concise = oldConcise;\n\n    this._printNewline(false, node, parent, opts);\n\n    this.printTrailingComments(node, parent);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  CodeGenerator.prototype.printJoin = function printJoin(print, nodes) {\n    // istanbul ignore next\n\n    var _this = this;\n\n    var opts = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];\n\n    if (!nodes || !nodes.length) return;\n\n    var len = nodes.length;\n\n    if (opts.indent) this.indent();\n\n    var printOpts = {\n      statement: opts.statement,\n      addNewlines: opts.addNewlines,\n      after: function after() {\n        if (opts.iterator) {\n          opts.iterator(node, i);\n        }\n\n        if (opts.separator && i < len - 1) {\n          _this.push(opts.separator);\n        }\n      }\n    };\n\n    for (var i = 0; i < nodes.length; i++) {\n      var node = nodes[i];\n      print.plain(node, printOpts);\n    }\n\n    if (opts.indent) this.dedent();\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  CodeGenerator.prototype.printAndIndentOnComments = function printAndIndentOnComments(print, node) {\n    var indent = !!node.leadingComments;\n    if (indent) this.indent();\n    print.plain(node);\n    if (indent) this.dedent();\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  CodeGenerator.prototype.printBlock = function printBlock(print, node) {\n    if (t.isEmptyStatement(node)) {\n      this.semicolon();\n    } else {\n      this.push(\" \");\n      print.plain(node);\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  CodeGenerator.prototype.generateComment = function generateComment(comment) {\n    var val = comment.value;\n    if (comment.type === \"CommentLine\") {\n      val = \"//\" + val;\n    } else {\n      val = \"/*\" + val + \"*/\";\n    }\n    return val;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  CodeGenerator.prototype.printTrailingComments = function printTrailingComments(node, parent) {\n    this._printComments(this.getComments(\"trailingComments\", node, parent));\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  CodeGenerator.prototype.printLeadingComments = function printLeadingComments(node, parent) {\n    this._printComments(this.getComments(\"leadingComments\", node, parent));\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  CodeGenerator.prototype.getComments = function getComments(key, node, parent) {\n    if (t.isExpressionStatement(parent)) {\n      return [];\n    }\n\n    var comments = [];\n    var nodes = [node];\n\n    if (t.isExpressionStatement(node)) {\n      nodes.push(node.argument);\n    }\n\n    var _arr2 = nodes;\n    for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n      var _node = _arr2[_i2];\n      comments = comments.concat(this._getComments(key, _node));\n    }\n\n    return comments;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  CodeGenerator.prototype._getComments = function _getComments(key, node) {\n    return node && node[key] || [];\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  CodeGenerator.prototype.shouldPrintComment = function shouldPrintComment(comment) {\n    if (this.format.shouldPrintComment) {\n      return this.format.shouldPrintComment(comment.value);\n    } else {\n      if (comment.value.indexOf(\"@license\") >= 0 || comment.value.indexOf(\"@preserve\") >= 0) {\n        return true;\n      } else {\n        return this.format.comments;\n      }\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  CodeGenerator.prototype._printComments = function _printComments(comments) {\n    if (!comments || !comments.length) return;\n\n    var _arr3 = comments;\n    for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n      var comment = _arr3[_i3];\n      if (!this.shouldPrintComment(comment)) continue;\n      if (comment._displayed) continue;\n      comment._displayed = true;\n\n      this.catchUp(comment);\n\n      // whitespace before\n      this.newline(this.whitespace.getNewlinesBefore(comment));\n\n      var column = this.position.column;\n      var val = this.generateComment(comment);\n\n      if (column && !this.isLast([\"\\n\", \" \", \"[\", \"{\"])) {\n        this._push(\" \");\n        column++;\n      }\n\n      //\n      if (comment.type === \"CommentBlock\" && this.format.indent.adjustMultilineComment) {\n        var offset = comment.loc && comment.loc.start.column;\n        if (offset) {\n          var newlineRegex = new RegExp(\"\\\\n\\\\s{1,\" + offset + \"}\", \"g\");\n          val = val.replace(newlineRegex, \"\\n\");\n        }\n\n        var indent = Math.max(this.indentSize(), column);\n        val = val.replace(/\\n/g, \"\\n\" + _repeating2[\"default\"](\" \", indent));\n      }\n\n      if (column === 0) {\n        val = this.getIndent() + val;\n      }\n\n      // force a newline for line comments when retainLines is set in case the next printed node\n      // doesn't catch up\n      if ((this.format.compact || this.format.retainLines) && comment.type === \"CommentLine\") {\n        val += \"\\n\";\n      }\n\n      //\n      this._push(val);\n\n      // whitespace after\n      this.newline(this.whitespace.getNewlinesAfter(comment));\n    }\n  };\n\n  _createClass(CodeGenerator, null, [{\n    key: \"generators\",\n    value: {\n      templateLiterals: require(\"./generators/template-literals\"),\n      comprehensions: require(\"./generators/comprehensions\"),\n      expressions: require(\"./generators/expressions\"),\n      statements: require(\"./generators/statements\"),\n      classes: require(\"./generators/classes\"),\n      methods: require(\"./generators/methods\"),\n      modules: require(\"./generators/modules\"),\n      types: require(\"./generators/types\"),\n      flow: require(\"./generators/flow\"),\n      base: require(\"./generators/base\"),\n      jsx: require(\"./generators/jsx\")\n    },\n    enumerable: true\n  }]);\n\n  return CodeGenerator;\n})();\n\n_lodashCollectionEach2[\"default\"](_buffer2[\"default\"].prototype, function (fn, key) {\n  CodeGenerator.prototype[key] = function () {\n    return fn.apply(this.buffer, arguments);\n  };\n});\n\n/**\n * [Please add a description.]\n */\n\n_lodashCollectionEach2[\"default\"](CodeGenerator.generators, function (generator) {\n  _lodashObjectExtend2[\"default\"](CodeGenerator.prototype, generator);\n});\n\n/**\n * [Please add a description.]\n */\n\nmodule.exports = function (ast, opts, code) {\n  var gen = new CodeGenerator(ast, opts, code);\n  return gen.generate();\n};\n\nmodule.exports.CodeGenerator = CodeGenerator;","/**\n * Returns `i`th number from `base`, continuing from 0 when `max` is reached.\n * Useful for shifting `for` loop by a fixed number but going over all items.\n *\n * @param {Number} i Current index in the loop\n * @param {Number} base Start index for which to return 0\n * @param {Number} max Array length\n * @returns {Number} shiftedIndex\n */\n\n\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction getLookupIndex(i, base, max) {\n  i += base;\n\n  if (i >= max) {\n    i -= max;\n  }\n\n  return i;\n}\n\n/**\n * Get whitespace around tokens.\n */\n\nvar Whitespace = (function () {\n  function Whitespace(tokens) {\n    _classCallCheck(this, Whitespace);\n\n    this.tokens = tokens;\n    this.used = {};\n\n    // Profiling this code shows that while generator passes over it, indexes\n    // returned by `getNewlinesBefore` and `getNewlinesAfter` are always increasing.\n\n    // We use this implementation detail for an optimization: instead of always\n    // starting to look from `this.tokens[0]`, we will start `for` loops from the\n    // previous successful match. We will enumerate all tokens—but the common\n    // case will be much faster.\n\n    this._lastFoundIndex = 0;\n  }\n\n  /**\n   * Count all the newlines before a node.\n   */\n\n  Whitespace.prototype.getNewlinesBefore = function getNewlinesBefore(node) {\n    var startToken;\n    var endToken;\n    var tokens = this.tokens;\n\n    for (var j = 0; j < tokens.length; j++) {\n      // optimize for forward traversal by shifting for loop index\n      var i = getLookupIndex(j, this._lastFoundIndex, this.tokens.length);\n      var token = tokens[i];\n\n      // this is the token this node starts with\n      if (node.start === token.start) {\n        startToken = tokens[i - 1];\n        endToken = token;\n\n        this._lastFoundIndex = i;\n        break;\n      }\n    }\n\n    return this.getNewlinesBetween(startToken, endToken);\n  };\n\n  /**\n   * Count all the newlines after a node.\n   */\n\n  Whitespace.prototype.getNewlinesAfter = function getNewlinesAfter(node) {\n    var startToken;\n    var endToken;\n    var tokens = this.tokens;\n\n    for (var j = 0; j < tokens.length; j++) {\n      // optimize for forward traversal by shifting for loop index\n      var i = getLookupIndex(j, this._lastFoundIndex, this.tokens.length);\n      var token = tokens[i];\n\n      // this is the token this node ends with\n      if (node.end === token.end) {\n        startToken = token;\n        endToken = tokens[i + 1];\n        if (endToken.type.label === \",\") endToken = tokens[i + 2];\n\n        this._lastFoundIndex = i;\n        break;\n      }\n    }\n\n    if (endToken && endToken.type.label === \"eof\") {\n      return 1;\n    } else {\n      var lines = this.getNewlinesBetween(startToken, endToken);\n      if (node.type === \"CommentLine\" && !lines) {\n        // line comment\n        return 1;\n      } else {\n        return lines;\n      }\n    }\n  };\n\n  /**\n   * Count all the newlines between two tokens.\n   */\n\n  Whitespace.prototype.getNewlinesBetween = function getNewlinesBetween(startToken, endToken) {\n    if (!endToken || !endToken.loc) return 0;\n\n    var start = startToken ? startToken.loc.end.line : 1;\n    var end = endToken.loc.start.line;\n    var lines = 0;\n\n    for (var line = start; line < end; line++) {\n      if (typeof this.used[line] === \"undefined\") {\n        this.used[line] = true;\n        lines++;\n      }\n    }\n\n    return lines;\n  };\n\n  return Whitespace;\n})();\n\nexports[\"default\"] = Whitespace;\nmodule.exports = exports[\"default\"];","/**\n * Printer for nodes, needs a `generator` and a `parent`.\n */\n\n\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar NodePrinter = (function () {\n  function NodePrinter(generator, parent) {\n    _classCallCheck(this, NodePrinter);\n\n    this.generator = generator;\n    this.parent = parent;\n  }\n\n  /**\n   * Description\n   */\n\n  NodePrinter.prototype.printInnerComments = function printInnerComments() {\n    if (!this.parent.innerComments) return;\n    var gen = this.generator;\n    gen.indent();\n    gen._printComments(this.parent.innerComments);\n    gen.dedent();\n  };\n\n  /**\n   * Print a plain node.\n   */\n\n  NodePrinter.prototype.plain = function plain(node, opts) {\n    return this.generator.print(node, this.parent, opts);\n  };\n\n  /**\n   * Print a sequence of nodes as statements.\n   */\n\n  NodePrinter.prototype.sequence = function sequence(nodes) {\n    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    opts.statement = true;\n    return this.generator.printJoin(this, nodes, opts);\n  };\n\n  /**\n   * Print a sequence of nodes as expressions.\n   */\n\n  NodePrinter.prototype.join = function join(nodes, opts) {\n    return this.generator.printJoin(this, nodes, opts);\n  };\n\n  /**\n   * Print a list of nodes, with a customizable separator (defaults to \",\").\n   */\n\n  NodePrinter.prototype.list = function list(items) {\n    var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    if (opts.separator == null) {\n      opts.separator = \",\";\n      if (!this.generator.format.compact) opts.separator += \" \";\n    }\n\n    return this.join(items, opts);\n  };\n\n  /**\n   * Print a block-like node.\n   */\n\n  NodePrinter.prototype.block = function block(node) {\n    return this.generator.printBlock(this, node);\n  };\n\n  /**\n   * Print node and indent comments.\n   */\n\n  NodePrinter.prototype.indentOnComments = function indentOnComments(node) {\n    return this.generator.printAndIndentOnComments(this, node);\n  };\n\n  return NodePrinter;\n})();\n\nexports[\"default\"] = NodePrinter;\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// istanbul ignore next\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _sourceMap = require(\"source-map\");\n\nvar _sourceMap2 = _interopRequireDefault(_sourceMap);\n\nvar _types = require(\"../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * Build a sourcemap.\n */\n\nvar SourceMap = (function () {\n  function SourceMap(position, opts, code) {\n    _classCallCheck(this, SourceMap);\n\n    this.position = position;\n    this.opts = opts;\n\n    if (opts.sourceMaps) {\n      this.map = new _sourceMap2[\"default\"].SourceMapGenerator({\n        file: opts.sourceMapTarget,\n        sourceRoot: opts.sourceRoot\n      });\n\n      this.map.setSourceContent(opts.sourceFileName, code);\n    } else {\n      this.map = null;\n    }\n  }\n\n  /**\n   * Get the sourcemap.\n   */\n\n  SourceMap.prototype.get = function get() {\n    var map = this.map;\n    if (map) {\n      return map.toJSON();\n    } else {\n      return map;\n    }\n  };\n\n  /**\n   * Mark a node's generated position, and add it to the sourcemap.\n   */\n\n  SourceMap.prototype.mark = function mark(node, type) {\n    var loc = node.loc;\n    if (!loc) return; // no location info\n\n    var map = this.map;\n    if (!map) return; // no source map\n\n    if (t.isProgram(node) || t.isFile(node)) return; // illegal mapping nodes\n\n    var position = this.position;\n\n    var generated = {\n      line: position.line,\n      column: position.column\n    };\n\n    var original = loc[type];\n\n    map.addMapping({\n      source: this.opts.sourceFileName,\n      generated: generated,\n      original: original\n    });\n  };\n\n  return SourceMap;\n})();\n\nexports[\"default\"] = SourceMap;\nmodule.exports = exports[\"default\"];","/**\n * Track current position in code generation.\n */\n\n\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Position = (function () {\n  function Position() {\n    _classCallCheck(this, Position);\n\n    this.line = 1;\n    this.column = 0;\n  }\n\n  /**\n   * Push a string to the current position, mantaining the current line and column.\n   */\n\n  Position.prototype.push = function push(str) {\n    for (var i = 0; i < str.length; i++) {\n      if (str[i] === \"\\n\") {\n        this.line++;\n        this.column = 0;\n      } else {\n        this.column++;\n      }\n    }\n  };\n\n  /**\n   * Unshift a string from the current position, mantaining the current line and column.\n   */\n\n  Position.prototype.unshift = function unshift(str) {\n    for (var i = 0; i < str.length; i++) {\n      if (str[i] === \"\\n\") {\n        this.line--;\n      } else {\n        this.column--;\n      }\n    }\n  };\n\n  return Position;\n})();\n\nexports[\"default\"] = Position;\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// istanbul ignore next\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _repeating = require(\"repeating\");\n\nvar _repeating2 = _interopRequireDefault(_repeating);\n\nvar _trimRight = require(\"trim-right\");\n\nvar _trimRight2 = _interopRequireDefault(_trimRight);\n\nvar _lodashLangIsBoolean = require(\"lodash/lang/isBoolean\");\n\nvar _lodashLangIsBoolean2 = _interopRequireDefault(_lodashLangIsBoolean);\n\nvar _lodashCollectionIncludes = require(\"lodash/collection/includes\");\n\nvar _lodashCollectionIncludes2 = _interopRequireDefault(_lodashCollectionIncludes);\n\nvar _lodashLangIsNumber = require(\"lodash/lang/isNumber\");\n\nvar _lodashLangIsNumber2 = _interopRequireDefault(_lodashLangIsNumber);\n\n/**\n * Buffer for collecting generated output.\n */\n\nvar Buffer = (function () {\n  function Buffer(position, format) {\n    _classCallCheck(this, Buffer);\n\n    this.parenPushNewlineState = null;\n\n    this.position = position;\n    this._indent = format.indent.base;\n    this.format = format;\n    this.buf = \"\";\n  }\n\n  /**\n   * Get the current trimmed buffer.\n   */\n\n  Buffer.prototype.get = function get() {\n    return _trimRight2[\"default\"](this.buf);\n  };\n\n  /**\n   * Get the current indent.\n   */\n\n  Buffer.prototype.getIndent = function getIndent() {\n    if (this.format.compact || this.format.concise) {\n      return \"\";\n    } else {\n      return _repeating2[\"default\"](this.format.indent.style, this._indent);\n    }\n  };\n\n  /**\n   * Get the current indent size.\n   */\n\n  Buffer.prototype.indentSize = function indentSize() {\n    return this.getIndent().length;\n  };\n\n  /**\n   * Increment indent size.\n   */\n\n  Buffer.prototype.indent = function indent() {\n    this._indent++;\n  };\n\n  /**\n   * Decrement indent size.\n   */\n\n  Buffer.prototype.dedent = function dedent() {\n    this._indent--;\n  };\n\n  /**\n   * Add a semicolon to the buffer.\n   */\n\n  Buffer.prototype.semicolon = function semicolon() {\n    this.push(\";\");\n  };\n\n  /**\n   * Ensure last character is a semicolon.\n   */\n\n  Buffer.prototype.ensureSemicolon = function ensureSemicolon() {\n    if (!this.isLast(\";\")) this.semicolon();\n  };\n\n  /**\n   * Add a right brace to the buffer.\n   */\n\n  Buffer.prototype.rightBrace = function rightBrace() {\n    this.newline(true);\n    //if (this.format.compact) this._removeLast(\";\");\n    this.push(\"}\");\n  };\n\n  /**\n   * Add a keyword to the buffer.\n   */\n\n  Buffer.prototype.keyword = function keyword(name) {\n    this.push(name);\n    this.space();\n  };\n\n  /**\n   * Add a space to the buffer unless it is compact (override with force).\n   */\n\n  Buffer.prototype.space = function space(force) {\n    if (!force && this.format.compact) return;\n\n    if (force || this.buf && !this.isLast(\" \") && !this.isLast(\"\\n\")) {\n      this.push(\" \");\n    }\n  };\n\n  /**\n   * Remove the last character.\n   */\n\n  Buffer.prototype.removeLast = function removeLast(cha) {\n    if (this.format.compact) return;\n    return this._removeLast(cha);\n  };\n\n  Buffer.prototype._removeLast = function _removeLast(cha) {\n    if (!this._isLast(cha)) return;\n    this.buf = this.buf.substr(0, this.buf.length - 1);\n    this.position.unshift(cha);\n  };\n\n  /**\n   * Set some state that will be modified if a newline has been inserted before any\n   * non-space characters.\n   *\n   * This is to prevent breaking semantics for terminatorless separator nodes. eg:\n   *\n   *    return foo;\n   *\n   * returns `foo`. But if we do:\n   *\n   *   return\n   *   foo;\n   *\n   *  `undefined` will be returned and not `foo` due to the terminator.\n   */\n\n  Buffer.prototype.startTerminatorless = function startTerminatorless() {\n    return this.parenPushNewlineState = {\n      printed: false\n    };\n  };\n\n  /**\n   * Print an ending parentheses if a starting one has been printed.\n   */\n\n  Buffer.prototype.endTerminatorless = function endTerminatorless(state) {\n    if (state.printed) {\n      this.dedent();\n      this.newline();\n      this.push(\")\");\n    }\n  };\n\n  /**\n   * Add a newline (or many newlines), maintaining formatting.\n   * Strips multiple newlines if removeLast is true.\n   */\n\n  Buffer.prototype.newline = function newline(i, removeLast) {\n    if (this.format.compact || this.format.retainLines) return;\n\n    if (this.format.concise) {\n      this.space();\n      return;\n    }\n\n    removeLast = removeLast || false;\n\n    if (_lodashLangIsNumber2[\"default\"](i)) {\n      i = Math.min(2, i);\n\n      if (this.endsWith(\"{\\n\") || this.endsWith(\":\\n\")) i--;\n      if (i <= 0) return;\n\n      while (i > 0) {\n        this._newline(removeLast);\n        i--;\n      }\n      return;\n    }\n\n    if (_lodashLangIsBoolean2[\"default\"](i)) {\n      removeLast = i;\n    }\n\n    this._newline(removeLast);\n  };\n\n  /**\n   * Adds a newline unless there is already two previous newlines.\n   */\n\n  Buffer.prototype._newline = function _newline(removeLast) {\n    // never allow more than two lines\n    if (this.endsWith(\"\\n\\n\")) return;\n\n    // remove the last newline\n    if (removeLast && this.isLast(\"\\n\")) this.removeLast(\"\\n\");\n\n    this.removeLast(\" \");\n    this._removeSpacesAfterLastNewline();\n    this._push(\"\\n\");\n  };\n\n  /**\n   * If buffer ends with a newline and some spaces after it, trim those spaces.\n   */\n\n  Buffer.prototype._removeSpacesAfterLastNewline = function _removeSpacesAfterLastNewline() {\n    var lastNewlineIndex = this.buf.lastIndexOf(\"\\n\");\n    if (lastNewlineIndex === -1) {\n      return;\n    }\n\n    var index = this.buf.length - 1;\n    while (index > lastNewlineIndex) {\n      if (this.buf[index] !== \" \") {\n        break;\n      }\n\n      index--;\n    }\n\n    if (index === lastNewlineIndex) {\n      this.buf = this.buf.substring(0, index + 1);\n    }\n  };\n\n  /**\n   * Push a string to the buffer, maintaining indentation and newlines.\n   */\n\n  Buffer.prototype.push = function push(str, noIndent) {\n    if (!this.format.compact && this._indent && !noIndent && str !== \"\\n\") {\n      // we have an indent level and we aren't pushing a newline\n      var indent = this.getIndent();\n\n      // replace all newlines with newlines with the indentation\n      str = str.replace(/\\n/g, \"\\n\" + indent);\n\n      // we've got a newline before us so prepend on the indentation\n      if (this.isLast(\"\\n\")) this._push(indent);\n    }\n\n    this._push(str);\n  };\n\n  /**\n   * Push a string to the buffer.\n   */\n\n  Buffer.prototype._push = function _push(str) {\n    // see startTerminatorless() instance method\n    var parenPushNewlineState = this.parenPushNewlineState;\n    if (parenPushNewlineState) {\n      for (var i = 0; i < str.length; i++) {\n        var cha = str[i];\n\n        // we can ignore spaces since they wont interupt a terminatorless separator\n        if (cha === \" \") continue;\n\n        this.parenPushNewlineState = null;\n\n        if (cha === \"\\n\" || cha === \"/\") {\n          // we're going to break this terminator expression so we need to add a parentheses\n          this._push(\"(\");\n          this.indent();\n          parenPushNewlineState.printed = true;\n        }\n\n        break;\n      }\n    }\n\n    //\n    this.position.push(str);\n    this.buf += str;\n  };\n\n  /**\n   * Test if the buffer ends with a string.\n   */\n\n  Buffer.prototype.endsWith = function endsWith(str) {\n    var buf = arguments.length <= 1 || arguments[1] === undefined ? this.buf : arguments[1];\n\n    if (str.length === 1) {\n      return buf[buf.length - 1] === str;\n    } else {\n      return buf.slice(-str.length) === str;\n    }\n  };\n\n  /**\n   * Test if a character is last in the buffer.\n   */\n\n  Buffer.prototype.isLast = function isLast(cha) {\n    if (this.format.compact) return false;\n    return this._isLast(cha);\n  };\n\n  Buffer.prototype._isLast = function _isLast(cha) {\n    var buf = this.buf;\n    var last = buf[buf.length - 1];\n\n    if (Array.isArray(cha)) {\n      return _lodashCollectionIncludes2[\"default\"](cha, last);\n    } else {\n      return cha === last;\n    }\n  };\n\n  return Buffer;\n})();\n\nexports[\"default\"] = Buffer;\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// istanbul ignore next\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _whitespace = require(\"./whitespace\");\n\nvar _whitespace2 = _interopRequireDefault(_whitespace);\n\nvar _parentheses = require(\"./parentheses\");\n\nvar parens = _interopRequireWildcard(_parentheses);\n\nvar _lodashCollectionEach = require(\"lodash/collection/each\");\n\nvar _lodashCollectionEach2 = _interopRequireDefault(_lodashCollectionEach);\n\nvar _lodashCollectionSome = require(\"lodash/collection/some\");\n\nvar _lodashCollectionSome2 = _interopRequireDefault(_lodashCollectionSome);\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * Test if node matches a set of type-matcher pairs.\n * @example\n * find({\n *   VariableDeclaration(node, parent) {\n *     return true;\n *   }\n * }, node, parent);\n */\n\nvar find = function find(obj, node, parent) {\n  if (!obj) return;\n  var result;\n\n  var types = Object.keys(obj);\n  for (var i = 0; i < types.length; i++) {\n    var type = types[i];\n\n    if (t.is(type, node)) {\n      var fn = obj[type];\n      result = fn(node, parent);\n      if (result != null) break;\n    }\n  }\n\n  return result;\n};\n\n/**\n * Whitespace and Parenthesis related methods for nodes.\n */\n\nvar Node = (function () {\n  function Node(node, parent) {\n    _classCallCheck(this, Node);\n\n    this.parent = parent;\n    this.node = node;\n  }\n\n  /**\n   * Add all static methods from `Node` to `Node.prototype`.\n   */\n\n  /**\n   * Test if `node` can have whitespace set by the user.\n   */\n\n  Node.isUserWhitespacable = function isUserWhitespacable(node) {\n    return t.isUserWhitespacable(node);\n  };\n\n  /**\n   * Test if a `node` requires whitespace.\n   */\n\n  Node.needsWhitespace = function needsWhitespace(node, parent, type) {\n    if (!node) return 0;\n\n    if (t.isExpressionStatement(node)) {\n      node = node.expression;\n    }\n\n    var linesInfo = find(_whitespace2[\"default\"].nodes, node, parent);\n\n    if (!linesInfo) {\n      var items = find(_whitespace2[\"default\"].list, node, parent);\n      if (items) {\n        for (var i = 0; i < items.length; i++) {\n          linesInfo = Node.needsWhitespace(items[i], node, type);\n          if (linesInfo) break;\n        }\n      }\n    }\n\n    return linesInfo && linesInfo[type] || 0;\n  };\n\n  /**\n   * Test if a `node` requires whitespace before it.\n   */\n\n  Node.needsWhitespaceBefore = function needsWhitespaceBefore(node, parent) {\n    return Node.needsWhitespace(node, parent, \"before\");\n  };\n\n  /**\n   * Test if a `note` requires whitespace after it.\n   */\n\n  Node.needsWhitespaceAfter = function needsWhitespaceAfter(node, parent) {\n    return Node.needsWhitespace(node, parent, \"after\");\n  };\n\n  /**\n   * Test if a `node` needs parentheses around it.\n   */\n\n  Node.needsParens = function needsParens(node, parent) {\n    if (!parent) return false;\n\n    if (t.isNewExpression(parent) && parent.callee === node) {\n      if (t.isCallExpression(node)) return true;\n\n      var hasCall = _lodashCollectionSome2[\"default\"](node, function (val) {\n        return t.isCallExpression(val);\n      });\n      if (hasCall) return true;\n    }\n\n    return find(parens, node, parent);\n  };\n\n  return Node;\n})();\n\nexports[\"default\"] = Node;\n_lodashCollectionEach2[\"default\"](Node, function (fn, key) {\n  Node.prototype[key] = function () {\n    // Avoid leaking arguments to prevent deoptimization\n    var args = new Array(arguments.length + 2);\n\n    args[0] = this.node;\n    args[1] = this.parent;\n\n    for (var i = 0; i < args.length; i++) {\n      args[i + 2] = arguments[i];\n    }\n\n    return Node[key].apply(null, args);\n  };\n});\nmodule.exports = exports[\"default\"];","\n\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _lodashLangIsBoolean = require(\"lodash/lang/isBoolean\");\n\nvar _lodashLangIsBoolean2 = _interopRequireDefault(_lodashLangIsBoolean);\n\nvar _lodashCollectionEach = require(\"lodash/collection/each\");\n\nvar _lodashCollectionEach2 = _interopRequireDefault(_lodashCollectionEach);\n\nvar _lodashCollectionMap = require(\"lodash/collection/map\");\n\nvar _lodashCollectionMap2 = _interopRequireDefault(_lodashCollectionMap);\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * Crawl a node to test if it contains a CallExpression, a Function, or a Helper.\n *\n * @example\n * crawl(node)\n * // { hasCall: false, hasFunction: true, hasHelper: false }\n */\n\nfunction crawl(node) {\n  var state = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n  if (t.isMemberExpression(node)) {\n    crawl(node.object, state);\n    if (node.computed) crawl(node.property, state);\n  } else if (t.isBinary(node) || t.isAssignmentExpression(node)) {\n    crawl(node.left, state);\n    crawl(node.right, state);\n  } else if (t.isCallExpression(node)) {\n    state.hasCall = true;\n    crawl(node.callee, state);\n  } else if (t.isFunction(node)) {\n    state.hasFunction = true;\n  } else if (t.isIdentifier(node)) {\n    state.hasHelper = state.hasHelper || isHelper(node.callee);\n  }\n\n  return state;\n}\n\n/**\n * Test if a node is or has a helper.\n */\n\nfunction isHelper(node) {\n  if (t.isMemberExpression(node)) {\n    return isHelper(node.object) || isHelper(node.property);\n  } else if (t.isIdentifier(node)) {\n    return node.name === \"require\" || node.name[0] === \"_\";\n  } else if (t.isCallExpression(node)) {\n    return isHelper(node.callee);\n  } else if (t.isBinary(node) || t.isAssignmentExpression(node)) {\n    return t.isIdentifier(node.left) && isHelper(node.left) || isHelper(node.right);\n  } else {\n    return false;\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction isType(node) {\n  return t.isLiteral(node) || t.isObjectExpression(node) || t.isArrayExpression(node) || t.isIdentifier(node) || t.isMemberExpression(node);\n}\n\n/**\n * Tests for node types that need whitespace.\n */\n\nexports.nodes = {\n\n  /**\n   * Test if AssignmentExpression needs whitespace.\n   */\n\n  AssignmentExpression: function AssignmentExpression(node) {\n    var state = crawl(node.right);\n    if (state.hasCall && state.hasHelper || state.hasFunction) {\n      return {\n        before: state.hasFunction,\n        after: true\n      };\n    }\n  },\n\n  /**\n   * Test if SwitchCase needs whitespace.\n   */\n\n  SwitchCase: function SwitchCase(node, parent) {\n    return {\n      before: node.consequent.length || parent.cases[0] === node\n    };\n  },\n\n  /**\n   * Test if LogicalExpression needs whitespace.\n   */\n\n  LogicalExpression: function LogicalExpression(node) {\n    if (t.isFunction(node.left) || t.isFunction(node.right)) {\n      return {\n        after: true\n      };\n    }\n  },\n\n  /**\n   * Test if Literal needs whitespace.\n   */\n\n  Literal: function Literal(node) {\n    if (node.value === \"use strict\") {\n      return {\n        after: true\n      };\n    }\n  },\n\n  /**\n   * Test if CallExpression needs whitespace.\n   */\n\n  CallExpression: function CallExpression(node) {\n    if (t.isFunction(node.callee) || isHelper(node)) {\n      return {\n        before: true,\n        after: true\n      };\n    }\n  },\n\n  /**\n   * Test if VariableDeclaration needs whitespace.\n   */\n\n  VariableDeclaration: function VariableDeclaration(node) {\n    for (var i = 0; i < node.declarations.length; i++) {\n      var declar = node.declarations[i];\n\n      var enabled = isHelper(declar.id) && !isType(declar.init);\n      if (!enabled) {\n        var state = crawl(declar.init);\n        enabled = isHelper(declar.init) && state.hasCall || state.hasFunction;\n      }\n\n      if (enabled) {\n        return {\n          before: true,\n          after: true\n        };\n      }\n    }\n  },\n\n  /**\n   * Test if IfStatement needs whitespace.\n   */\n\n  IfStatement: function IfStatement(node) {\n    if (t.isBlockStatement(node.consequent)) {\n      return {\n        before: true,\n        after: true\n      };\n    }\n  }\n};\n\n/**\n * Test if Property or SpreadProperty needs whitespace.\n */\n\nexports.nodes.Property = exports.nodes.SpreadProperty = function (node, parent) {\n  if (parent.properties[0] === node) {\n    return {\n      before: true\n    };\n  }\n};\n\n/**\n * Returns lists from node types that need whitespace.\n */\n\nexports.list = {\n\n  /**\n   * Return VariableDeclaration declarations init properties.\n   */\n\n  VariableDeclaration: function VariableDeclaration(node) {\n    return _lodashCollectionMap2[\"default\"](node.declarations, \"init\");\n  },\n\n  /**\n   * Return VariableDeclaration elements.\n   */\n\n  ArrayExpression: function ArrayExpression(node) {\n    return node.elements;\n  },\n\n  /**\n   * Return VariableDeclaration properties.\n   */\n\n  ObjectExpression: function ObjectExpression(node) {\n    return node.properties;\n  }\n};\n\n/**\n * Add whitespace tests for nodes and their aliases.\n */\n\n_lodashCollectionEach2[\"default\"]({\n  Function: true,\n  Class: true,\n  Loop: true,\n  LabeledStatement: true,\n  SwitchStatement: true,\n  TryStatement: true\n}, function (amounts, type) {\n  if (_lodashLangIsBoolean2[\"default\"](amounts)) {\n    amounts = { after: amounts, before: amounts };\n  }\n\n  _lodashCollectionEach2[\"default\"]([type].concat(t.FLIPPED_ALIAS_KEYS[type] || []), function (type) {\n    exports.nodes[type] = function () {\n      return amounts;\n    };\n  });\n});","\n\nexports.__esModule = true;\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nexports.UpdateExpression = UpdateExpression;\nexports.ObjectExpression = ObjectExpression;\nexports.Binary = Binary;\nexports.BinaryExpression = BinaryExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.YieldExpression = YieldExpression;\nexports.ClassExpression = ClassExpression;\nexports.UnaryLike = UnaryLike;\nexports.FunctionExpression = FunctionExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.AssignmentExpression = AssignmentExpression;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _lodashCollectionEach = require(\"lodash/collection/each\");\n\nvar _lodashCollectionEach2 = _interopRequireDefault(_lodashCollectionEach);\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * Create a mapping of operators to precendence.\n *\n * @example\n * { \"==\": 6, \"+\": 9 }\n */\nvar PRECEDENCE = {};\n\n_lodashCollectionEach2[\"default\"]([[\"||\"], [\"&&\"], [\"|\"], [\"^\"], [\"&\"], [\"==\", \"===\", \"!=\", \"!==\"], [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"], [\">>\", \"<<\", \">>>\"], [\"+\", \"-\"], [\"*\", \"/\", \"%\"], [\"**\"]], function (tier, i) {\n  _lodashCollectionEach2[\"default\"](tier, function (op) {\n    PRECEDENCE[op] = i;\n  });\n});\n\n/**\n * Test if NullableTypeAnnotation needs parentheses.\n */\n\nfunction NullableTypeAnnotation(node, parent) {\n  return t.isArrayTypeAnnotation(parent);\n}\n\n/**\n * Alias NullableTypeAnnotation test as FunctionTypeAnnotation.\n */\n\nexports.FunctionTypeAnnotation = NullableTypeAnnotation;\n\n/**\n * Test if UpdateExpression needs parentheses.\n */\n\nfunction UpdateExpression(node, parent) {\n  if (t.isMemberExpression(parent) && parent.object === node) {\n    // (foo++).test()\n    return true;\n  }\n}\n\n/**\n * Test if ObjectExpression needs parentheses.\n */\n\nfunction ObjectExpression(node, parent) {\n  if (t.isExpressionStatement(parent)) {\n    // ({ foo: \"bar\" });\n    return true;\n  }\n\n  if (t.isMemberExpression(parent) && parent.object === node) {\n    // ({ foo: \"bar\" }).foo\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Test if Binary needs parentheses.\n */\n\nfunction Binary(node, parent) {\n  if ((t.isCallExpression(parent) || t.isNewExpression(parent)) && parent.callee === node) {\n    return true;\n  }\n\n  if (t.isUnaryLike(parent)) {\n    return true;\n  }\n\n  if (t.isMemberExpression(parent) && parent.object === node) {\n    return true;\n  }\n\n  if (t.isBinary(parent)) {\n    var parentOp = parent.operator;\n    var parentPos = PRECEDENCE[parentOp];\n\n    var nodeOp = node.operator;\n    var nodePos = PRECEDENCE[nodeOp];\n\n    if (parentPos > nodePos) {\n      return true;\n    }\n\n    // Logical expressions with the same precedence don't need parens.\n    if (parentPos === nodePos && parent.right === node && !t.isLogicalExpression(parent)) {\n      return true;\n    }\n  }\n}\n\n/**\n * Test if BinaryExpression needs parentheses.\n */\n\nfunction BinaryExpression(node, parent) {\n  if (node.operator === \"in\") {\n    // var i = (1 in []);\n    if (t.isVariableDeclarator(parent)) {\n      return true;\n    }\n\n    // for ((1 in []);;);\n    if (t.isFor(parent)) {\n      return true;\n    }\n  }\n}\n\n/**\n * Test if SequenceExpression needs parentheses.\n */\n\nfunction SequenceExpression(node, parent) {\n  if (t.isForStatement(parent)) {\n    // Although parentheses wouldn't hurt around sequence\n    // expressions in the head of for loops, traditional style\n    // dictates that e.g. i++, j++ should not be wrapped with\n    // parentheses.\n    return false;\n  }\n\n  if (t.isExpressionStatement(parent) && parent.expression === node) {\n    return false;\n  }\n\n  if (t.isReturnStatement(parent)) {\n    return false;\n  }\n\n  // Otherwise err on the side of overparenthesization, adding\n  // explicit exceptions above if this proves overzealous.\n  return true;\n}\n\n/**\n * Test if YieldExpression needs parentheses.\n */\n\nfunction YieldExpression(node, parent) {\n  return t.isBinary(parent) || t.isUnaryLike(parent) || t.isCallExpression(parent) || t.isMemberExpression(parent) || t.isNewExpression(parent) || t.isConditionalExpression(parent) || t.isYieldExpression(parent);\n}\n\n/**\n * Test if ClassExpression needs parentheses.\n */\n\nfunction ClassExpression(node, parent) {\n  return t.isExpressionStatement(parent);\n}\n\n/**\n * Test if UnaryLike needs parentheses.\n */\n\nfunction UnaryLike(node, parent) {\n  return t.isMemberExpression(parent) && parent.object === node;\n}\n\n/**\n * Test if FunctionExpression needs parentheses.\n */\n\nfunction FunctionExpression(node, parent) {\n  // function () {};\n  if (t.isExpressionStatement(parent)) {\n    return true;\n  }\n\n  // (function test() {}).name;\n  if (t.isMemberExpression(parent) && parent.object === node) {\n    return true;\n  }\n\n  // (function () {})();\n  if (t.isCallExpression(parent) && parent.callee === node) {\n    return true;\n  }\n}\n\n/**\n * Test if ConditionalExpression needs parentheses.\n */\n\nfunction ConditionalExpression(node, parent) {\n  if (t.isUnaryLike(parent)) {\n    return true;\n  }\n\n  if (t.isBinary(parent)) {\n    return true;\n  }\n\n  if (t.isCallExpression(parent) || t.isNewExpression(parent)) {\n    if (parent.callee === node) {\n      return true;\n    }\n  }\n\n  if (t.isConditionalExpression(parent) && parent.test === node) {\n    return true;\n  }\n\n  if (t.isMemberExpression(parent) && parent.object === node) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Test if AssignmentExpression needs parentheses.\n */\n\nfunction AssignmentExpression(node) {\n  if (t.isObjectPattern(node.left)) {\n    return true;\n  } else {\n    return ConditionalExpression.apply(undefined, arguments);\n  }\n}","/**\n * Prints TaggedTemplateExpression, prints tag and quasi.\n */\n\n\n\nexports.__esModule = true;\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nexports.TemplateElement = TemplateElement;\nexports.TemplateLiteral = TemplateLiteral;\n\nfunction TaggedTemplateExpression(node, print) {\n  print.plain(node.tag);\n  print.plain(node.quasi);\n}\n\n/**\n * Prints TemplateElement, prints value.\n */\n\nfunction TemplateElement(node) {\n  this._push(node.value.raw);\n}\n\n/**\n * Prints TemplateLiteral, prints quasis, and expressions.\n */\n\nfunction TemplateLiteral(node, print) {\n  this.push(\"`\");\n\n  var quasis = node.quasis;\n  var len = quasis.length;\n\n  for (var i = 0; i < len; i++) {\n    print.plain(quasis[i]);\n\n    if (i + 1 < len) {\n      this.push(\"${ \");\n      print.plain(node.expressions[i]);\n      this.push(\" }\");\n    }\n  }\n\n  this._push(\"`\");\n}","/**\n * Prints ComprehensionBlock, prints left and right.\n */\n\n\n\nexports.__esModule = true;\nexports.ComprehensionBlock = ComprehensionBlock;\nexports.ComprehensionExpression = ComprehensionExpression;\n\nfunction ComprehensionBlock(node, print) {\n  this.keyword(\"for\");\n  this.push(\"(\");\n  print.plain(node.left);\n  this.push(\" of \");\n  print.plain(node.right);\n  this.push(\")\");\n}\n\n/**\n * Prints ComprehensionExpression, prints blocks, filter, and body. Handles generators.\n */\n\nfunction ComprehensionExpression(node, print) {\n  this.push(node.generator ? \"(\" : \"[\");\n\n  print.join(node.blocks, { separator: \" \" });\n  this.space();\n\n  if (node.filter) {\n    this.keyword(\"if\");\n    this.push(\"(\");\n    print.plain(node.filter);\n    this.push(\")\");\n    this.space();\n  }\n\n  print.plain(node.body);\n\n  this.push(node.generator ? \")\" : \"]\");\n}","\n\nexports.__esModule = true;\nexports.UnaryExpression = UnaryExpression;\nexports.DoExpression = DoExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.NewExpression = NewExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.ThisExpression = ThisExpression;\nexports.Super = Super;\nexports.Decorator = Decorator;\nexports.CallExpression = CallExpression;\nexports.EmptyStatement = EmptyStatement;\nexports.ExpressionStatement = ExpressionStatement;\nexports.AssignmentPattern = AssignmentPattern;\nexports.AssignmentExpression = AssignmentExpression;\nexports.BindExpression = BindExpression;\nexports.MemberExpression = MemberExpression;\nexports.MetaProperty = MetaProperty;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _isInteger = require(\"is-integer\");\n\nvar _isInteger2 = _interopRequireDefault(_isInteger);\n\nvar _lodashLangIsNumber = require(\"lodash/lang/isNumber\");\n\nvar _lodashLangIsNumber2 = _interopRequireDefault(_lodashLangIsNumber);\n\nvar _node = require(\"../node\");\n\nvar _node2 = _interopRequireDefault(_node);\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * RegExp for testing scientific notation in literals.\n */\n\nvar SCIENTIFIC_NOTATION = /e/i;\nvar ZERO_DECIMAL_INTEGER = /\\.0+$/;\n\n/**\n * RegExp for testing if a numeric literal is\n * a BinaryIntegerLiteral, OctalIntegerLiteral or HexIntegerLiteral.\n */\n\nvar NON_DECIMAL_NUMERIC_LITERAL = /^0(b|o|x)/i;\n\n/**\n * Prints UnaryExpression, prints operator and argument.\n */\n\nfunction UnaryExpression(node, print) {\n  var needsSpace = /[a-z]$/.test(node.operator);\n  var arg = node.argument;\n\n  if (t.isUpdateExpression(arg) || t.isUnaryExpression(arg)) {\n    needsSpace = true;\n  }\n\n  if (t.isUnaryExpression(arg) && arg.operator === \"!\") {\n    needsSpace = false;\n  }\n\n  this.push(node.operator);\n  if (needsSpace) this.push(\" \");\n  print.plain(node.argument);\n}\n\n/**\n * Prints DoExpression, prints body.\n */\n\nfunction DoExpression(node, print) {\n  this.push(\"do\");\n  this.space();\n  print.plain(node.body);\n}\n\n/**\n * Prints ParenthesizedExpression, prints expression.\n */\n\nfunction ParenthesizedExpression(node, print) {\n  this.push(\"(\");\n  print.plain(node.expression);\n  this.push(\")\");\n}\n\n/**\n * Prints UpdateExpression, prints operator and argument.\n */\n\nfunction UpdateExpression(node, print) {\n  if (node.prefix) {\n    this.push(node.operator);\n    print.plain(node.argument);\n  } else {\n    print.plain(node.argument);\n    this.push(node.operator);\n  }\n}\n\n/**\n * Prints ConditionalExpression, prints test, consequent, and alternate.\n */\n\nfunction ConditionalExpression(node, print) {\n  print.plain(node.test);\n  this.space();\n  this.push(\"?\");\n  this.space();\n  print.plain(node.consequent);\n  this.space();\n  this.push(\":\");\n  this.space();\n  print.plain(node.alternate);\n}\n\n/**\n * Prints NewExpression, prints callee and arguments.\n */\n\nfunction NewExpression(node, print) {\n  this.push(\"new \");\n  print.plain(node.callee);\n  this.push(\"(\");\n  print.list(node.arguments);\n  this.push(\")\");\n}\n\n/**\n * Prints SequenceExpression.expressions.\n */\n\nfunction SequenceExpression(node, print) {\n  print.list(node.expressions);\n}\n\n/**\n * Prints ThisExpression.\n */\n\nfunction ThisExpression() {\n  this.push(\"this\");\n}\n\n/**\n * Prints Super.\n */\n\nfunction Super() {\n  this.push(\"super\");\n}\n\n/**\n * Prints Decorator, prints expression.\n */\n\nfunction Decorator(node, print) {\n  this.push(\"@\");\n  print.plain(node.expression);\n  this.newline();\n}\n\n/**\n * Prints CallExpression, prints callee and arguments.\n */\n\nfunction CallExpression(node, print) {\n  print.plain(node.callee);\n\n  this.push(\"(\");\n\n  var isPrettyCall = node._prettyCall && !this.format.retainLines && !this.format.compact;\n\n  var separator;\n  if (isPrettyCall) {\n    separator = \",\\n\";\n    this.newline();\n    this.indent();\n  }\n\n  print.list(node.arguments, { separator: separator });\n\n  if (isPrettyCall) {\n    this.newline();\n    this.dedent();\n  }\n\n  this.push(\")\");\n}\n\n/**\n * Builds yield or await expression printer.\n * Prints delegate, all, and argument.\n */\n\nvar buildYieldAwait = function buildYieldAwait(keyword) {\n  return function (node, print) {\n    this.push(keyword);\n\n    if (node.delegate || node.all) {\n      this.push(\"*\");\n    }\n\n    if (node.argument) {\n      this.push(\" \");\n      var terminatorState = this.startTerminatorless();\n      print.plain(node.argument);\n      this.endTerminatorless(terminatorState);\n    }\n  };\n};\n\n/**\n * Create YieldExpression and AwaitExpression printers.\n */\n\nvar YieldExpression = buildYieldAwait(\"yield\");\nexports.YieldExpression = YieldExpression;\nvar AwaitExpression = buildYieldAwait(\"await\");\n\nexports.AwaitExpression = AwaitExpression;\n/**\n * Prints EmptyStatement.\n */\n\nfunction EmptyStatement() {\n  this.semicolon();\n}\n\n/**\n * Prints ExpressionStatement, prints expression.\n */\n\nfunction ExpressionStatement(node, print) {\n  print.plain(node.expression);\n  this.semicolon();\n}\n\n/**\n * Prints AssignmentPattern, prints left and right.\n */\n\nfunction AssignmentPattern(node, print) {\n  print.plain(node.left);\n  this.push(\" = \");\n  print.plain(node.right);\n}\n\n/**\n * Prints AssignmentExpression, prints left, operator, and right.\n */\n\nfunction AssignmentExpression(node, print, parent) {\n  // Somewhere inside a for statement `init` node but doesn't usually\n  // needs a paren except for `in` expressions: `for (a in b ? a : b;;)`\n  var parens = this._inForStatementInit && node.operator === \"in\" && !_node2[\"default\"].needsParens(node, parent);\n\n  if (parens) {\n    this.push(\"(\");\n  }\n\n  // todo: add cases where the spaces can be dropped when in compact mode\n  print.plain(node.left);\n\n  var spaces = node.operator === \"in\" || node.operator === \"instanceof\";\n  spaces = true; // todo: https://github.com/babel/babel/issues/1835\n  this.space(spaces);\n\n  this.push(node.operator);\n\n  if (!spaces) {\n    // space is mandatory to avoid outputting <!--\n    // http://javascript.spec.whatwg.org/#comment-syntax\n    spaces = node.operator === \"<\" && t.isUnaryExpression(node.right, { prefix: true, operator: \"!\" }) && t.isUnaryExpression(node.right.argument, { prefix: true, operator: \"--\" });\n  }\n\n  this.space(spaces);\n\n  print.plain(node.right);\n\n  if (parens) {\n    this.push(\")\");\n  }\n}\n\n/**\n * Prints BindExpression, prints object and callee.\n */\n\nfunction BindExpression(node, print) {\n  print.plain(node.object);\n  this.push(\"::\");\n  print.plain(node.callee);\n}\n\n/**\n * Alias ClassDeclaration printer as ClassExpression,\n * and AssignmentExpression printer as LogicalExpression.\n */\n\nexports.BinaryExpression = AssignmentExpression;\nexports.LogicalExpression = AssignmentExpression;\n\n/**\n * Print MemberExpression, prints object, property, and value. Handles computed.\n */\n\nfunction MemberExpression(node, print) {\n  var obj = node.object;\n  print.plain(obj);\n\n  if (!node.computed && t.isMemberExpression(node.property)) {\n    throw new TypeError(\"Got a MemberExpression for MemberExpression property\");\n  }\n\n  var computed = node.computed;\n  if (t.isLiteral(node.property) && _lodashLangIsNumber2[\"default\"](node.property.value)) {\n    computed = true;\n  }\n\n  if (computed) {\n    this.push(\"[\");\n    print.plain(node.property);\n    this.push(\"]\");\n  } else {\n    if (t.isLiteral(node.object)) {\n      var val = this._Literal(node.object);\n      if (_isInteger2[\"default\"](+val) && !ZERO_DECIMAL_INTEGER.test(val) && !SCIENTIFIC_NOTATION.test(val) && !this.endsWith(\".\") && !NON_DECIMAL_NUMERIC_LITERAL.test(val)) {\n        this.push(\".\");\n      }\n    }\n\n    this.push(\".\");\n    print.plain(node.property);\n  }\n}\n\n/**\n * Print MetaProperty, prints meta and property.\n */\n\nfunction MetaProperty(node, print) {\n  print.plain(node.meta);\n  this.push(\".\");\n  print.plain(node.property);\n}","\n\nexports.__esModule = true;\nexports.WithStatement = WithStatement;\nexports.IfStatement = IfStatement;\nexports.ForStatement = ForStatement;\nexports.WhileStatement = WhileStatement;\nexports.DoWhileStatement = DoWhileStatement;\nexports.LabeledStatement = LabeledStatement;\nexports.TryStatement = TryStatement;\nexports.CatchClause = CatchClause;\nexports.SwitchStatement = SwitchStatement;\nexports.SwitchCase = SwitchCase;\nexports.DebuggerStatement = DebuggerStatement;\nexports.VariableDeclaration = VariableDeclaration;\nexports.VariableDeclarator = VariableDeclarator;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _repeating = require(\"repeating\");\n\nvar _repeating2 = _interopRequireDefault(_repeating);\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * Prints WithStatement, prints object and body.\n */\n\nfunction WithStatement(node, print) {\n  this.keyword(\"with\");\n  this.push(\"(\");\n  print.plain(node.object);\n  this.push(\")\");\n  print.block(node.body);\n}\n\n/**\n * Prints IfStatement, prints test, consequent, and alternate.\n */\n\nfunction IfStatement(node, print) {\n  this.keyword(\"if\");\n  this.push(\"(\");\n  print.plain(node.test);\n  this.push(\")\");\n  this.space();\n\n  print.indentOnComments(node.consequent);\n\n  if (node.alternate) {\n    if (this.isLast(\"}\")) this.space();\n    this.push(\"else \");\n    print.indentOnComments(node.alternate);\n  }\n}\n\n/**\n * Prints ForStatement, prints init, test, update, and body.\n */\n\nfunction ForStatement(node, print) {\n  this.keyword(\"for\");\n  this.push(\"(\");\n\n  this._inForStatementInit = true;\n  print.plain(node.init);\n  this._inForStatementInit = false;\n  this.push(\";\");\n\n  if (node.test) {\n    this.space();\n    print.plain(node.test);\n  }\n  this.push(\";\");\n\n  if (node.update) {\n    this.space();\n    print.plain(node.update);\n  }\n\n  this.push(\")\");\n  print.block(node.body);\n}\n\n/**\n * Prints WhileStatement, prints test and body.\n */\n\nfunction WhileStatement(node, print) {\n  this.keyword(\"while\");\n  this.push(\"(\");\n  print.plain(node.test);\n  this.push(\")\");\n  print.block(node.body);\n}\n\n/**\n * Builds ForIn or ForOf statement printers.\n * Prints left, right, and body.\n */\n\nvar buildForXStatement = function buildForXStatement(op) {\n  return function (node, print) {\n    this.keyword(\"for\");\n    this.push(\"(\");\n    print.plain(node.left);\n    this.push(\" \" + op + \" \");\n    print.plain(node.right);\n    this.push(\")\");\n    print.block(node.body);\n  };\n};\n\n/**\n * Create ForInStatement and ForOfStatement printers.\n */\n\nvar ForInStatement = buildForXStatement(\"in\");\nexports.ForInStatement = ForInStatement;\nvar ForOfStatement = buildForXStatement(\"of\");\n\nexports.ForOfStatement = ForOfStatement;\n/**\n * Prints DoWhileStatement, prints body and test.\n */\n\nfunction DoWhileStatement(node, print) {\n  this.push(\"do \");\n  print.plain(node.body);\n  this.space();\n  this.keyword(\"while\");\n  this.push(\"(\");\n  print.plain(node.test);\n  this.push(\");\");\n}\n\n/**\n * Builds continue, return, or break statement printers.\n * Prints label (or key).\n */\n\nvar buildLabelStatement = function buildLabelStatement(prefix) {\n  var key = arguments.length <= 1 || arguments[1] === undefined ? \"label\" : arguments[1];\n\n  return function (node, print) {\n    this.push(prefix);\n\n    var label = node[key];\n    if (label) {\n      this.push(\" \");\n      var terminatorState = this.startTerminatorless();\n      print.plain(label);\n      this.endTerminatorless(terminatorState);\n    }\n\n    this.semicolon();\n  };\n};\n\n/**\n * Create ContinueStatement, ReturnStatement, and BreakStatement printers.\n */\n\nvar ContinueStatement = buildLabelStatement(\"continue\");\nexports.ContinueStatement = ContinueStatement;\nvar ReturnStatement = buildLabelStatement(\"return\", \"argument\");\nexports.ReturnStatement = ReturnStatement;\nvar BreakStatement = buildLabelStatement(\"break\");\nexports.BreakStatement = BreakStatement;\nvar ThrowStatement = buildLabelStatement(\"throw\", \"argument\");\n\nexports.ThrowStatement = ThrowStatement;\n/**\n * Prints LabeledStatement, prints label and body.\n */\n\nfunction LabeledStatement(node, print) {\n  print.plain(node.label);\n  this.push(\": \");\n  print.plain(node.body);\n}\n\n/**\n * Prints TryStatement, prints block, handlers, and finalizer.\n */\n\nfunction TryStatement(node, print) {\n  this.keyword(\"try\");\n  print.plain(node.block);\n  this.space();\n\n  // Esprima bug puts the catch clause in a `handlers` array.\n  // see https://code.google.com/p/esprima/issues/detail?id=433\n  // We run into this from regenerator generated ast.\n  if (node.handlers) {\n    print.plain(node.handlers[0]);\n  } else {\n    print.plain(node.handler);\n  }\n\n  if (node.finalizer) {\n    this.space();\n    this.push(\"finally \");\n    print.plain(node.finalizer);\n  }\n}\n\n/**\n * Prints CatchClause, prints param and body.\n */\n\nfunction CatchClause(node, print) {\n  this.keyword(\"catch\");\n  this.push(\"(\");\n  print.plain(node.param);\n  this.push(\") \");\n  print.plain(node.body);\n}\n\n/**\n * Prints SwitchStatement, prints discriminant and cases.\n */\n\nfunction SwitchStatement(node, print) {\n  this.keyword(\"switch\");\n  this.push(\"(\");\n  print.plain(node.discriminant);\n  this.push(\")\");\n  this.space();\n  this.push(\"{\");\n\n  print.sequence(node.cases, {\n    indent: true,\n    addNewlines: function addNewlines(leading, cas) {\n      if (!leading && node.cases[node.cases.length - 1] === cas) return -1;\n    }\n  });\n\n  this.push(\"}\");\n}\n\n/**\n * Prints SwitchCase, prints test and consequent.\n */\n\nfunction SwitchCase(node, print) {\n  if (node.test) {\n    this.push(\"case \");\n    print.plain(node.test);\n    this.push(\":\");\n  } else {\n    this.push(\"default:\");\n  }\n\n  if (node.consequent.length) {\n    this.newline();\n    print.sequence(node.consequent, { indent: true });\n  }\n}\n\n/**\n * Prints DebuggerStatement.\n */\n\nfunction DebuggerStatement() {\n  this.push(\"debugger;\");\n}\n\n/**\n * Prints VariableDeclaration, prints declarations, handles kind and format.\n */\n\nfunction VariableDeclaration(node, print, parent) {\n  this.push(node.kind + \" \");\n\n  var hasInits = false;\n  // don't add whitespace to loop heads\n  if (!t.isFor(parent)) {\n    var _arr = node.declarations;\n\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var declar = _arr[_i];\n      if (declar.init) {\n        // has an init so let's split it up over multiple lines\n        hasInits = true;\n      }\n    }\n  }\n\n  //\n  // use a pretty separator when we aren't in compact mode, have initializers and don't have retainLines on\n  // this will format declarations like:\n  //\n  //   var foo = \"bar\", bar = \"foo\";\n  //\n  // into\n  //\n  //   var foo = \"bar\",\n  //       bar = \"foo\";\n  //\n\n  var sep;\n  if (!this.format.compact && !this.format.concise && hasInits && !this.format.retainLines) {\n    sep = \",\\n\" + _repeating2[\"default\"](\" \", node.kind.length + 1);\n  }\n\n  //\n\n  print.list(node.declarations, { separator: sep });\n\n  if (t.isFor(parent)) {\n    // don't give semicolons to these nodes since they'll be inserted in the parent generator\n    if (parent.left === node || parent.init === node) return;\n  }\n\n  this.semicolon();\n}\n\n/**\n * Prints VariableDeclarator, handles id, id.typeAnnotation, and init.\n */\n\nfunction VariableDeclarator(node, print) {\n  print.plain(node.id);\n  print.plain(node.id.typeAnnotation);\n  if (node.init) {\n    this.space();\n    this.push(\"=\");\n    this.space();\n    print.plain(node.init);\n  }\n}","/**\n * Print ClassDeclaration, prints decorators, typeParameters, extends, implements, and body.\n */\n\n\n\nexports.__esModule = true;\nexports.ClassDeclaration = ClassDeclaration;\nexports.ClassBody = ClassBody;\nexports.ClassProperty = ClassProperty;\nexports.MethodDefinition = MethodDefinition;\n\nfunction ClassDeclaration(node, print) {\n  print.list(node.decorators, { separator: \"\" });\n  this.push(\"class\");\n\n  if (node.id) {\n    this.push(\" \");\n    print.plain(node.id);\n  }\n\n  print.plain(node.typeParameters);\n\n  if (node.superClass) {\n    this.push(\" extends \");\n    print.plain(node.superClass);\n    print.plain(node.superTypeParameters);\n  }\n\n  if (node[\"implements\"]) {\n    this.push(\" implements \");\n    print.join(node[\"implements\"], { separator: \", \" });\n  }\n\n  this.space();\n  print.plain(node.body);\n}\n\n/**\n * Alias ClassDeclaration printer as ClassExpression.\n */\n\nexports.ClassExpression = ClassDeclaration;\n\n/**\n * Print ClassBody, collapses empty blocks, prints body.\n */\n\nfunction ClassBody(node, print) {\n  this.push(\"{\");\n  if (node.body.length === 0) {\n    print.printInnerComments();\n    this.push(\"}\");\n  } else {\n    this.newline();\n\n    this.indent();\n    print.sequence(node.body);\n    this.dedent();\n\n    this.rightBrace();\n  }\n}\n\n/**\n * Print ClassProperty, prints decorators, static, key, typeAnnotation, and value.\n * Also: semicolons, deal with it.\n */\n\nfunction ClassProperty(node, print) {\n  print.list(node.decorators, { separator: \"\" });\n\n  if (node[\"static\"]) this.push(\"static \");\n  print.plain(node.key);\n  print.plain(node.typeAnnotation);\n  if (node.value) {\n    this.space();\n    this.push(\"=\");\n    this.space();\n    print.plain(node.value);\n  }\n  this.semicolon();\n}\n\n/**\n * Print MethodDefinition, prints decorations, static, and method.\n */\n\nfunction MethodDefinition(node, print) {\n  print.list(node.decorators, { separator: \"\" });\n\n  if (node[\"static\"]) {\n    this.push(\"static \");\n  }\n\n  this._method(node, print);\n}","\n\nexports.__esModule = true;\nexports._params = _params;\nexports._method = _method;\nexports.FunctionExpression = FunctionExpression;\nexports.ArrowFunctionExpression = ArrowFunctionExpression;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * Prints nodes with params, prints typeParameters, params, and returnType, handles optional params.\n */\n\nfunction _params(node, print) {\n  // istanbul ignore next\n\n  var _this = this;\n\n  print.plain(node.typeParameters);\n  this.push(\"(\");\n  print.list(node.params, {\n    iterator: function iterator(node) {\n      if (node.optional) _this.push(\"?\");\n      print.plain(node.typeAnnotation);\n    }\n  });\n  this.push(\")\");\n\n  if (node.returnType) {\n    print.plain(node.returnType);\n  }\n}\n\n/**\n * Prints method-like nodes, prints key, value, and body, handles async, generator, computed, and get or set.\n */\n\nfunction _method(node, print) {\n  var value = node.value;\n  var kind = node.kind;\n  var key = node.key;\n\n  if (kind === \"method\" || kind === \"init\") {\n    if (value.generator) {\n      this.push(\"*\");\n    }\n  }\n\n  if (kind === \"get\" || kind === \"set\") {\n    this.push(kind + \" \");\n  }\n\n  if (value.async) this.push(\"async \");\n\n  if (node.computed) {\n    this.push(\"[\");\n    print.plain(key);\n    this.push(\"]\");\n  } else {\n    print.plain(key);\n  }\n\n  this._params(value, print);\n  this.space();\n  print.plain(value.body);\n}\n\n/**\n * Prints FunctionExpression, prints id and body, handles async and generator.\n */\n\nfunction FunctionExpression(node, print) {\n  if (node.async) this.push(\"async \");\n  this.push(\"function\");\n  if (node.generator) this.push(\"*\");\n\n  if (node.id) {\n    this.push(\" \");\n    print.plain(node.id);\n  } else {\n    this.space();\n  }\n\n  this._params(node, print);\n  this.space();\n  print.plain(node.body);\n}\n\n/**\n * Alias FunctionExpression printer as FunctionDeclaration.\n */\n\nexports.FunctionDeclaration = FunctionExpression;\n\n/**\n * Prints ArrowFunctionExpression, prints params and body, handles async.\n * Leaves out parentheses when single param.\n */\n\nfunction ArrowFunctionExpression(node, print) {\n  if (node.async) this.push(\"async \");\n\n  if (node.params.length === 1 && t.isIdentifier(node.params[0])) {\n    print.plain(node.params[0]);\n  } else {\n    this._params(node, print);\n  }\n\n  this.push(\" => \");\n\n  var bodyNeedsParens = t.isObjectExpression(node.body);\n\n  if (bodyNeedsParens) {\n    this.push(\"(\");\n  }\n\n  print.plain(node.body);\n\n  if (bodyNeedsParens) {\n    this.push(\")\");\n  }\n}","\n\nexports.__esModule = true;\nexports.ImportSpecifier = ImportSpecifier;\nexports.ImportDefaultSpecifier = ImportDefaultSpecifier;\nexports.ExportDefaultSpecifier = ExportDefaultSpecifier;\nexports.ExportSpecifier = ExportSpecifier;\nexports.ExportNamespaceSpecifier = ExportNamespaceSpecifier;\nexports.ExportAllDeclaration = ExportAllDeclaration;\nexports.ExportNamedDeclaration = ExportNamedDeclaration;\nexports.ExportDefaultDeclaration = ExportDefaultDeclaration;\nexports.ImportDeclaration = ImportDeclaration;\nexports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * Prints ImportSpecifier, prints imported and local.\n */\n\nfunction ImportSpecifier(node, print) {\n  print.plain(node.imported);\n  if (node.local && node.local.name !== node.imported.name) {\n    this.push(\" as \");\n    print.plain(node.local);\n  }\n}\n\n/**\n * Prints ImportDefaultSpecifier, prints local.\n */\n\nfunction ImportDefaultSpecifier(node, print) {\n  print.plain(node.local);\n}\n\n/**\n * Prints ExportDefaultSpecifier, prints exported.\n */\n\nfunction ExportDefaultSpecifier(node, print) {\n  print.plain(node.exported);\n}\n\n/**\n * Prints ExportSpecifier, prints local and exported.\n */\n\nfunction ExportSpecifier(node, print) {\n  print.plain(node.local);\n  if (node.exported && node.local.name !== node.exported.name) {\n    this.push(\" as \");\n    print.plain(node.exported);\n  }\n}\n\n/**\n * Prints ExportNamespaceSpecifier, prints exported.\n */\n\nfunction ExportNamespaceSpecifier(node, print) {\n  this.push(\"* as \");\n  print.plain(node.exported);\n}\n\n/**\n * Prints ExportAllDeclaration, prints exported and source.\n */\n\nfunction ExportAllDeclaration(node, print) {\n  this.push(\"export *\");\n  if (node.exported) {\n    this.push(\" as \");\n    print.plain(node.exported);\n  }\n  this.push(\" from \");\n  print.plain(node.source);\n  this.semicolon();\n}\n\n/**\n * Prints ExportNamedDeclaration, delegates to ExportDeclaration.\n */\n\nfunction ExportNamedDeclaration(node, print) {\n  this.push(\"export \");\n  ExportDeclaration.call(this, node, print);\n}\n\n/**\n * Prints ExportDefaultDeclaration, delegates to ExportDeclaration.\n */\n\nfunction ExportDefaultDeclaration(node, print) {\n  this.push(\"export default \");\n  ExportDeclaration.call(this, node, print);\n}\n\n/**\n * Prints ExportDeclaration, prints specifiers, declration, and source.\n */\n\nfunction ExportDeclaration(node, print) {\n  var specifiers = node.specifiers;\n\n  if (node.declaration) {\n    var declar = node.declaration;\n    print.plain(declar);\n    if (t.isStatement(declar) || t.isFunction(declar) || t.isClass(declar)) return;\n  } else {\n    if (node.exportKind === \"type\") {\n      this.push(\"type \");\n    }\n\n    var first = specifiers[0];\n    var hasSpecial = false;\n    if (t.isExportDefaultSpecifier(first) || t.isExportNamespaceSpecifier(first)) {\n      hasSpecial = true;\n      print.plain(specifiers.shift());\n      if (specifiers.length) {\n        this.push(\", \");\n      }\n    }\n\n    if (specifiers.length || !specifiers.length && !hasSpecial) {\n      this.push(\"{\");\n      if (specifiers.length) {\n        this.space();\n        print.join(specifiers, { separator: \", \" });\n        this.space();\n      }\n      this.push(\"}\");\n    }\n\n    if (node.source) {\n      this.push(\" from \");\n      print.plain(node.source);\n    }\n  }\n\n  this.ensureSemicolon();\n}\n\n/**\n * Prints ImportDeclaration, prints specifiers and source, handles isType.\n */\n\nfunction ImportDeclaration(node, print) {\n  this.push(\"import \");\n\n  if (node.importKind === \"type\" || node.importKind === \"typeof\") {\n    this.push(node.importKind + \" \");\n  }\n\n  var specfiers = node.specifiers;\n  if (specfiers && specfiers.length) {\n    var first = node.specifiers[0];\n    if (t.isImportDefaultSpecifier(first) || t.isImportNamespaceSpecifier(first)) {\n      print.plain(node.specifiers.shift());\n      if (node.specifiers.length) {\n        this.push(\", \");\n      }\n    }\n\n    if (node.specifiers.length) {\n      this.push(\"{\");\n      this.space();\n      print.join(node.specifiers, { separator: \", \" });\n      this.space();\n      this.push(\"}\");\n    }\n\n    this.push(\" from \");\n  }\n\n  print.plain(node.source);\n  this.semicolon();\n}\n\n/**\n * Prints ImportNamespaceSpecifier, prints local.\n */\n\nfunction ImportNamespaceSpecifier(node, print) {\n  this.push(\"* as \");\n  print.plain(node.local);\n}","/* eslint quotes: 0 */\n\n\n\nexports.__esModule = true;\nexports.Identifier = Identifier;\nexports.RestElement = RestElement;\nexports.ObjectExpression = ObjectExpression;\nexports.Property = Property;\nexports.ArrayExpression = ArrayExpression;\nexports.Literal = Literal;\nexports._Literal = _Literal;\nexports._stringLiteral = _stringLiteral;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * Prints Identifier, prints name.\n */\n\nfunction Identifier(node) {\n  this.push(node.name);\n}\n\n/**\n * Prints RestElement, prints argument.\n */\n\nfunction RestElement(node, print) {\n  this.push(\"...\");\n  print.plain(node.argument);\n}\n\n/**\n * Alias RestElement printer as SpreadElement,\n * and RestElement printer as SpreadProperty.\n */\n\nexports.SpreadElement = RestElement;\nexports.SpreadProperty = RestElement;\n\n/**\n * Prints ObjectExpression, prints properties.\n */\n\nfunction ObjectExpression(node, print) {\n  var props = node.properties;\n\n  this.push(\"{\");\n  print.printInnerComments();\n\n  if (props.length) {\n    this.space();\n    print.list(props, { indent: true });\n    this.space();\n  }\n\n  this.push(\"}\");\n}\n\n/**\n * Alias ObjectExpression printer as ObjectPattern.\n */\n\nexports.ObjectPattern = ObjectExpression;\n\n/**\n * Prints Property, prints decorators, key, and value, handles kind, computed, and shorthand.\n */\n\nfunction Property(node, print) {\n  print.list(node.decorators, { separator: \"\" });\n\n  if (node.method || node.kind === \"get\" || node.kind === \"set\") {\n    this._method(node, print);\n  } else {\n    if (node.computed) {\n      this.push(\"[\");\n      print.plain(node.key);\n      this.push(\"]\");\n    } else {\n      // print `({ foo: foo = 5 } = {})` as `({ foo = 5 } = {});`\n      if (t.isAssignmentPattern(node.value) && t.isIdentifier(node.key) && node.key.name === node.value.left.name) {\n        print.plain(node.value);\n        return;\n      }\n\n      print.plain(node.key);\n\n      // shorthand!\n      if (node.shorthand && t.isIdentifier(node.key) && t.isIdentifier(node.value) && node.key.name === node.value.name) {\n        return;\n      }\n    }\n\n    this.push(\":\");\n    this.space();\n    print.plain(node.value);\n  }\n}\n\n/**\n * Prints ArrayExpression, prints elements.\n */\n\nfunction ArrayExpression(node, print) {\n  var elems = node.elements;\n  var len = elems.length;\n\n  this.push(\"[\");\n  print.printInnerComments();\n\n  for (var i = 0; i < elems.length; i++) {\n    var elem = elems[i];\n    if (elem) {\n      if (i > 0) this.space();\n      print.plain(elem);\n      if (i < len - 1) this.push(\",\");\n    } else {\n      // If the array expression ends with a hole, that hole\n      // will be ignored by the interpreter, but if it ends with\n      // two (or more) holes, we need to write out two (or more)\n      // commas so that the resulting code is interpreted with\n      // both (all) of the holes.\n      this.push(\",\");\n    }\n  }\n\n  this.push(\"]\");\n}\n\n/**\n * Alias ArrayExpression printer as ArrayPattern.\n */\n\nexports.ArrayPattern = ArrayExpression;\n\n/**\n * Prints Literal, prints value, regex, raw, handles val type.\n */\n\nfunction Literal(node) {\n  this.push(\"\"); // hack: catch up indentation\n  this._push(this._Literal(node));\n}\n\nfunction _Literal(node) {\n  var val = node.value;\n\n  if (node.regex) {\n    return \"/\" + node.regex.pattern + \"/\" + node.regex.flags;\n  }\n\n  // just use the raw property if our current value is equivalent to the one we got\n  // when we populated raw\n  if (node.raw != null && node.rawValue != null && val === node.rawValue) {\n    return node.raw;\n  }\n\n  switch (typeof val) {\n    case \"string\":\n      return this._stringLiteral(val);\n\n    case \"number\":\n      return val + \"\";\n\n    case \"boolean\":\n      return val ? \"true\" : \"false\";\n\n    default:\n      if (val === null) {\n        return \"null\";\n      } else {\n        throw new Error(\"Invalid Literal type\");\n      }\n  }\n}\n\n/**\n * Prints string literals, handles format.\n */\n\nfunction _stringLiteral(val) {\n  val = JSON.stringify(val);\n\n  // escape illegal js but valid json unicode characters\n  val = val.replace(/[\\u000A\\u000D\\u2028\\u2029]/g, function (c) {\n    return \"\\\\u\" + (\"0000\" + c.charCodeAt(0).toString(16)).slice(-4);\n  });\n\n  if (this.format.quotes === \"single\") {\n    // remove double quotes\n    val = val.slice(1, -1);\n\n    // unescape double quotes\n    val = val.replace(/\\\\\"/g, '\"');\n\n    // escape single quotes\n    val = val.replace(/'/g, \"\\\\'\");\n\n    // add single quotes\n    val = \"'\" + val + \"'\";\n  }\n\n  return val;\n}","\n\nexports.__esModule = true;\nexports.AnyTypeAnnotation = AnyTypeAnnotation;\nexports.ArrayTypeAnnotation = ArrayTypeAnnotation;\nexports.BooleanTypeAnnotation = BooleanTypeAnnotation;\nexports.BooleanLiteralTypeAnnotation = BooleanLiteralTypeAnnotation;\nexports.DeclareClass = DeclareClass;\nexports.DeclareFunction = DeclareFunction;\nexports.DeclareInterface = DeclareInterface;\nexports.DeclareModule = DeclareModule;\nexports.DeclareTypeAlias = DeclareTypeAlias;\nexports.DeclareVariable = DeclareVariable;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.FunctionTypeParam = FunctionTypeParam;\nexports.InterfaceExtends = InterfaceExtends;\nexports._interfaceish = _interfaceish;\nexports.InterfaceDeclaration = InterfaceDeclaration;\nexports.IntersectionTypeAnnotation = IntersectionTypeAnnotation;\nexports.MixedTypeAnnotation = MixedTypeAnnotation;\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nexports.NullLiteralTypeAnnotation = NullLiteralTypeAnnotation;\nexports.NumberTypeAnnotation = NumberTypeAnnotation;\nexports.StringLiteralTypeAnnotation = StringLiteralTypeAnnotation;\nexports.StringTypeAnnotation = StringTypeAnnotation;\nexports.ThisTypeAnnotation = ThisTypeAnnotation;\nexports.TupleTypeAnnotation = TupleTypeAnnotation;\nexports.TypeofTypeAnnotation = TypeofTypeAnnotation;\nexports.TypeAlias = TypeAlias;\nexports.TypeAnnotation = TypeAnnotation;\nexports.TypeParameterInstantiation = TypeParameterInstantiation;\nexports.ObjectTypeAnnotation = ObjectTypeAnnotation;\nexports.ObjectTypeCallProperty = ObjectTypeCallProperty;\nexports.ObjectTypeIndexer = ObjectTypeIndexer;\nexports.ObjectTypeProperty = ObjectTypeProperty;\nexports.QualifiedTypeIdentifier = QualifiedTypeIdentifier;\nexports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.TypeCastExpression = TypeCastExpression;\nexports.VoidTypeAnnotation = VoidTypeAnnotation;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * Prints AnyTypeAnnotation.\n */\n\nfunction AnyTypeAnnotation() {\n  this.push(\"any\");\n}\n\n/**\n * Prints ArrayTypeAnnotation, prints elementType.\n */\n\nfunction ArrayTypeAnnotation(node, print) {\n  print.plain(node.elementType);\n  this.push(\"[\");\n  this.push(\"]\");\n}\n\n/**\n * Prints BooleanTypeAnnotation.\n */\n\nfunction BooleanTypeAnnotation() {\n  this.push(\"bool\");\n}\n\n/**\n * Prints BooleanLiteralTypeAnnotation.\n */\n\nfunction BooleanLiteralTypeAnnotation(node) {\n  this.push(node.value ? \"true\" : \"false\");\n}\n\n/**\n * Prints DeclareClass, prints node.\n */\n\nfunction DeclareClass(node, print) {\n  this.push(\"declare class \");\n  this._interfaceish(node, print);\n}\n\n/**\n * Prints DeclareFunction, prints id and id.typeAnnotation.\n */\n\nfunction DeclareFunction(node, print) {\n  this.push(\"declare function \");\n  print.plain(node.id);\n  print.plain(node.id.typeAnnotation.typeAnnotation);\n  this.semicolon();\n}\n\n/**\n * Prints DeclareInterface.\n */\n\nfunction DeclareInterface(node, print) {\n  this.push(\"declare \");\n  this.InterfaceDeclaration(node, print);\n}\n\n/**\n * Prints DeclareModule, prints id and body.\n */\n\nfunction DeclareModule(node, print) {\n  this.push(\"declare module \");\n  print.plain(node.id);\n  this.space();\n  print.plain(node.body);\n}\n\n/**\n * Prints DeclareTypeAlias.\n */\n\nfunction DeclareTypeAlias(node, print) {\n  this.push(\"declare \");\n  this.TypeAlias(node, print);\n}\n\n/**\n * Prints DeclareVariable, prints id and id.typeAnnotation.\n */\n\nfunction DeclareVariable(node, print) {\n  this.push(\"declare var \");\n  print.plain(node.id);\n  print.plain(node.id.typeAnnotation);\n  this.semicolon();\n}\n\n/**\n * Prints FunctionTypeAnnotation, prints typeParameters, params, and rest.\n */\n\nfunction FunctionTypeAnnotation(node, print, parent) {\n  print.plain(node.typeParameters);\n  this.push(\"(\");\n  print.list(node.params);\n\n  if (node.rest) {\n    if (node.params.length) {\n      this.push(\",\");\n      this.space();\n    }\n    this.push(\"...\");\n    print.plain(node.rest);\n  }\n\n  this.push(\")\");\n\n  // this node type is overloaded, not sure why but it makes it EXTREMELY annoying\n  if (parent.type === \"ObjectTypeProperty\" || parent.type === \"ObjectTypeCallProperty\" || parent.type === \"DeclareFunction\") {\n    this.push(\":\");\n  } else {\n    this.space();\n    this.push(\"=>\");\n  }\n\n  this.space();\n  print.plain(node.returnType);\n}\n\n/**\n * Prints FunctionTypeParam, prints name and typeAnnotation, handles optional.\n */\n\nfunction FunctionTypeParam(node, print) {\n  print.plain(node.name);\n  if (node.optional) this.push(\"?\");\n  this.push(\":\");\n  this.space();\n  print.plain(node.typeAnnotation);\n}\n\n/**\n * Prints InterfaceExtends, prints id and typeParameters.\n */\n\nfunction InterfaceExtends(node, print) {\n  print.plain(node.id);\n  print.plain(node.typeParameters);\n}\n\n/**\n * Alias InterfaceExtends printer as ClassImplements,\n * and InterfaceExtends printer as GenericTypeAnnotation.\n */\n\nexports.ClassImplements = InterfaceExtends;\nexports.GenericTypeAnnotation = InterfaceExtends;\n\n/**\n * Prints interface-like node, prints id, typeParameters, extends, and body.\n */\n\nfunction _interfaceish(node, print) {\n  print.plain(node.id);\n  print.plain(node.typeParameters);\n  if (node[\"extends\"].length) {\n    this.push(\" extends \");\n    print.join(node[\"extends\"], { separator: \", \" });\n  }\n  if (node.mixins && node.mixins.length) {\n    this.push(\" mixins \");\n    print.join(node.mixins, { separator: \", \" });\n  }\n  this.space();\n  print.plain(node.body);\n}\n\n/**\n * Prints InterfaceDeclaration, prints node.\n */\n\nfunction InterfaceDeclaration(node, print) {\n  this.push(\"interface \");\n  this._interfaceish(node, print);\n}\n\n/**\n * Prints IntersectionTypeAnnotation, prints types.\n */\n\nfunction IntersectionTypeAnnotation(node, print) {\n  print.join(node.types, { separator: \" & \" });\n}\n\n/**\n * Prints MixedTypeAnnotation.\n */\n\nfunction MixedTypeAnnotation() {\n  this.push(\"mixed\");\n}\n\n/**\n * Prints NullableTypeAnnotation, prints typeAnnotation.\n */\n\nfunction NullableTypeAnnotation(node, print) {\n  this.push(\"?\");\n  print.plain(node.typeAnnotation);\n}\n\n/**\n * Prints NullLiteralTypeAnnotation, prints value.\n */\n\nfunction NullLiteralTypeAnnotation() {\n  this.push(\"null\");\n}\n\n/**\n * Prints NumberLiteralTypeAnnotation, prints value.\n */\n\nvar _types2 = require(\"./types\");\n\nexports.NumberLiteralTypeAnnotation = _types2.Literal;\n\n/**\n * Prints NumberTypeAnnotation.\n */\n\nfunction NumberTypeAnnotation() {\n  this.push(\"number\");\n}\n\n/**\n * Prints StringLiteralTypeAnnotation, prints value.\n */\n\nfunction StringLiteralTypeAnnotation(node) {\n  this.push(this._stringLiteral(node.value));\n}\n\n/**\n * Prints StringTypeAnnotation.\n */\n\nfunction StringTypeAnnotation() {\n  this.push(\"string\");\n}\n\n/**\n * Prints ThisTypeAnnotation, prints this.\n */\n\nfunction ThisTypeAnnotation() {\n  this.push(\"this\");\n}\n\n/**\n * Prints TupleTypeAnnotation, prints types.\n */\n\nfunction TupleTypeAnnotation(node, print) {\n  this.push(\"[\");\n  print.join(node.types, { separator: \", \" });\n  this.push(\"]\");\n}\n\n/**\n * Prints TypeofTypeAnnotation, prints argument.\n */\n\nfunction TypeofTypeAnnotation(node, print) {\n  this.push(\"typeof \");\n  print.plain(node.argument);\n}\n\n/**\n * Prints TypeAlias, prints id, typeParameters, and right.\n */\n\nfunction TypeAlias(node, print) {\n  this.push(\"type \");\n  print.plain(node.id);\n  print.plain(node.typeParameters);\n  this.space();\n  this.push(\"=\");\n  this.space();\n  print.plain(node.right);\n  this.semicolon();\n}\n\n/**\n * Prints TypeAnnotation, prints typeAnnotation, handles optional.\n */\n\nfunction TypeAnnotation(node, print) {\n  this.push(\":\");\n  this.space();\n  if (node.optional) this.push(\"?\");\n  print.plain(node.typeAnnotation);\n}\n\n/**\n * Prints TypeParameterInstantiation, prints params.\n */\n\nfunction TypeParameterInstantiation(node, print) {\n  this.push(\"<\");\n  print.join(node.params, {\n    separator: \", \",\n    iterator: function iterator(node) {\n      print.plain(node.typeAnnotation);\n    }\n  });\n  this.push(\">\");\n}\n\n/**\n * Alias TypeParameterInstantiation printer as TypeParameterDeclaration\n */\n\nexports.TypeParameterDeclaration = TypeParameterInstantiation;\n\n/**\n * Prints ObjectTypeAnnotation, prints properties, callProperties, and indexers.\n */\n\nfunction ObjectTypeAnnotation(node, print) {\n  // istanbul ignore next\n\n  var _this = this;\n\n  this.push(\"{\");\n  var props = node.properties.concat(node.callProperties, node.indexers);\n\n  if (props.length) {\n    this.space();\n\n    print.list(props, {\n      separator: false,\n      indent: true,\n      iterator: function iterator() {\n        if (props.length !== 1) {\n          _this.semicolon();\n          _this.space();\n        }\n      }\n    });\n\n    this.space();\n  }\n\n  this.push(\"}\");\n}\n\n/**\n * Prints ObjectTypeCallProperty, prints value, handles static.\n */\n\nfunction ObjectTypeCallProperty(node, print) {\n  if (node[\"static\"]) this.push(\"static \");\n  print.plain(node.value);\n}\n\n/**\n * Prints ObjectTypeIndexer, prints id, key, and value, handles static.\n */\n\nfunction ObjectTypeIndexer(node, print) {\n  if (node[\"static\"]) this.push(\"static \");\n  this.push(\"[\");\n  print.plain(node.id);\n  this.push(\":\");\n  this.space();\n  print.plain(node.key);\n  this.push(\"]\");\n  this.push(\":\");\n  this.space();\n  print.plain(node.value);\n}\n\n/**\n * Prints ObjectTypeProperty, prints static, key, and value.\n */\n\nfunction ObjectTypeProperty(node, print) {\n  if (node[\"static\"]) this.push(\"static \");\n  print.plain(node.key);\n  if (node.optional) this.push(\"?\");\n  if (!t.isFunctionTypeAnnotation(node.value)) {\n    this.push(\":\");\n    this.space();\n  }\n  print.plain(node.value);\n}\n\n/**\n * Prints QualifiedTypeIdentifier, prints qualification and id.\n */\n\nfunction QualifiedTypeIdentifier(node, print) {\n  print.plain(node.qualification);\n  this.push(\".\");\n  print.plain(node.id);\n}\n\n/**\n * Prints UnionTypeAnnotation, prints types.\n */\n\nfunction UnionTypeAnnotation(node, print) {\n  print.join(node.types, { separator: \" | \" });\n}\n\n/**\n * Prints TypeCastExpression, prints expression and typeAnnotation.\n */\n\nfunction TypeCastExpression(node, print) {\n  this.push(\"(\");\n  print.plain(node.expression);\n  print.plain(node.typeAnnotation);\n  this.push(\")\");\n}\n\n/**\n * Prints VoidTypeAnnotation.\n */\n\nfunction VoidTypeAnnotation() {\n  this.push(\"void\");\n}","/**\n * Print File.program\n */\n\n\n\nexports.__esModule = true;\nexports.File = File;\nexports.Program = Program;\nexports.BlockStatement = BlockStatement;\nexports.Noop = Noop;\n\nfunction File(node, print) {\n  print.plain(node.program);\n}\n\n/**\n * Print all nodes in a Program.body.\n */\n\nfunction Program(node, print) {\n  print.sequence(node.body);\n}\n\n/**\n * Print BlockStatement, collapses empty blocks, prints body.\n */\n\nfunction BlockStatement(node, print) {\n  this.push(\"{\");\n  if (node.body.length) {\n    this.newline();\n    print.sequence(node.body, { indent: true });\n    if (!this.format.retainLines) this.removeLast(\"\\n\");\n    this.rightBrace();\n  } else {\n    print.printInnerComments();\n    this.push(\"}\");\n  }\n}\n\n/**\n * What is my purpose?\n * Why am I here?\n * Why are any of us here?\n * Does any of this really matter?\n */\n\nfunction Noop() {}","\n\nexports.__esModule = true;\nexports.JSXAttribute = JSXAttribute;\nexports.JSXIdentifier = JSXIdentifier;\nexports.JSXNamespacedName = JSXNamespacedName;\nexports.JSXMemberExpression = JSXMemberExpression;\nexports.JSXSpreadAttribute = JSXSpreadAttribute;\nexports.JSXExpressionContainer = JSXExpressionContainer;\nexports.JSXElement = JSXElement;\nexports.JSXOpeningElement = JSXOpeningElement;\nexports.JSXClosingElement = JSXClosingElement;\nexports.JSXEmptyExpression = JSXEmptyExpression;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * Prints JSXAttribute, prints name and value.\n */\n\nfunction JSXAttribute(node, print) {\n  print.plain(node.name);\n  if (node.value) {\n    this.push(\"=\");\n    print.plain(node.value);\n  }\n}\n\n/**\n * Prints JSXIdentifier, prints name.\n */\n\nfunction JSXIdentifier(node) {\n  this.push(node.name);\n}\n\n/**\n * Prints JSXNamespacedName, prints namespace and name.\n */\n\nfunction JSXNamespacedName(node, print) {\n  print.plain(node.namespace);\n  this.push(\":\");\n  print.plain(node.name);\n}\n\n/**\n * Prints JSXMemberExpression, prints object and property.\n */\n\nfunction JSXMemberExpression(node, print) {\n  print.plain(node.object);\n  this.push(\".\");\n  print.plain(node.property);\n}\n\n/**\n * Prints JSXSpreadAttribute, prints argument.\n */\n\nfunction JSXSpreadAttribute(node, print) {\n  this.push(\"{...\");\n  print.plain(node.argument);\n  this.push(\"}\");\n}\n\n/**\n * Prints JSXExpressionContainer, prints expression.\n */\n\nfunction JSXExpressionContainer(node, print) {\n  this.push(\"{\");\n  print.plain(node.expression);\n  this.push(\"}\");\n}\n\n/**\n * Prints JSXElement, prints openingElement, children, and closingElement.\n */\n\nfunction JSXElement(node, print) {\n  var open = node.openingElement;\n  print.plain(open);\n  if (open.selfClosing) return;\n\n  this.indent();\n  var _arr = node.children;\n  for (var _i = 0; _i < _arr.length; _i++) {\n    var child = _arr[_i];\n    if (t.isLiteral(child)) {\n      this.push(child.value, true);\n    } else {\n      print.plain(child);\n    }\n  }\n  this.dedent();\n\n  print.plain(node.closingElement);\n}\n\n/**\n * Prints JSXOpeningElement, prints name and attributes, handles selfClosing.\n */\n\nfunction JSXOpeningElement(node, print) {\n  this.push(\"<\");\n  print.plain(node.name);\n  if (node.attributes.length > 0) {\n    this.push(\" \");\n    print.join(node.attributes, { separator: \" \" });\n  }\n  this.push(node.selfClosing ? \" />\" : \">\");\n}\n\n/**\n * Prints JSXClosingElement, prints name.\n */\n\nfunction JSXClosingElement(node, print) {\n  this.push(\"</\");\n  print.plain(node.name);\n  this.push(\">\");\n}\n\n/**\n * Prints JSXEmptyExpression.\n */\n\nfunction JSXEmptyExpression() {}","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// istanbul ignore next\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _debugNode = require(\"debug/node\");\n\nvar _debugNode2 = _interopRequireDefault(_debugNode);\n\nvar verboseDebug = _debugNode2[\"default\"](\"babel:verbose\");\nvar generalDebug = _debugNode2[\"default\"](\"babel\");\n\nvar seenDeprecatedMessages = [];\n\n/**\n * [Please add a description.]\n */\n\nvar Logger = (function () {\n  function Logger(file, filename) {\n    _classCallCheck(this, Logger);\n\n    this.filename = filename;\n    this.file = file;\n  }\n\n  /**\n   * [Please add a description.]\n   */\n\n  Logger.prototype._buildMessage = function _buildMessage(msg) {\n    var parts = \"[BABEL] \" + this.filename;\n    if (msg) parts += \": \" + msg;\n    return parts;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Logger.prototype.warn = function warn(msg) {\n    console.warn(this._buildMessage(msg));\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Logger.prototype.error = function error(msg) {\n    var Constructor = arguments.length <= 1 || arguments[1] === undefined ? Error : arguments[1];\n\n    throw new Constructor(this._buildMessage(msg));\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Logger.prototype.deprecate = function deprecate(msg) {\n    if (this.file.opts && this.file.opts.suppressDeprecationMessages) return;\n\n    msg = this._buildMessage(msg);\n\n    // already seen this message\n    if (seenDeprecatedMessages.indexOf(msg) >= 0) return;\n\n    // make sure we don't see it again\n    seenDeprecatedMessages.push(msg);\n\n    console.error(msg);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Logger.prototype.verbose = function verbose(msg) {\n    if (verboseDebug.enabled) verboseDebug(this._buildMessage(msg));\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Logger.prototype.debug = function debug(msg) {\n    if (generalDebug.enabled) generalDebug(this._buildMessage(msg));\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  Logger.prototype.deopt = function deopt(node, msg) {\n    this.debug(msg);\n  };\n\n  return Logger;\n})();\n\nexports[\"default\"] = Logger;\nmodule.exports = exports[\"default\"];","/**\n * [Please add a description.]\n */\n\n\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Hub = function Hub(file) {\n  _classCallCheck(this, Hub);\n\n  this.file = file;\n};\n\nexports[\"default\"] = Hub;\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * Normalize an AST.\n *\n * - Wrap `Program` node with a `File` node.\n */\n\nexports[\"default\"] = function (ast, comments, tokens) {\n  if (ast && ast.type === \"Program\") {\n    return t.file(ast, comments || [], tokens || []);\n  } else {\n    throw new Error(\"Not a valid ast?\");\n  }\n};\n\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\nexports[\"default\"] = {\n  //- builtin-prepass\n  \"minification.constantFolding\": require(\"babel-plugin-constant-folding\"),\n\n  //- builtin-pre\n  strict: require(\"./other/strict\"),\n  eval: require(\"babel-plugin-eval\"),\n  _validation: require(\"./internal/validation\"),\n  _hoistDirectives: require(\"./internal/hoist-directives\"),\n  \"minification.removeDebugger\": require(\"babel-plugin-remove-debugger\"),\n  \"minification.removeConsole\": require(\"babel-plugin-remove-console\"),\n  \"utility.inlineEnvironmentVariables\": require(\"babel-plugin-inline-environment-variables\"),\n  \"minification.deadCodeElimination\": require(\"babel-plugin-dead-code-elimination\"),\n  _modules: require(\"./internal/modules\"),\n  \"react.displayName\": require(\"babel-plugin-react-display-name\"),\n  \"es6.spec.modules\": require(\"./es6/spec.modules\"),\n  \"es6.spec.arrowFunctions\": require(\"./es6/spec.arrow-functions\"),\n  \"es6.spec.templateLiterals\": require(\"./es6/spec.template-literals\"),\n  \"es6.templateLiterals\": require(\"./es6/template-literals\"),\n  \"es6.literals\": require(\"./es6/literals\"),\n  \"validation.undeclaredVariableCheck\": require(\"babel-plugin-undeclared-variables-check\"),\n\n  //- builtin-basic\n  // this is where the bulk of the ES6 transformations take place, none of them require traversal state\n  // so they can all be concatenated together for performance\n  \"spec.functionName\": require(\"./spec/function-name\"),\n  \"es7.classProperties\": require(\"./es7/class-properties\"),\n  \"es7.trailingFunctionCommas\": require(\"./es7/trailing-function-commas\"),\n  \"es7.asyncFunctions\": require(\"./es7/async-functions\"),\n  \"es7.decorators\": require(\"./es7/decorators\"),\n  \"validation.react\": require(\"./validation/react\"),\n  \"es6.arrowFunctions\": require(\"./es6/arrow-functions\"),\n  \"spec.blockScopedFunctions\": require(\"./spec/block-scoped-functions\"),\n  \"optimisation.react.constantElements\": require(\"babel-plugin-react-constant-elements\"),\n  \"optimisation.react.inlineElements\": require(\"./optimisation/react.inline-elements\"),\n  \"es7.comprehensions\": require(\"./es7/comprehensions\"),\n  \"es6.classes\": require(\"./es6/classes\"),\n  asyncToGenerator: require(\"./other/async-to-generator\"),\n  bluebirdCoroutines: require(\"./other/bluebird-coroutines\"),\n  \"es6.objectSuper\": require(\"./es6/object-super\"),\n  \"es7.objectRestSpread\": require(\"./es7/object-rest-spread\"),\n  \"es7.exponentiationOperator\": require(\"./es7/exponentiation-operator\"),\n  \"es5.properties.mutators\": require(\"./es5/properties.mutators\"),\n  \"es6.properties.shorthand\": require(\"./es6/properties.shorthand\"),\n  \"es6.properties.computed\": require(\"./es6/properties.computed\"),\n  \"optimisation.flow.forOf\": require(\"./optimisation/flow.for-of\"),\n  \"es6.forOf\": require(\"./es6/for-of\"),\n  \"es6.regex.sticky\": require(\"./es6/regex.sticky\"),\n  \"es6.regex.unicode\": require(\"./es6/regex.unicode\"),\n  \"es6.constants\": require(\"./es6/constants\"),\n  \"es7.exportExtensions\": require(\"./es7/export-extensions\"),\n  \"spec.protoToAssign\": require(\"babel-plugin-proto-to-assign\"),\n  \"es7.doExpressions\": require(\"./es7/do-expressions\"),\n  \"es6.spec.symbols\": require(\"./es6/spec.symbols\"),\n  \"es7.functionBind\": require(\"./es7/function-bind\"),\n  \"spec.undefinedToVoid\": require(\"babel-plugin-undefined-to-void\"),\n\n  //- builtin-advanced\n  \"es6.spread\": require(\"./es6/spread\"),\n  \"es6.parameters\": require(\"./es6/parameters\"),\n  \"es6.destructuring\": require(\"./es6/destructuring\"),\n  \"es6.blockScoping\": require(\"./es6/block-scoping\"),\n  \"es6.spec.blockScoping\": require(\"./es6/spec.block-scoping\"),\n  reactCompat: require(\"./other/react-compat\"),\n  react: require(\"./other/react\"),\n  regenerator: require(\"./other/regenerator\"),\n\n  // es6 syntax transformation is **forbidden** past this point since regenerator will chuck a massive\n  // hissy fit\n\n  //- builtin-modules\n  runtime: require(\"babel-plugin-runtime\"),\n  \"es6.modules\": require(\"./es6/modules\"),\n  _moduleFormatter: require(\"./internal/module-formatter\"),\n\n  //- builtin-trailing\n  // these clean up the output and do finishing up transformations, it's important to note that by this\n  // stage you can't import any new modules or insert new ES6 as all those transformers have already\n  // been ran\n  \"es6.tailCall\": require(\"./es6/tail-call\"),\n  _shadowFunctions: require(\"./internal/shadow-functions\"),\n  \"es3.propertyLiterals\": require(\"./es3/property-literals\"),\n  \"es3.memberExpressionLiterals\": require(\"./es3/member-expression-literals\"),\n  \"minification.memberExpressionLiterals\": require(\"babel-plugin-member-expression-literals\"),\n  \"minification.propertyLiterals\": require(\"babel-plugin-property-literals\"),\n  _blockHoist: require(\"./internal/block-hoist\"),\n  jscript: require(\"babel-plugin-jscript\"),\n  flow: require(\"./other/flow\"),\n  \"optimisation.modules.system\": require(\"./optimisation/modules.system\")\n};\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\nvar metadata = {\n  group: \"builtin-pre\"\n};\n\nexports.metadata = metadata;\nvar THIS_BREAK_KEYS = [\"FunctionExpression\", \"FunctionDeclaration\", \"ClassProperty\"];\n\nfunction isUseStrict(node) {\n  if (!t.isLiteral(node)) return false;\n\n  if (node.raw && node.rawValue === node.value) {\n    return node.rawValue === \"use strict\";\n  } else {\n    return node.value === \"use strict\";\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  Program: {\n    enter: function enter(program) {\n      var first = program.body[0];\n\n      var directive;\n      if (t.isExpressionStatement(first) && isUseStrict(first.expression)) {\n        directive = first;\n      } else {\n        directive = t.expressionStatement(t.literal(\"use strict\"));\n        this.unshiftContainer(\"body\", directive);\n        if (first) {\n          directive.leadingComments = first.leadingComments;\n          first.leadingComments = [];\n        }\n      }\n      directive._blockHoist = Infinity;\n    }\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  ThisExpression: function ThisExpression() {\n    if (!this.findParent(function (path) {\n      return !path.is(\"shadow\") && THIS_BREAK_KEYS.indexOf(path.type) >= 0;\n    })) {\n      return t.identifier(\"undefined\");\n    }\n  }\n};\nexports.visitor = visitor;","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _messages = require(\"../../../messages\");\n\nvar messages = _interopRequireWildcard(_messages);\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\nvar metadata = {\n  group: \"builtin-pre\"\n};\n\nexports.metadata = metadata;\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  ForXStatement: function ForXStatement(node, parent, scope, file) {\n    var left = node.left;\n    if (t.isVariableDeclaration(left)) {\n      var declar = left.declarations[0];\n      if (declar.init) throw file.errorWithNode(declar, messages.get(\"noAssignmentsInForHead\"));\n    }\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  Property: function Property(node, parent, scope, file) {\n    if (node.kind === \"set\") {\n      var first = node.value.params[0];\n      if (t.isRestElement(first)) {\n        throw file.errorWithNode(first, messages.get(\"settersNoRest\"));\n      }\n    }\n  }\n};\nexports.visitor = visitor;","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\nvar metadata = {\n  group: \"builtin-pre\"\n};\n\nexports.metadata = metadata;\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  Block: {\n    exit: function exit(node) {\n      for (var i = 0; i < node.body.length; i++) {\n        var bodyNode = node.body[i];\n        if (t.isExpressionStatement(bodyNode) && t.isLiteral(bodyNode.expression)) {\n          bodyNode._blockHoist = Infinity;\n        } else {\n          return;\n        }\n      }\n    }\n  }\n};\nexports.visitor = visitor;","// in this transformer we have to split up classes and function declarations\n// from their exports. why? because sometimes we need to replace classes with\n// nodes that aren't allowed in the same contexts. also, if you're exporting\n// a generator function as a default then regenerator will destroy the export\n// declaration and leave a variable declaration in it's place... yeah, handy.\n\n\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nfunction getDeclar(node) {\n  var declar = node.declaration;\n  t.inheritsComments(declar, node);\n  t.removeComments(node);\n  declar._ignoreUserWhitespace = true;\n  return declar;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction buildExportSpecifier(id) {\n  return t.exportSpecifier(cloneIdentifier(id), cloneIdentifier(id));\n}\n\nfunction cloneIdentifier(_ref) {\n  var name = _ref.name;\n  var loc = _ref.loc;\n\n  var id = t.identifier(name);\n  id._loc = loc;\n  return id;\n}\n\nvar metadata = {\n  group: \"builtin-pre\"\n};\n\nexports.metadata = metadata;\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  ExportDefaultDeclaration: function ExportDefaultDeclaration(node, parent, scope) {\n    var declar = node.declaration;\n\n    if (t.isClassDeclaration(declar)) {\n      // export default class Foo {};\n      var nodes = [getDeclar(node), node];\n      node.declaration = declar.id;\n      return nodes;\n    } else if (t.isClassExpression(declar)) {\n      // export default class {};\n      var temp = scope.generateUidIdentifier(\"default\");\n      node.declaration = t.variableDeclaration(\"var\", [t.variableDeclarator(temp, declar)]);\n\n      var nodes = [getDeclar(node), node];\n      node.declaration = temp;\n      return nodes;\n    } else if (t.isFunctionDeclaration(declar)) {\n      // export default function Foo() {}\n      node._blockHoist = 2;\n\n      var nodes = [getDeclar(node), node];\n      node.declaration = declar.id;\n      return nodes;\n    }\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  ExportNamedDeclaration: function ExportNamedDeclaration(node) {\n    var declar = node.declaration;\n\n    if (t.isClassDeclaration(declar)) {\n      // export class Foo {}\n      node.specifiers = [buildExportSpecifier(declar.id)];\n\n      var nodes = [getDeclar(node), node];\n      node.declaration = null;\n      return nodes;\n    } else if (t.isFunctionDeclaration(declar)) {\n      // export function Foo() {}\n      var newExport = t.exportNamedDeclaration(null, [buildExportSpecifier(declar.id)]);\n      newExport._blockHoist = 2;\n      return [getDeclar(node), newExport];\n    } else if (t.isVariableDeclaration(declar)) {\n      // export var foo = \"bar\";\n      var specifiers = [];\n      var bindings = this.get(\"declaration\").getBindingIdentifiers();\n      for (var key in bindings) {\n        specifiers.push(buildExportSpecifier(bindings[key]));\n      }\n      return [declar, t.exportNamedDeclaration(null, specifiers)];\n    }\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  Program: {\n    enter: function enter(node) {\n      var imports = [];\n      var rest = [];\n\n      for (var i = 0; i < node.body.length; i++) {\n        var bodyNode = node.body[i];\n        if (t.isImportDeclaration(bodyNode)) {\n          imports.push(bodyNode);\n        } else {\n          rest.push(bodyNode);\n        }\n      }\n\n      node.body = imports.concat(rest);\n    },\n\n    exit: function exit(node, parent, scope, file) {\n      if (!file.transformers[\"es6.modules\"].canTransform()) return;\n\n      if (file.moduleFormatter.setup) {\n        file.moduleFormatter.setup();\n      }\n    }\n  }\n};\nexports.visitor = visitor;","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\nvar metadata = {\n  group: \"builtin-pre\",\n  optional: true\n};\n\nexports.metadata = metadata;\nvar visitor = {\n  Program: function Program() {\n    var id = this.scope.generateUidIdentifier(\"null\");\n    this.unshiftContainer(\"body\", [t.variableDeclaration(\"var\", [t.variableDeclarator(id, t.literal(null))]), t.exportNamedDeclaration(null, [t.exportSpecifier(id, t.identifier(\"__proto__\"))])]);\n  }\n};\nexports.visitor = visitor;","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\nvar metadata = {\n  group: \"builtin-pre\",\n  optional: true\n};\n\nexports.metadata = metadata;\nvar visitor = {\n  ArrowFunctionExpression: function ArrowFunctionExpression(node, parent, scope, file) {\n    if (node.shadow) return;\n    node.shadow = { \"this\": false };\n\n    var boundThis = t.thisExpression();\n    boundThis._forceShadow = this;\n\n    // make sure that arrow function won't be instantiated\n    t.ensureBlock(node);\n    this.get(\"body\").unshiftContainer(\"body\", t.expressionStatement(t.callExpression(file.addHelper(\"new-arrow-check\"), [t.thisExpression(), boundThis])));\n\n    return t.callExpression(t.memberExpression(node, t.identifier(\"bind\")), [t.thisExpression()]);\n  }\n};\nexports.visitor = visitor;","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\nvar metadata = {\n  optional: true,\n  group: \"builtin-pre\"\n};\n\nexports.metadata = metadata;\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  TemplateLiteral: function TemplateLiteral(node, parent) {\n    if (t.isTaggedTemplateExpression(parent)) return;\n\n    for (var i = 0; i < node.expressions.length; i++) {\n      node.expressions[i] = t.callExpression(t.identifier(\"String\"), [node.expressions[i]]);\n    }\n  }\n};\nexports.visitor = visitor;","/* eslint no-unused-vars: 0 */\n\n\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\nvar metadata = {\n  group: \"builtin-pre\"\n};\n\nexports.metadata = metadata;\n/**\n * [Please add a description.]\n */\n\nfunction isString(node) {\n  return t.isLiteral(node) && typeof node.value === \"string\";\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction buildBinaryExpression(left, right) {\n  var node = t.binaryExpression(\"+\", left, right);\n  node._templateLiteralProduced = true;\n  return node;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction crawl(path) {\n  if (path.is(\"_templateLiteralProduced\")) {\n    crawl(path.get(\"left\"));\n    crawl(path.get(\"right\"));\n  } else if (!path.isBaseType(\"string\") && !path.isBaseType(\"number\")) {\n    path.replaceWith(t.callExpression(t.identifier(\"String\"), [path.node]));\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  TaggedTemplateExpression: function TaggedTemplateExpression(node, parent, scope, file) {\n    var quasi = node.quasi;\n    var args = [];\n\n    var strings = [];\n    var raw = [];\n\n    var _arr = quasi.quasis;\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var elem = _arr[_i];\n      strings.push(t.literal(elem.value.cooked));\n      raw.push(t.literal(elem.value.raw));\n    }\n\n    strings = t.arrayExpression(strings);\n    raw = t.arrayExpression(raw);\n\n    var templateName = \"tagged-template-literal\";\n    if (file.isLoose(\"es6.templateLiterals\")) templateName += \"-loose\";\n\n    var templateObject = file.addTemplateObject(templateName, strings, raw);\n    args.push(templateObject);\n\n    args = args.concat(quasi.expressions);\n\n    return t.callExpression(node.tag, args);\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  TemplateLiteral: function TemplateLiteral(node, parent, scope, file) {\n    var nodes = [];\n\n    var _arr2 = node.quasis;\n    for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n      var elem = _arr2[_i2];\n      nodes.push(t.literal(elem.value.cooked));\n\n      var expr = node.expressions.shift();\n      if (expr) nodes.push(expr);\n    }\n\n    // filter out empty string literals\n    nodes = nodes.filter(function (n) {\n      return !t.isLiteral(n, { value: \"\" });\n    });\n\n    // since `+` is left-to-right associative\n    // ensure the first node is a string if first/second isn't\n    if (!isString(nodes[0]) && !isString(nodes[1])) {\n      nodes.unshift(t.literal(\"\"));\n    }\n\n    if (nodes.length > 1) {\n      var root = buildBinaryExpression(nodes.shift(), nodes.shift());\n\n      var _arr3 = nodes;\n      for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n        var _node = _arr3[_i3];\n        root = buildBinaryExpression(root, _node);\n      }\n\n      this.replaceWith(root);\n      //crawl(this);\n    } else {\n        return nodes[0];\n      }\n  }\n};\nexports.visitor = visitor;","\n\nexports.__esModule = true;\nvar metadata = {\n  group: \"builtin-pre\"\n};\n\nexports.metadata = metadata;\nvar visitor = {\n  Literal: function Literal(node) {\n    // number octal like 0b10 or 0o70\n    if (typeof node.value === \"number\" && /^0[ob]/i.test(node.raw)) {\n      node.raw = undefined;\n    }\n\n    // unicode escape\n    if (typeof node.value === \"string\" && /\\\\[u]/gi.test(node.raw)) {\n      node.raw = undefined;\n    }\n  }\n};\nexports.visitor = visitor;","\n\nexports.__esModule = true;\n\nvar _helpersNameMethod = require(\"../../helpers/name-method\");\n\nvar metadata = {\n  group: \"builtin-basic\"\n};\n\nexports.metadata = metadata;\n// visit Property functions first - https://github.com/babel/babel/issues/1860\n\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  \"ArrowFunctionExpression|FunctionExpression\": {\n    exit: function exit() {\n      if (!this.parentPath.isProperty()) {\n        return _helpersNameMethod.bare.apply(this, arguments);\n      }\n    }\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  ObjectExpression: function ObjectExpression() {\n    var props = this.get(\"properties\");\n    var _arr = props;\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var prop = _arr[_i];\n      var value = prop.get(\"value\");\n      if (value.isFunction()) {\n        var newNode = _helpersNameMethod.bare(value.node, prop.node, value.scope);\n        if (newNode) value.replaceWith(newNode);\n      }\n    }\n  }\n};\nexports.visitor = visitor;","\n\nexports.__esModule = true;\nexports.custom = custom;\nexports.property = property;\nexports.bare = bare;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _getFunctionArity = require(\"./get-function-arity\");\n\nvar _getFunctionArity2 = _interopRequireDefault(_getFunctionArity);\n\nvar _util = require(\"../../util\");\n\nvar util = _interopRequireWildcard(_util);\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nfunction visitIdentifier(context, node, scope, state) {\n  // check if this node matches our function id\n  if (node.name !== state.name) return;\n\n  // check that we don't have a local variable declared as that removes the need\n  // for the wrapper\n  var localDeclar = scope.getBindingIdentifier(state.name);\n  if (localDeclar !== state.outerDeclar) return;\n\n  state.selfReference = true;\n  context.stop();\n}\n\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope, state) {\n    visitIdentifier(this, node, scope, state);\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  BindingIdentifier: function BindingIdentifier(node, parent, scope, state) {\n    visitIdentifier(this, node, scope, state);\n  }\n};\n\n/**\n * [Please add a description.]\n */\n\nvar wrap = function wrap(state, method, id, scope) {\n  if (state.selfReference) {\n    if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {\n      // we can just munge the local binding\n      scope.rename(id.name);\n    } else {\n      // need to add a wrapper since we can't change the references\n      var templateName = \"property-method-assignment-wrapper\";\n      if (method.generator) templateName += \"-generator\";\n      var template = util.template(templateName, {\n        FUNCTION: method,\n        FUNCTION_ID: id,\n        FUNCTION_KEY: scope.generateUidIdentifier(id.name)\n      });\n      template.callee._skipModulesRemap = true;\n\n      // shim in dummy params to retain function arity, if you try to read the\n      // source then you'll get the original since it's proxied so it's all good\n      var params = template.callee.body.body[0].params;\n      for (var i = 0, len = _getFunctionArity2[\"default\"](method); i < len; i++) {\n        params.push(scope.generateUidIdentifier(\"x\"));\n      }\n\n      return template;\n    }\n  }\n\n  method.id = id;\n  scope.getProgramParent().references[id.name] = true;\n};\n\n/**\n * [Please add a description.]\n */\n\nvar visit = function visit(node, name, scope) {\n  var state = {\n    selfAssignment: false,\n    selfReference: false,\n    outerDeclar: scope.getBindingIdentifier(name),\n    references: [],\n    name: name\n  };\n\n  // check to see if we have a local binding of the id we're setting inside of\n  // the function, this is important as there are caveats associated\n\n  var binding = scope.getOwnBinding(name);\n\n  if (binding) {\n    if (binding.kind === \"param\") {\n      // safari will blow up in strict mode with code like:\n      //\n      //   var t = function t(t) {};\n      //\n      // with the error:\n      //\n      //   Cannot declare a parameter named 't' as it shadows the name of a\n      //   strict mode function.\n      //\n      // this isn't to the spec and they've invented this behaviour which is\n      // **extremely** annoying so we avoid setting the name if it has a param\n      // with the same id\n      state.selfReference = true;\n    } else {\n      // otherwise it's defined somewhere in scope like:\n      //\n      //   var t = function () {\n      //     var t = 2;\n      //   };\n      //\n      // so we can safely just set the id and move along as it shadows the\n      // bound function id\n    }\n  } else if (state.outerDeclar || scope.hasGlobal(name)) {\n      scope.traverse(node, visitor, state);\n    }\n\n  return state;\n};\n\n/**\n * [Please add a description.]\n */\n\nfunction custom(node, id, scope) {\n  var state = visit(node, id.name, scope);\n  return wrap(state, node, id, scope);\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction property(node, file, scope) {\n  var key = t.toComputedKey(node, node.key);\n  if (!t.isLiteral(key)) return; // we can't set a function id with this\n\n  var name = t.toBindingIdentifierName(key.value);\n  var id = t.identifier(name);\n\n  var method = node.value;\n  var state = visit(method, name, scope);\n  node.value = wrap(state, method, id, scope) || method;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction bare(node, parent, scope) {\n  // has an `id` so we don't need to infer one\n  if (node.id) return;\n\n  var id;\n  if (t.isProperty(parent) && parent.kind === \"init\" && (!parent.computed || t.isLiteral(parent.key))) {\n    // { foo() {} };\n    id = parent.key;\n  } else if (t.isVariableDeclarator(parent)) {\n    // var foo = function () {};\n    id = parent.id;\n\n    if (t.isIdentifier(id)) {\n      var binding = scope.parent.getBinding(id.name);\n      if (binding && binding.constant && scope.getBinding(id.name) === binding) {\n        // always going to reference this method\n        node.id = id;\n        return;\n      }\n    }\n  } else {\n    return;\n  }\n\n  var name;\n  if (t.isLiteral(id)) {\n    name = id.value;\n  } else if (t.isIdentifier(id)) {\n    name = id.name;\n  } else {\n    return;\n  }\n\n  name = t.toBindingIdentifierName(name);\n  id = t.identifier(name);\n\n  var state = visit(node, name, scope);\n  return wrap(state, node, id, scope);\n}","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nexports[\"default\"] = function (node) {\n  var lastNonDefault = 0;\n  for (var i = 0; i < node.params.length; i++) {\n    var param = node.params[i];\n    if (!t.isAssignmentPattern(param) && !t.isRestElement(param)) {\n      lastNonDefault = i + 1;\n    }\n  }\n  return lastNonDefault;\n};\n\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\nvar metadata = {\n  stage: 1,\n  dependencies: [\"es6.classes\"]\n};\nexports.metadata = metadata;","\n\nexports.__esModule = true;\nvar metadata = {\n  stage: 2\n};\nexports.metadata = metadata;","\n\nexports.__esModule = true;\nvar metadata = {\n  stage: 3\n};\nexports.metadata = metadata;","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _helpersMemoiseDecorators = require(\"../../helpers/memoise-decorators\");\n\nvar _helpersMemoiseDecorators2 = _interopRequireDefault(_helpersMemoiseDecorators);\n\nvar _helpersDefineMap = require(\"../../helpers/define-map\");\n\nvar defineMap = _interopRequireWildcard(_helpersDefineMap);\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\nvar metadata = {\n  dependencies: [\"es6.classes\"],\n  optional: true,\n  stage: 1\n};\n\nexports.metadata = metadata;\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  ObjectExpression: function ObjectExpression(node, parent, scope, file) {\n    var hasDecorators = false;\n    for (var i = 0; i < node.properties.length; i++) {\n      var prop = node.properties[i];\n      if (prop.decorators) {\n        hasDecorators = true;\n        break;\n      }\n    }\n    if (!hasDecorators) return;\n\n    var mutatorMap = {};\n\n    for (var i = 0; i < node.properties.length; i++) {\n      var prop = node.properties[i];\n      if (prop.decorators) _helpersMemoiseDecorators2[\"default\"](prop.decorators, scope);\n\n      if (prop.kind === \"init\" && !prop.method) {\n        prop.kind = \"\";\n        prop.value = t.functionExpression(null, [], t.blockStatement([t.returnStatement(prop.value)]));\n      }\n\n      defineMap.push(mutatorMap, prop, \"initializer\", file);\n    }\n\n    var obj = defineMap.toClassObject(mutatorMap);\n    obj = defineMap.toComputedObjectFromClass(obj);\n    return t.callExpression(file.addHelper(\"create-decorated-object\"), [obj]);\n  }\n};\nexports.visitor = visitor;","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nexports[\"default\"] = function (decorators, scope) {\n  for (var i = 0; i < decorators.length; i++) {\n    var decorator = decorators[i];\n    var expression = decorator.expression;\n    if (!t.isMemberExpression(expression)) continue;\n\n    var temp = scope.maybeGenerateMemoised(expression.object);\n    var ref;\n\n    var nodes = [];\n\n    if (temp) {\n      ref = temp;\n      nodes.push(t.assignmentExpression(\"=\", temp, expression.object));\n    } else {\n      ref = expression.object;\n    }\n\n    nodes.push(t.callExpression(t.memberExpression(t.memberExpression(ref, expression.property, expression.computed), t.identifier(\"bind\")), [ref]));\n\n    if (nodes.length === 1) {\n      decorator.expression = nodes[0];\n    } else {\n      decorator.expression = t.sequenceExpression(nodes);\n    }\n  }\n\n  return decorators;\n};\n\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\nexports.push = push;\nexports.hasComputed = hasComputed;\nexports.toComputedObjectFromClass = toComputedObjectFromClass;\nexports.toClassObject = toClassObject;\nexports.toDefineObject = toDefineObject;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _lodashCollectionEach = require(\"lodash/collection/each\");\n\nvar _lodashCollectionEach2 = _interopRequireDefault(_lodashCollectionEach);\n\nvar _lodashObjectHas = require(\"lodash/object/has\");\n\nvar _lodashObjectHas2 = _interopRequireDefault(_lodashObjectHas);\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nfunction push(mutatorMap, node, kind, file) {\n  var alias = t.toKeyAlias(node);\n\n  //\n\n  var map = {};\n  if (_lodashObjectHas2[\"default\"](mutatorMap, alias)) map = mutatorMap[alias];\n  mutatorMap[alias] = map;\n\n  //\n\n  map._inherits = map._inherits || [];\n  map._inherits.push(node);\n\n  map._key = node.key;\n\n  if (node.computed) {\n    map._computed = true;\n  }\n\n  if (node.decorators) {\n    var decorators = map.decorators = map.decorators || t.arrayExpression([]);\n    decorators.elements = decorators.elements.concat(node.decorators.map(function (dec) {\n      return dec.expression;\n    }).reverse());\n  }\n\n  if (map.value || map.initializer) {\n    throw file.errorWithNode(node, \"Key conflict with sibling node\");\n  }\n\n  if (node.value) {\n    if (node.kind === \"init\") kind = \"value\";\n    if (node.kind === \"get\") kind = \"get\";\n    if (node.kind === \"set\") kind = \"set\";\n\n    t.inheritsComments(node.value, node);\n    map[kind] = node.value;\n  }\n\n  return map;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction hasComputed(mutatorMap) {\n  for (var key in mutatorMap) {\n    if (mutatorMap[key]._computed) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction toComputedObjectFromClass(obj) {\n  var objExpr = t.arrayExpression([]);\n\n  for (var i = 0; i < obj.properties.length; i++) {\n    var prop = obj.properties[i];\n    var val = prop.value;\n    val.properties.unshift(t.property(\"init\", t.identifier(\"key\"), t.toComputedKey(prop)));\n    objExpr.elements.push(val);\n  }\n\n  return objExpr;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction toClassObject(mutatorMap) {\n  var objExpr = t.objectExpression([]);\n\n  _lodashCollectionEach2[\"default\"](mutatorMap, function (map) {\n    var mapNode = t.objectExpression([]);\n\n    var propNode = t.property(\"init\", map._key, mapNode, map._computed);\n\n    _lodashCollectionEach2[\"default\"](map, function (node, key) {\n      if (key[0] === \"_\") return;\n\n      var inheritNode = node;\n      if (t.isMethodDefinition(node) || t.isClassProperty(node)) node = node.value;\n\n      var prop = t.property(\"init\", t.identifier(key), node);\n      t.inheritsComments(prop, inheritNode);\n      t.removeComments(inheritNode);\n\n      mapNode.properties.push(prop);\n    });\n\n    objExpr.properties.push(propNode);\n  });\n\n  return objExpr;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction toDefineObject(mutatorMap) {\n  _lodashCollectionEach2[\"default\"](mutatorMap, function (map) {\n    if (map.value) map.writable = t.literal(true);\n    map.configurable = t.literal(true);\n    map.enumerable = t.literal(true);\n  });\n\n  return toClassObject(mutatorMap);\n}","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _messages = require(\"../../../messages\");\n\nvar messages = _interopRequireWildcard(_messages);\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n// check if the input Literal `source` is an alternate casing of \"react\"\nfunction check(source, file) {\n  if (t.isLiteral(source)) {\n    var name = source.value;\n    var lower = name.toLowerCase();\n\n    if (lower === \"react\" && name !== lower) {\n      throw file.errorWithNode(source, messages.get(\"didYouMean\", \"react\"));\n    }\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  CallExpression: function CallExpression(node, parent, scope, file) {\n    if (this.get(\"callee\").isIdentifier({ name: \"require\" }) && node.arguments.length === 1) {\n      check(node.arguments[0], file);\n    }\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  ModuleDeclaration: function ModuleDeclaration(node, parent, scope, file) {\n    check(node.source, file);\n  }\n};\nexports.visitor = visitor;","/**\n * Turn arrow functions into normal functions.\n *\n * @example\n *\n * **In**\n *\n * ```javascript\n * arr.map(x => x * x);\n * ```\n *\n * **Out**\n *\n * ```javascript\n * arr.map(function (x) {\n *   return x * x;\n * });\n */\n\n\n\nexports.__esModule = true;\nvar visitor = {\n\n  /**\n   * Look for arrow functions and mark them as \"shadow functions\".\n   * @see /transformation/transformers/internal/shadow-functions.js\n   */\n\n  ArrowFunctionExpression: function ArrowFunctionExpression(node) {\n    this.ensureBlock();\n    node.expression = false;\n    node.type = \"FunctionExpression\";\n    node.shadow = node.shadow || true;\n  }\n};\nexports.visitor = visitor;","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nfunction statementList(key, path) {\n  var paths = path.get(key);\n\n  for (var i = 0; i < paths.length; i++) {\n    var _path = paths[i];\n\n    var func = _path.node;\n    if (!t.isFunctionDeclaration(func)) continue;\n\n    var declar = t.variableDeclaration(\"let\", [t.variableDeclarator(func.id, t.toExpression(func))]);\n\n    // hoist it up above everything else\n    declar._blockHoist = 2;\n\n    // todo: name this\n    func.id = null;\n\n    _path.replaceWith(declar);\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  BlockStatement: function BlockStatement(node, parent) {\n    if (t.isFunction(parent) && parent.body === node || t.isExportDeclaration(parent)) {\n      return;\n    }\n\n    statementList(\"body\", this);\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  SwitchCase: function SwitchCase() {\n    statementList(\"consequent\", this);\n  }\n};\nexports.visitor = visitor;","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _helpersReact = require(\"../../helpers/react\");\n\nvar react = _interopRequireWildcard(_helpersReact);\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\nvar metadata = {\n  optional: true\n};\n\nexports.metadata = metadata;\n/**\n * [Please add a description.]\n */\n\nfunction hasRefOrSpread(attrs) {\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    if (t.isJSXSpreadAttribute(attr)) return true;\n    if (isJSXAttributeOfName(attr, \"ref\")) return true;\n  }\n  return false;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction isJSXAttributeOfName(attr, name) {\n  return t.isJSXAttribute(attr) && t.isJSXIdentifier(attr.name, { name: name });\n}\n\n/**\n * [Please add a description.]\n */\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  JSXElement: function JSXElement(node, parent, scope, file) {\n    // filter\n    var open = node.openingElement;\n    if (hasRefOrSpread(open.attributes)) return;\n\n    // init\n    var isComponent = true;\n    var props = t.objectExpression([]);\n    var obj = t.objectExpression([]);\n    var key = t.literal(null);\n    var type = open.name;\n\n    if (t.isJSXIdentifier(type) && react.isCompatTag(type.name)) {\n      type = t.literal(type.name);\n      isComponent = false;\n    }\n\n    function pushElemProp(key, value) {\n      pushProp(obj.properties, t.identifier(key), value);\n    }\n\n    function pushProp(objProps, key, value) {\n      objProps.push(t.property(\"init\", key, value));\n    }\n\n    if (node.children.length) {\n      var children = react.buildChildren(node);\n      children = children.length === 1 ? children[0] : t.arrayExpression(children);\n      pushProp(props.properties, t.identifier(\"children\"), children);\n    }\n\n    // props\n    for (var i = 0; i < open.attributes.length; i++) {\n      var attr = open.attributes[i];\n      if (isJSXAttributeOfName(attr, \"key\")) {\n        key = attr.value;\n      } else {\n        pushProp(props.properties, attr.name, attr.value || t.identifier(\"true\"));\n      }\n    }\n\n    if (isComponent) {\n      props = t.callExpression(file.addHelper(\"default-props\"), [t.memberExpression(type, t.identifier(\"defaultProps\")), props]);\n    }\n\n    // metadata\n    pushElemProp(\"$$typeof\", file.addHelper(\"typeof-react-element\"));\n    pushElemProp(\"type\", type);\n    pushElemProp(\"key\", key);\n    pushElemProp(\"ref\", t.literal(null));\n\n    pushElemProp(\"props\", props);\n    pushElemProp(\"_owner\", t.literal(null));\n\n    return obj;\n  }\n};\nexports.visitor = visitor;","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _helpersBuildComprehension = require(\"../../helpers/build-comprehension\");\n\nvar _helpersBuildComprehension2 = _interopRequireDefault(_helpersBuildComprehension);\n\nvar _traversal = require(\"../../../traversal\");\n\nvar _traversal2 = _interopRequireDefault(_traversal);\n\nvar _util = require(\"../../../util\");\n\nvar util = _interopRequireWildcard(_util);\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\nvar metadata = {\n  stage: 0\n};\n\nexports.metadata = metadata;\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  ComprehensionExpression: function ComprehensionExpression(node, parent, scope) {\n    var callback = array;\n    if (node.generator) callback = generator;\n    return callback(node, parent, scope);\n  }\n};\n\nexports.visitor = visitor;\n/**\n * [Please add a description.]\n */\n\nfunction generator(node) {\n  var body = [];\n  var container = t.functionExpression(null, [], t.blockStatement(body), true);\n  container.shadow = true;\n\n  body.push(_helpersBuildComprehension2[\"default\"](node, function () {\n    return t.expressionStatement(t.yieldExpression(node.body));\n  }));\n\n  return t.callExpression(container, []);\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction array(node, parent, scope) {\n  var uid = scope.generateUidIdentifierBasedOnNode(parent);\n\n  var container = util.template(\"array-comprehension-container\", {\n    KEY: uid\n  });\n  container.callee.shadow = true;\n\n  var block = container.callee.body;\n  var body = block.body;\n\n  if (_traversal2[\"default\"].hasType(node, scope, \"YieldExpression\", t.FUNCTION_TYPES)) {\n    container.callee.generator = true;\n    container = t.yieldExpression(container, true);\n  }\n\n  var returnStatement = body.pop();\n\n  body.push(_helpersBuildComprehension2[\"default\"](node, function () {\n    return util.template(\"array-push\", {\n      STATEMENT: node.body,\n      KEY: uid\n    }, true);\n  }));\n  body.push(returnStatement);\n\n  return container;\n}","\n\nexports.__esModule = true;\nexports[\"default\"] = build;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nfunction build(node, buildBody) {\n  var self = node.blocks.shift();\n  if (!self) return;\n\n  var child = build(node, buildBody);\n  if (!child) {\n    // last item\n    child = buildBody();\n\n    // add a filter as this is our final stop\n    if (node.filter) {\n      child = t.ifStatement(node.filter, t.blockStatement([child]));\n    }\n  }\n\n  return t.forOfStatement(t.variableDeclaration(\"let\", [t.variableDeclarator(self.left)]), self.right, t.blockStatement([child]));\n}\n\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _loose = require(\"./loose\");\n\nvar _loose2 = _interopRequireDefault(_loose);\n\nvar _vanilla = require(\"./vanilla\");\n\nvar _vanilla2 = _interopRequireDefault(_vanilla);\n\nvar _types = require(\"../../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\nvar _helpersNameMethod = require(\"../../../helpers/name-method\");\n\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  ClassDeclaration: function ClassDeclaration(node) {\n    return t.variableDeclaration(\"let\", [t.variableDeclarator(node.id, t.toExpression(node))]);\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  ClassExpression: function ClassExpression(node, parent, scope, file) {\n    var inferred = _helpersNameMethod.bare(node, parent, scope);\n    if (inferred) return inferred;\n\n    if (file.isLoose(\"es6.classes\")) {\n      return new _loose2[\"default\"](this, file).run();\n    } else {\n      return new _vanilla2[\"default\"](this, file).run();\n    }\n  }\n};\nexports.visitor = visitor;","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// istanbul ignore next\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n// istanbul ignore next\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar _vanilla = require(\"./vanilla\");\n\nvar _vanilla2 = _interopRequireDefault(_vanilla);\n\nvar _types = require(\"../../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nvar LooseClassTransformer = (function (_VanillaTransformer) {\n  _inherits(LooseClassTransformer, _VanillaTransformer);\n\n  function LooseClassTransformer() {\n    _classCallCheck(this, LooseClassTransformer);\n\n    _VanillaTransformer.apply(this, arguments);\n    this.isLoose = true;\n  }\n\n  /**\n   * [Please add a description.]\n   */\n\n  LooseClassTransformer.prototype._processMethod = function _processMethod(node) {\n    if (!node.decorators) {\n      // use assignments instead of define properties for loose classes\n\n      var classRef = this.classRef;\n      if (!node[\"static\"]) classRef = t.memberExpression(classRef, t.identifier(\"prototype\"));\n      var methodName = t.memberExpression(classRef, node.key, node.computed || t.isLiteral(node.key));\n\n      var expr = t.expressionStatement(t.assignmentExpression(\"=\", methodName, node.value));\n      t.inheritsComments(expr, node);\n      this.body.push(expr);\n      return true;\n    }\n  };\n\n  return LooseClassTransformer;\n})(_vanilla2[\"default\"]);\n\nexports[\"default\"] = LooseClassTransformer;\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// istanbul ignore next\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _helpersMemoiseDecorators = require(\"../../../helpers/memoise-decorators\");\n\nvar _helpersMemoiseDecorators2 = _interopRequireDefault(_helpersMemoiseDecorators);\n\nvar _helpersReplaceSupers = require(\"../../../helpers/replace-supers\");\n\nvar _helpersReplaceSupers2 = _interopRequireDefault(_helpersReplaceSupers);\n\nvar _helpersNameMethod = require(\"../../../helpers/name-method\");\n\nvar nameMethod = _interopRequireWildcard(_helpersNameMethod);\n\nvar _helpersDefineMap = require(\"../../../helpers/define-map\");\n\nvar defineMap = _interopRequireWildcard(_helpersDefineMap);\n\nvar _messages = require(\"../../../../messages\");\n\nvar messages = _interopRequireWildcard(_messages);\n\nvar _util = require(\"../../../../util\");\n\nvar util = _interopRequireWildcard(_util);\n\nvar _types = require(\"../../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\nvar PROPERTY_COLLISION_METHOD_NAME = \"__initializeProperties\";\n\n/**\n * [Please add a description.]\n */\n\nvar collectPropertyReferencesVisitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  Identifier: {\n    enter: function enter(node, parent, scope, state) {\n      if (this.parentPath.isClassProperty({ key: node })) {\n        return;\n      }\n\n      if (this.isReferenced() && scope.getBinding(node.name) === state.scope.getBinding(node.name)) {\n        state.references[node.name] = true;\n      }\n    }\n  }\n};\n\n/**\n * [Please add a description.]\n */\n\nvar verifyConstructorVisitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  MethodDefinition: function MethodDefinition() {\n    this.skip();\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  Property: function Property(node) {\n    if (node.method) this.skip();\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  CallExpression: {\n    exit: function exit(node, parent, scope, state) {\n      if (this.get(\"callee\").isSuper()) {\n        state.hasBareSuper = true;\n        state.bareSuper = this;\n\n        if (!state.isDerived) {\n          throw this.errorWithNode(\"super call is only allowed in derived constructor\");\n        }\n      }\n    }\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  \"FunctionDeclaration|FunctionExpression\": function FunctionDeclarationFunctionExpression() {\n    this.skip();\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  ThisExpression: function ThisExpression(node, parent, scope, state) {\n    if (state.isDerived && !state.hasBareSuper) {\n      if (this.inShadow()) {\n        // https://github.com/babel/babel/issues/1920\n        var thisAlias = state.constructorPath.getData(\"this\");\n\n        if (!thisAlias) {\n          thisAlias = state.constructorPath.setData(\"this\", state.constructorPath.scope.generateUidIdentifier(\"this\"));\n        }\n\n        return thisAlias;\n      } else {\n        throw this.errorWithNode(\"'this' is not allowed before super()\");\n      }\n    }\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  Super: function Super(node, parent, scope, state) {\n    if (state.isDerived && !state.hasBareSuper && !this.parentPath.isCallExpression({ callee: node })) {\n      throw this.errorWithNode(\"'super.*' is not allowed before super()\");\n    }\n  }\n};\n\n/**\n * [Please add a description.]\n */\n\nvar ClassTransformer = (function () {\n  function ClassTransformer(path, file) {\n    _classCallCheck(this, ClassTransformer);\n\n    this.parent = path.parent;\n    this.scope = path.scope;\n    this.node = path.node;\n    this.path = path;\n    this.file = file;\n\n    this.clearDescriptors();\n\n    this.instancePropBody = [];\n    this.instancePropRefs = {};\n    this.staticPropBody = [];\n    this.body = [];\n\n    this.pushedConstructor = false;\n    this.pushedInherits = false;\n    this.hasDecorators = false;\n    this.isLoose = false;\n\n    // class id\n    this.classId = this.node.id;\n\n    // this is the name of the binding that will **always** reference the class we've constructed\n    this.classRef = this.node.id || this.scope.generateUidIdentifier(\"class\");\n\n    // this is a direct reference to the class we're building, class decorators can shadow the classRef\n    this.directRef = null;\n\n    this.superName = this.node.superClass || t.identifier(\"Function\");\n    this.isDerived = !!this.node.superClass;\n  }\n\n  /**\n   * [Please add a description.]\n   * @returns {Array}\n   */\n\n  ClassTransformer.prototype.run = function run() {\n    var superName = this.superName;\n    var file = this.file;\n\n    //\n\n    var body = this.body;\n\n    //\n\n    var constructorBody = this.constructorBody = t.blockStatement([]);\n    this.constructor = this.buildConstructor();\n\n    //\n\n    var closureParams = [];\n    var closureArgs = [];\n\n    //\n    if (this.isDerived) {\n      closureArgs.push(superName);\n\n      superName = this.scope.generateUidIdentifierBasedOnNode(superName);\n      closureParams.push(superName);\n\n      this.superName = superName;\n    }\n\n    //\n    var decorators = this.node.decorators;\n    if (decorators) {\n      // this is so super calls and the decorators have access to the raw function\n      this.directRef = this.scope.generateUidIdentifier(this.classRef);\n    } else {\n      this.directRef = this.classRef;\n    }\n\n    //\n    this.buildBody();\n\n    // make sure this class isn't directly called\n    constructorBody.body.unshift(t.expressionStatement(t.callExpression(file.addHelper(\"class-call-check\"), [t.thisExpression(), this.directRef])));\n\n    //\n    this.pushDecorators();\n\n    body = body.concat(this.staticPropBody);\n\n    if (this.classId) {\n      // named class with only a constructor\n      if (body.length === 1) return t.toExpression(body[0]);\n    }\n\n    //\n    body.push(t.returnStatement(this.classRef));\n\n    var container = t.functionExpression(null, closureParams, t.blockStatement(body));\n    container.shadow = true;\n    return t.callExpression(container, closureArgs);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  ClassTransformer.prototype.buildConstructor = function buildConstructor() {\n    var func = t.functionDeclaration(this.classRef, [], this.constructorBody);\n    t.inherits(func, this.node);\n    return func;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  ClassTransformer.prototype.pushToMap = function pushToMap(node, enumerable) {\n    var kind = arguments.length <= 2 || arguments[2] === undefined ? \"value\" : arguments[2];\n\n    var mutatorMap;\n    if (node[\"static\"]) {\n      this.hasStaticDescriptors = true;\n      mutatorMap = this.staticMutatorMap;\n    } else {\n      this.hasInstanceDescriptors = true;\n      mutatorMap = this.instanceMutatorMap;\n    }\n\n    var map = defineMap.push(mutatorMap, node, kind, this.file);\n\n    if (enumerable) {\n      map.enumerable = t.literal(true);\n    }\n\n    if (map.decorators) {\n      this.hasDecorators = true;\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   * https://www.youtube.com/watch?v=fWNaR-rxAic\n   */\n\n  ClassTransformer.prototype.constructorMeMaybe = function constructorMeMaybe() {\n    var hasConstructor = false;\n    var paths = this.path.get(\"body.body\");\n    var _arr = paths;\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var path = _arr[_i];\n      hasConstructor = path.equals(\"kind\", \"constructor\");\n      if (hasConstructor) break;\n    }\n    if (hasConstructor) return;\n\n    var constructor;\n    if (this.isDerived) {\n      constructor = util.template(\"class-derived-default-constructor\");\n    } else {\n      constructor = t.functionExpression(null, [], t.blockStatement([]));\n    }\n\n    this.path.get(\"body\").unshiftContainer(\"body\", t.methodDefinition(t.identifier(\"constructor\"), constructor, \"constructor\"));\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  ClassTransformer.prototype.buildBody = function buildBody() {\n    this.constructorMeMaybe();\n    this.pushBody();\n    this.placePropertyInitializers();\n\n    if (this.userConstructor) {\n      var constructorBody = this.constructorBody;\n      constructorBody.body = constructorBody.body.concat(this.userConstructor.body.body);\n      t.inherits(this.constructor, this.userConstructor);\n      t.inherits(constructorBody, this.userConstructor.body);\n    }\n\n    this.pushDescriptors();\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  ClassTransformer.prototype.pushBody = function pushBody() {\n    var classBodyPaths = this.path.get(\"body.body\");\n\n    var _arr2 = classBodyPaths;\n    for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n      var path = _arr2[_i2];\n      var node = path.node;\n\n      if (node.decorators) {\n        _helpersMemoiseDecorators2[\"default\"](node.decorators, this.scope);\n      }\n\n      if (t.isMethodDefinition(node)) {\n        var isConstructor = node.kind === \"constructor\";\n        if (isConstructor) this.verifyConstructor(path);\n\n        var replaceSupers = new _helpersReplaceSupers2[\"default\"]({\n          methodPath: path,\n          methodNode: node,\n          objectRef: this.directRef,\n          superRef: this.superName,\n          isStatic: node[\"static\"],\n          isLoose: this.isLoose,\n          scope: this.scope,\n          file: this.file\n        }, true);\n\n        replaceSupers.replace();\n\n        if (isConstructor) {\n          this.pushConstructor(node, path);\n        } else {\n          this.pushMethod(node, path);\n        }\n      } else if (t.isClassProperty(node)) {\n        this.pushProperty(node, path);\n      }\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  ClassTransformer.prototype.clearDescriptors = function clearDescriptors() {\n    this.hasInstanceDescriptors = false;\n    this.hasStaticDescriptors = false;\n\n    this.instanceMutatorMap = {};\n    this.staticMutatorMap = {};\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  ClassTransformer.prototype.pushDescriptors = function pushDescriptors() {\n    this.pushInherits();\n\n    var body = this.body;\n\n    var instanceProps;\n    var staticProps;\n    var classHelper = \"create-class\";\n    if (this.hasDecorators) classHelper = \"create-decorated-class\";\n\n    if (this.hasInstanceDescriptors) {\n      instanceProps = defineMap.toClassObject(this.instanceMutatorMap);\n    }\n\n    if (this.hasStaticDescriptors) {\n      staticProps = defineMap.toClassObject(this.staticMutatorMap);\n    }\n\n    if (instanceProps || staticProps) {\n      if (instanceProps) instanceProps = defineMap.toComputedObjectFromClass(instanceProps);\n      if (staticProps) staticProps = defineMap.toComputedObjectFromClass(staticProps);\n\n      var nullNode = t.literal(null);\n\n      // (Constructor, instanceDescriptors, staticDescriptors, instanceInitializers, staticInitializers)\n      var args = [this.classRef, nullNode, nullNode, nullNode, nullNode];\n\n      if (instanceProps) args[1] = instanceProps;\n      if (staticProps) args[2] = staticProps;\n\n      if (this.instanceInitializersId) {\n        args[3] = this.instanceInitializersId;\n        body.unshift(this.buildObjectAssignment(this.instanceInitializersId));\n      }\n\n      if (this.staticInitializersId) {\n        args[4] = this.staticInitializersId;\n        body.unshift(this.buildObjectAssignment(this.staticInitializersId));\n      }\n\n      var lastNonNullIndex = 0;\n      for (var i = 0; i < args.length; i++) {\n        if (args[i] !== nullNode) lastNonNullIndex = i;\n      }\n      args = args.slice(0, lastNonNullIndex + 1);\n\n      body.push(t.expressionStatement(t.callExpression(this.file.addHelper(classHelper), args)));\n    }\n\n    this.clearDescriptors();\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  ClassTransformer.prototype.buildObjectAssignment = function buildObjectAssignment(id) {\n    return t.variableDeclaration(\"var\", [t.variableDeclarator(id, t.objectExpression([]))]);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  ClassTransformer.prototype.placePropertyInitializers = function placePropertyInitializers() {\n    var body = this.instancePropBody;\n    if (!body.length) return;\n\n    if (this.hasPropertyCollision()) {\n      var call = t.expressionStatement(t.callExpression(t.memberExpression(t.thisExpression(), t.identifier(PROPERTY_COLLISION_METHOD_NAME)), []));\n\n      this.pushMethod(t.methodDefinition(t.identifier(PROPERTY_COLLISION_METHOD_NAME), t.functionExpression(null, [], t.blockStatement(body))), null, true);\n\n      if (this.isDerived) {\n        this.bareSuper.insertAfter(call);\n      } else {\n        this.constructorBody.body.unshift(call);\n      }\n    } else {\n      if (this.isDerived) {\n        this.bareSuper.insertAfter(body);\n      } else {\n        this.constructorBody.body = body.concat(this.constructorBody.body);\n      }\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  ClassTransformer.prototype.hasPropertyCollision = function hasPropertyCollision() {\n    if (this.userConstructorPath) {\n      for (var name in this.instancePropRefs) {\n        if (this.userConstructorPath.scope.hasOwnBinding(name)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  ClassTransformer.prototype.verifyConstructor = function verifyConstructor(path) {\n    var state = {\n      constructorPath: path.get(\"value\"),\n      hasBareSuper: false,\n      bareSuper: null,\n      isDerived: this.isDerived,\n      file: this.file\n    };\n\n    state.constructorPath.traverse(verifyConstructorVisitor, state);\n\n    var thisAlias = state.constructorPath.getData(\"this\");\n    if (thisAlias && state.bareSuper) {\n      state.bareSuper.insertAfter(t.variableDeclaration(\"var\", [t.variableDeclarator(thisAlias, t.thisExpression())]));\n    }\n\n    this.bareSuper = state.bareSuper;\n\n    if (!state.hasBareSuper && this.isDerived) {\n      throw path.errorWithNode(\"Derived constructor must call super()\");\n    }\n  };\n\n  /**\n   * Push a method to its respective mutatorMap.\n   */\n\n  ClassTransformer.prototype.pushMethod = function pushMethod(node, path, allowedIllegal) {\n    if (!allowedIllegal && t.isLiteral(t.toComputedKey(node), { value: PROPERTY_COLLISION_METHOD_NAME })) {\n      throw this.file.errorWithNode(node, messages.get(\"illegalMethodName\", PROPERTY_COLLISION_METHOD_NAME));\n    }\n\n    if (node.kind === \"method\") {\n      nameMethod.property(node, this.file, path ? path.get(\"value\").scope : this.scope);\n      if (this._processMethod(node)) return;\n    }\n\n    this.pushToMap(node);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  ClassTransformer.prototype._processMethod = function _processMethod() {\n    return false;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  ClassTransformer.prototype.pushProperty = function pushProperty(node, path) {\n    path.traverse(collectPropertyReferencesVisitor, {\n      references: this.instancePropRefs,\n      scope: this.scope\n    });\n\n    if (node.decorators) {\n      var body = [];\n      if (node.value) {\n        body.push(t.returnStatement(node.value));\n        node.value = t.functionExpression(null, [], t.blockStatement(body));\n      } else {\n        node.value = t.literal(null);\n      }\n      this.pushToMap(node, true, \"initializer\");\n\n      var initializers;\n      var target;\n      if (node[\"static\"]) {\n        initializers = this.staticInitializersId = this.staticInitializersId || this.scope.generateUidIdentifier(\"staticInitializers\");\n        body = this.staticPropBody;\n        target = this.classRef;\n      } else {\n        initializers = this.instanceInitializersId = this.instanceInitializersId || this.scope.generateUidIdentifier(\"instanceInitializers\");\n        body = this.instancePropBody;\n        target = t.thisExpression();\n      }\n\n      body.push(t.expressionStatement(t.callExpression(this.file.addHelper(\"define-decorated-property-descriptor\"), [target, t.literal(node.key.name), initializers])));\n    } else {\n      if (!node.value && !node.decorators) return;\n\n      if (node[\"static\"]) {\n        // can just be added to the static map\n        this.pushToMap(node, true);\n      } else if (node.value) {\n        // add this to the instancePropBody which will be added after the super call in a derived constructor\n        // or at the start of a constructor for a non-derived constructor\n        this.instancePropBody.push(t.expressionStatement(t.assignmentExpression(\"=\", t.memberExpression(t.thisExpression(), node.key), node.value)));\n      }\n    }\n  };\n\n  /**\n   * Replace the constructor body of our class.\n   */\n\n  ClassTransformer.prototype.pushConstructor = function pushConstructor(method, path) {\n    // https://github.com/babel/babel/issues/1077\n    var fnPath = path.get(\"value\");\n    if (fnPath.scope.hasOwnBinding(this.classRef.name)) {\n      fnPath.scope.rename(this.classRef.name);\n    }\n\n    var construct = this.constructor;\n    var fn = method.value;\n\n    this.userConstructorPath = fnPath;\n    this.userConstructor = fn;\n    this.hasConstructor = true;\n\n    t.inheritsComments(construct, method);\n\n    construct._ignoreUserWhitespace = true;\n    construct.params = fn.params;\n\n    t.inherits(construct.body, fn.body);\n\n    // push constructor to body\n    this._pushConstructor();\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  ClassTransformer.prototype._pushConstructor = function _pushConstructor() {\n    if (this.pushedConstructor) return;\n    this.pushedConstructor = true;\n\n    // we haven't pushed any descriptors yet\n    if (this.hasInstanceDescriptors || this.hasStaticDescriptors) {\n      this.pushDescriptors();\n    }\n\n    this.body.push(this.constructor);\n\n    this.pushInherits();\n  };\n\n  /**\n   * Push inherits helper to body.\n   */\n\n  ClassTransformer.prototype.pushInherits = function pushInherits() {\n    if (!this.isDerived || this.pushedInherits) return;\n\n    // Unshift to ensure that the constructor inheritance is set up before\n    // any properties can be assigned to the prototype.\n    this.pushedInherits = true;\n    this.body.unshift(t.expressionStatement(t.callExpression(this.file.addHelper(\"inherits\"), [this.classRef, this.superName])));\n  };\n\n  /**\n   * Push decorators to body.\n   */\n\n  ClassTransformer.prototype.pushDecorators = function pushDecorators() {\n    var decorators = this.node.decorators;\n    if (!decorators) return;\n\n    this.body.push(t.variableDeclaration(\"var\", [t.variableDeclarator(this.directRef, this.classRef)]));\n\n    // reverse the decorators so we execute them in the right order\n    decorators = decorators.reverse();\n\n    var _arr3 = decorators;\n    for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n      var decorator = _arr3[_i3];\n      var decoratorNode = util.template(\"class-decorator\", {\n        DECORATOR: decorator.expression,\n        CLASS_REF: this.classRef\n      }, true);\n      decoratorNode.expression._ignoreModulesRemap = true;\n      this.body.push(decoratorNode);\n    }\n  };\n\n  return ClassTransformer;\n})();\n\nexports[\"default\"] = ClassTransformer;\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _messages = require(\"../../messages\");\n\nvar messages = _interopRequireWildcard(_messages);\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nfunction isIllegalBareSuper(node, parent) {\n  if (!t.isSuper(node)) return false;\n  if (t.isMemberExpression(parent, { computed: false })) return false;\n  if (t.isCallExpression(parent, { callee: node })) return false;\n  return true;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction isMemberExpressionSuper(node) {\n  return t.isMemberExpression(node) && t.isSuper(node.object);\n}\n\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  enter: function enter(node, parent, scope, state) {\n    var topLevel = state.topLevel;\n    var self = state.self;\n\n    if (t.isFunction(node) && !t.isArrowFunctionExpression(node)) {\n      // we need to call traverseLevel again so we're context aware\n      self.traverseLevel(this, false);\n      return this.skip();\n    }\n\n    if (t.isProperty(node, { method: true }) || t.isMethodDefinition(node)) {\n      // break on object methods\n      return this.skip();\n    }\n\n    var getThisReference = topLevel ?\n    // top level so `this` is the instance\n    t.thisExpression :\n    // not in the top level so we need to create a reference\n    self.getThisReference.bind(self);\n\n    var callback = self.specHandle;\n    if (self.isLoose) callback = self.looseHandle;\n    var result = callback.call(self, this, getThisReference);\n    if (result) this.hasSuper = true;\n    if (result === true) return;\n    return result;\n  }\n};\n\n/**\n * [Please add a description.]\n */\n\nvar ReplaceSupers = (function () {\n  function ReplaceSupers(opts) {\n    var inClass = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];\n\n    _classCallCheck(this, ReplaceSupers);\n\n    this.topLevelThisReference = opts.topLevelThisReference;\n    this.methodPath = opts.methodPath;\n    this.methodNode = opts.methodNode;\n    this.superRef = opts.superRef;\n    this.isStatic = opts.isStatic;\n    this.hasSuper = false;\n    this.inClass = inClass;\n    this.isLoose = opts.isLoose;\n    this.scope = opts.scope;\n    this.file = opts.file;\n    this.opts = opts;\n  }\n\n  /**\n   * [Please add a description.]\n   */\n\n  ReplaceSupers.prototype.getObjectRef = function getObjectRef() {\n    return this.opts.objectRef || this.opts.getObjectRef();\n  };\n\n  /**\n   * Sets a super class value of the named property.\n   *\n   * @example\n   *\n   *   _set(Object.getPrototypeOf(CLASS.prototype), \"METHOD\", \"VALUE\", this)\n   *\n   */\n\n  ReplaceSupers.prototype.setSuperProperty = function setSuperProperty(property, value, isComputed, thisExpression) {\n    return t.callExpression(this.file.addHelper(\"set\"), [t.callExpression(t.memberExpression(t.identifier(\"Object\"), t.identifier(\"getPrototypeOf\")), [this.isStatic ? this.getObjectRef() : t.memberExpression(this.getObjectRef(), t.identifier(\"prototype\"))]), isComputed ? property : t.literal(property.name), value, thisExpression]);\n  };\n\n  /**\n   * Gets a node representing the super class value of the named property.\n   *\n   * @example\n   *\n   *   _get(Object.getPrototypeOf(CLASS.prototype), \"METHOD\", this)\n   *\n   */\n\n  ReplaceSupers.prototype.getSuperProperty = function getSuperProperty(property, isComputed, thisExpression) {\n    return t.callExpression(this.file.addHelper(\"get\"), [t.callExpression(t.memberExpression(t.identifier(\"Object\"), t.identifier(\"getPrototypeOf\")), [this.isStatic ? this.getObjectRef() : t.memberExpression(this.getObjectRef(), t.identifier(\"prototype\"))]), isComputed ? property : t.literal(property.name), thisExpression]);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  ReplaceSupers.prototype.replace = function replace() {\n    this.traverseLevel(this.methodPath.get(\"value\"), true);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  ReplaceSupers.prototype.traverseLevel = function traverseLevel(path, topLevel) {\n    var state = { self: this, topLevel: topLevel };\n    path.traverse(visitor, state);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  ReplaceSupers.prototype.getThisReference = function getThisReference() {\n    if (this.topLevelThisReference) {\n      return this.topLevelThisReference;\n    } else {\n      var ref = this.topLevelThisReference = this.scope.generateUidIdentifier(\"this\");\n      this.methodNode.value.body.body.unshift(t.variableDeclaration(\"var\", [t.variableDeclarator(this.topLevelThisReference, t.thisExpression())]));\n      return ref;\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  ReplaceSupers.prototype.getLooseSuperProperty = function getLooseSuperProperty(id, parent) {\n    var methodNode = this.methodNode;\n    var methodName = methodNode.key;\n    var superRef = this.superRef || t.identifier(\"Function\");\n\n    if (parent.property === id) {\n      return;\n    } else if (t.isCallExpression(parent, { callee: id })) {\n      // super(); -> objectRef.prototype.MethodName.call(this);\n      parent.arguments.unshift(t.thisExpression());\n\n      if (methodName.name === \"constructor\") {\n        // constructor() { super(); }\n        if (parent.arguments.length === 2 && t.isSpreadElement(parent.arguments[1]) && t.isIdentifier(parent.arguments[1].argument, { name: \"arguments\" })) {\n          // special case single arguments spread\n          parent.arguments[1] = parent.arguments[1].argument;\n          return t.memberExpression(superRef, t.identifier(\"apply\"));\n        } else {\n          return t.memberExpression(superRef, t.identifier(\"call\"));\n        }\n      } else {\n        id = superRef;\n\n        // foo() { super(); }\n        if (!methodNode[\"static\"]) {\n          id = t.memberExpression(id, t.identifier(\"prototype\"));\n        }\n\n        id = t.memberExpression(id, methodName, methodNode.computed);\n        return t.memberExpression(id, t.identifier(\"call\"));\n      }\n    } else if (t.isMemberExpression(parent) && !methodNode[\"static\"]) {\n      // super.test -> objectRef.prototype.test\n      return t.memberExpression(superRef, t.identifier(\"prototype\"));\n    } else {\n      return superRef;\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  ReplaceSupers.prototype.looseHandle = function looseHandle(path, getThisReference) {\n    var node = path.node;\n    if (path.isSuper()) {\n      return this.getLooseSuperProperty(node, path.parent);\n    } else if (path.isCallExpression()) {\n      var callee = node.callee;\n      if (!t.isMemberExpression(callee)) return;\n      if (!t.isSuper(callee.object)) return;\n\n      // super.test(); -> objectRef.prototype.MethodName.call(this);\n      t.appendToMemberExpression(callee, t.identifier(\"call\"));\n      node.arguments.unshift(getThisReference());\n      return true;\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  ReplaceSupers.prototype.specHandleAssignmentExpression = function specHandleAssignmentExpression(ref, path, node, getThisReference) {\n    if (node.operator === \"=\") {\n      // super.name = \"val\"; -> _set(Object.getPrototypeOf(objectRef.prototype), \"name\", this);\n      return this.setSuperProperty(node.left.property, node.right, node.left.computed, getThisReference());\n    } else {\n      // super.age += 2; -> var _ref = super.age; super.age = _ref + 2;\n      ref = ref || path.scope.generateUidIdentifier(\"ref\");\n      return [t.variableDeclaration(\"var\", [t.variableDeclarator(ref, node.left)]), t.expressionStatement(t.assignmentExpression(\"=\", node.left, t.binaryExpression(node.operator[0], ref, node.right)))];\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  ReplaceSupers.prototype.specHandle = function specHandle(path, getThisReference) {\n    var methodNode = this.methodNode;\n    var property;\n    var computed;\n    var args;\n    var thisReference;\n\n    var parent = path.parent;\n    var node = path.node;\n\n    if (isIllegalBareSuper(node, parent)) {\n      throw path.errorWithNode(messages.get(\"classesIllegalBareSuper\"));\n    }\n\n    if (t.isCallExpression(node)) {\n      var callee = node.callee;\n      if (t.isSuper(callee)) {\n        // super(); -> _get(Object.getPrototypeOf(objectRef), \"MethodName\", this).call(this);\n        property = methodNode.key;\n        computed = methodNode.computed;\n        args = node.arguments;\n\n        // bare `super` call is illegal inside non-constructors\n        //  - https://esdiscuss.org/topic/super-call-in-methods\n        //  - https://twitter.com/wycats/status/544553184396836864\n        if (methodNode.key.name !== \"constructor\" || !this.inClass) {\n          var methodName = methodNode.key.name || \"METHOD_NAME\";\n          throw this.file.errorWithNode(node, messages.get(\"classesIllegalSuperCall\", methodName));\n        }\n      } else if (isMemberExpressionSuper(callee)) {\n        // super.test(); -> _get(Object.getPrototypeOf(objectRef.prototype), \"test\", this).call(this);\n        property = callee.property;\n        computed = callee.computed;\n        args = node.arguments;\n      }\n    } else if (t.isMemberExpression(node) && t.isSuper(node.object)) {\n      // super.name; -> _get(Object.getPrototypeOf(objectRef.prototype), \"name\", this);\n      property = node.property;\n      computed = node.computed;\n    } else if (t.isUpdateExpression(node) && isMemberExpressionSuper(node.argument)) {\n      var binary = t.binaryExpression(node.operator[0], node.argument, t.literal(1));\n      if (node.prefix) {\n        // ++super.foo; -> super.foo += 1;\n        return this.specHandleAssignmentExpression(null, path, binary, getThisReference);\n      } else {\n        // super.foo++; -> var _ref = super.foo; super.foo = _ref + 1;\n        var ref = path.scope.generateUidIdentifier(\"ref\");\n        return this.specHandleAssignmentExpression(ref, path, binary, getThisReference).concat(t.expressionStatement(ref));\n      }\n    } else if (t.isAssignmentExpression(node) && isMemberExpressionSuper(node.left)) {\n      return this.specHandleAssignmentExpression(null, path, node, getThisReference);\n    }\n\n    if (!property) return;\n\n    thisReference = getThisReference();\n    var superProperty = this.getSuperProperty(property, computed, thisReference);\n    if (args) {\n      if (args.length === 1 && t.isSpreadElement(args[0])) {\n        // super(...arguments);\n        return t.callExpression(t.memberExpression(superProperty, t.identifier(\"apply\")), [thisReference, args[0].argument]);\n      } else {\n        return t.callExpression(t.memberExpression(superProperty, t.identifier(\"call\")), [thisReference].concat(args));\n      }\n    } else {\n      return superProperty;\n    }\n  };\n\n  return ReplaceSupers;\n})();\n\nexports[\"default\"] = ReplaceSupers;\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _helpersRemapAsyncToGenerator = require(\"../../helpers/remap-async-to-generator\");\n\nvar _helpersRemapAsyncToGenerator2 = _interopRequireDefault(_helpersRemapAsyncToGenerator);\n\nvar _bluebirdCoroutines = require(\"./bluebird-coroutines\");\n\nexports.manipulateOptions = _bluebirdCoroutines.manipulateOptions;\nvar metadata = {\n  optional: true,\n  dependencies: [\"es7.asyncFunctions\", \"es6.classes\"]\n};\n\nexports.metadata = metadata;\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  Function: function Function(node, parent, scope, file) {\n    if (!node.async || node.generator) return;\n\n    return _helpersRemapAsyncToGenerator2[\"default\"](this, file.addHelper(\"async-to-generator\"));\n  }\n};\nexports.visitor = visitor;","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nvar awaitVisitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  Function: function Function() {\n    this.skip();\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  AwaitExpression: function AwaitExpression(node) {\n    node.type = \"YieldExpression\";\n\n    if (node.all) {\n      // await* foo; -> yield Promise.all(foo);\n      node.all = false;\n      node.argument = t.callExpression(t.memberExpression(t.identifier(\"Promise\"), t.identifier(\"all\")), [node.argument]);\n    }\n  }\n};\n\n/**\n * [Please add a description.]\n */\n\nvar referenceVisitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope, state) {\n    var name = state.id.name;\n    if (node.name === name && scope.bindingIdentifierEquals(name, state.id)) {\n      return state.ref = state.ref || scope.generateUidIdentifier(name);\n    }\n  }\n};\n\n/**\n * [Please add a description.]\n */\n\nexports[\"default\"] = function (path, callId) {\n  var node = path.node;\n\n  node.async = false;\n  node.generator = true;\n\n  path.traverse(awaitVisitor, state);\n\n  var call = t.callExpression(callId, [node]);\n\n  var id = node.id;\n  node.id = null;\n\n  if (t.isFunctionDeclaration(node)) {\n    var declar = t.variableDeclaration(\"let\", [t.variableDeclarator(id, call)]);\n    declar._blockHoist = true;\n    return declar;\n  } else {\n    if (id) {\n      var state = { id: id };\n      path.traverse(referenceVisitor, state);\n\n      if (state.ref) {\n        path.scope.parent.push({ id: state.ref });\n        return t.assignmentExpression(\"=\", state.ref, call);\n      }\n    }\n\n    return call;\n  }\n};\n\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\nexports.manipulateOptions = manipulateOptions;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _helpersRemapAsyncToGenerator = require(\"../../helpers/remap-async-to-generator\");\n\nvar _helpersRemapAsyncToGenerator2 = _interopRequireDefault(_helpersRemapAsyncToGenerator);\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nfunction manipulateOptions(opts) {\n  opts.blacklist.push(\"regenerator\");\n}\n\nvar metadata = {\n  optional: true,\n  dependencies: [\"es7.asyncFunctions\", \"es6.classes\"]\n};\n\nexports.metadata = metadata;\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  Function: function Function(node, parent, scope, file) {\n    if (!node.async || node.generator) return;\n\n    return _helpersRemapAsyncToGenerator2[\"default\"](this, t.memberExpression(file.addImport(\"bluebird\", null, \"absolute\"), t.identifier(\"coroutine\")));\n  }\n};\nexports.visitor = visitor;","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _helpersReplaceSupers = require(\"../../helpers/replace-supers\");\n\nvar _helpersReplaceSupers2 = _interopRequireDefault(_helpersReplaceSupers);\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nfunction Property(path, node, scope, getObjectRef, file) {\n  if (!node.method && node.kind === \"init\") return;\n  if (!t.isFunction(node.value)) return;\n\n  var replaceSupers = new _helpersReplaceSupers2[\"default\"]({\n    getObjectRef: getObjectRef,\n    methodNode: node,\n    methodPath: path,\n    isStatic: true,\n    scope: scope,\n    file: file\n  });\n\n  replaceSupers.replace();\n}\n\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  ObjectExpression: function ObjectExpression(node, parent, scope, file) {\n    var objectRef;\n    var getObjectRef = function getObjectRef() {\n      return objectRef = objectRef || scope.generateUidIdentifier(\"obj\");\n    };\n\n    var propPaths = this.get(\"properties\");\n    for (var i = 0; i < node.properties.length; i++) {\n      Property(propPaths[i], node.properties[i], scope, getObjectRef, file);\n    }\n\n    if (objectRef) {\n      scope.push({ id: objectRef });\n      return t.assignmentExpression(\"=\", objectRef, node);\n    }\n  }\n};\nexports.visitor = visitor;","// https://github.com/sebmarkbage/ecmascript-rest-spread\n\n\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\nvar metadata = {\n  stage: 2,\n  dependencies: [\"es6.destructuring\"]\n};\n\nexports.metadata = metadata;\n/**\n * [Please add a description.]\n */\n\nvar hasSpread = function hasSpread(node) {\n  for (var i = 0; i < node.properties.length; i++) {\n    if (t.isSpreadProperty(node.properties[i])) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  ObjectExpression: function ObjectExpression(node, parent, scope, file) {\n    if (!hasSpread(node)) return;\n\n    var args = [];\n    var props = [];\n\n    var push = function push() {\n      if (!props.length) return;\n      args.push(t.objectExpression(props));\n      props = [];\n    };\n\n    for (var i = 0; i < node.properties.length; i++) {\n      var prop = node.properties[i];\n      if (t.isSpreadProperty(prop)) {\n        push();\n        args.push(prop.argument);\n      } else {\n        props.push(prop);\n      }\n    }\n\n    push();\n\n    if (!t.isObjectExpression(args[0])) {\n      args.unshift(t.objectExpression([]));\n    }\n\n    return t.callExpression(file.addHelper(\"extends\"), args);\n  }\n};\nexports.visitor = visitor;","// https://github.com/rwaldron/exponentiation-operator\n\n\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _helpersBuildBinaryAssignmentOperatorTransformer = require(\"../../helpers/build-binary-assignment-operator-transformer\");\n\nvar _helpersBuildBinaryAssignmentOperatorTransformer2 = _interopRequireDefault(_helpersBuildBinaryAssignmentOperatorTransformer);\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\nvar metadata = {\n  stage: 3\n};\n\nexports.metadata = metadata;\nvar MATH_POW = t.memberExpression(t.identifier(\"Math\"), t.identifier(\"pow\"));\n\n/**\n * [Please add a description.]\n */\n\nvar visitor = _helpersBuildBinaryAssignmentOperatorTransformer2[\"default\"]({\n  operator: \"**\",\n\n  /**\n   * [Please add a description.]\n   */\n\n  build: function build(left, right) {\n    return t.callExpression(MATH_POW, [left, right]);\n  }\n});\nexports.visitor = visitor;","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _explodeAssignableExpression = require(\"./explode-assignable-expression\");\n\nvar _explodeAssignableExpression2 = _interopRequireDefault(_explodeAssignableExpression);\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nexports[\"default\"] = function (opts) {\n  var exports = {};\n\n  /**\n   * [Please add a description.]\n   */\n\n  var isAssignment = function isAssignment(node) {\n    return node.operator === opts.operator + \"=\";\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  var buildAssignment = function buildAssignment(left, right) {\n    return t.assignmentExpression(\"=\", left, right);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  exports.ExpressionStatement = function (node, parent, scope, file) {\n    // hit the `AssignmentExpression` one below\n    if (this.isCompletionRecord()) return;\n\n    var expr = node.expression;\n    if (!isAssignment(expr)) return;\n\n    var nodes = [];\n    var exploded = _explodeAssignableExpression2[\"default\"](expr.left, nodes, file, scope, true);\n\n    nodes.push(t.expressionStatement(buildAssignment(exploded.ref, opts.build(exploded.uid, expr.right))));\n\n    return nodes;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  exports.AssignmentExpression = function (node, parent, scope, file) {\n    if (!isAssignment(node)) return;\n\n    var nodes = [];\n    var exploded = _explodeAssignableExpression2[\"default\"](node.left, nodes, file, scope);\n    nodes.push(buildAssignment(exploded.ref, opts.build(exploded.uid, node.right)));\n    return nodes;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  exports.BinaryExpression = function (node) {\n    if (node.operator !== opts.operator) return;\n    return opts.build(node.left, node.right);\n  };\n\n  return exports;\n};\n\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nvar getObjRef = function getObjRef(node, nodes, file, scope) {\n  var ref;\n  if (t.isIdentifier(node)) {\n    if (scope.hasBinding(node.name)) {\n      // this variable is declared in scope so we can be 100% sure\n      // that evaluating it multiple times wont trigger a getter\n      // or something else\n      return node;\n    } else {\n      // could possibly trigger a getter so we need to only evaluate\n      // it once\n      ref = node;\n    }\n  } else if (t.isMemberExpression(node)) {\n    ref = node.object;\n\n    if (t.isIdentifier(ref) && scope.hasGlobal(ref.name)) {\n      // the object reference that we need to save is locally declared\n      // so as per the previous comment we can be 100% sure evaluating\n      // it multiple times will be safe\n      return ref;\n    }\n  } else {\n    throw new Error(\"We can't explode this node type \" + node.type);\n  }\n\n  var temp = scope.generateUidIdentifierBasedOnNode(ref);\n  nodes.push(t.variableDeclaration(\"var\", [t.variableDeclarator(temp, ref)]));\n  return temp;\n};\n\n/**\n * [Please add a description.]\n */\n\nvar getPropRef = function getPropRef(node, nodes, file, scope) {\n  var prop = node.property;\n  var key = t.toComputedKey(node, prop);\n  if (t.isLiteral(key)) return key;\n\n  var temp = scope.generateUidIdentifierBasedOnNode(prop);\n  nodes.push(t.variableDeclaration(\"var\", [t.variableDeclarator(temp, prop)]));\n  return temp;\n};\n\n/**\n * [Please add a description.]\n */\n\nexports[\"default\"] = function (node, nodes, file, scope, allowedSingleIdent) {\n  var obj;\n  if (t.isIdentifier(node) && allowedSingleIdent) {\n    obj = node;\n  } else {\n    obj = getObjRef(node, nodes, file, scope);\n  }\n\n  var ref, uid;\n\n  if (t.isIdentifier(node)) {\n    ref = node;\n    uid = obj;\n  } else {\n    var prop = getPropRef(node, nodes, file, scope);\n    var computed = node.computed || t.isLiteral(prop);\n    uid = ref = t.memberExpression(obj, prop, computed);\n  }\n\n  return {\n    uid: uid,\n    ref: ref\n  };\n};\n\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _helpersDefineMap = require(\"../../helpers/define-map\");\n\nvar defineMap = _interopRequireWildcard(_helpersDefineMap);\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * Turn [object initializer mutators](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#Method_definitions)\n * into `Object.defineProperties`.\n *\n * **In**\n *\n * ```javascript\n * var foo = {\n *   get bar() {\n *     return \"bar\";\n *   }\n * };\n * ```\n *\n * **Out**\n *\n * ```javascript\n * var foo = Object.defineProperties({}, {\n *   bar: {\n *     get: function () {\n *       return \"bar\";\n *     },\n *     enumerable: true,\n *     configurable: true\n *   }\n * });\n * ```\n */\n\nvar visitor = {\n\n  /**\n   * Look for getters and setters on an object.\n   * Filter them out and wrap the object with an `Object.defineProperties` that\n   * defines the getters and setters.\n   */\n\n  ObjectExpression: function ObjectExpression(node, parent, scope, file) {\n    var hasAny = false;\n    var _arr = node.properties;\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var prop = _arr[_i];\n      if (prop.kind === \"get\" || prop.kind === \"set\") {\n        hasAny = true;\n        break;\n      }\n    }\n    if (!hasAny) return;\n\n    var mutatorMap = {};\n\n    node.properties = node.properties.filter(function (prop) {\n      if (prop.kind === \"get\" || prop.kind === \"set\") {\n        defineMap.push(mutatorMap, prop, prop.kind, file);\n        return false;\n      } else {\n        return true;\n      }\n    });\n\n    return t.callExpression(t.memberExpression(t.identifier(\"Object\"), t.identifier(\"defineProperties\")), [node, defineMap.toDefineObject(mutatorMap)]);\n  }\n};\nexports.visitor = visitor;","/**\n * [Please add a description.]\n */\n\n\n\nexports.__esModule = true;\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  Property: function Property(node) {\n    if (node.method) {\n      node.method = false;\n    }\n\n    if (node.shorthand) {\n      node.shorthand = false;\n    }\n  }\n};\nexports.visitor = visitor;","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nfunction loose(node, body, objId) {\n  var _arr = node.properties;\n\n  for (var _i = 0; _i < _arr.length; _i++) {\n    var prop = _arr[_i];\n    body.push(t.expressionStatement(t.assignmentExpression(\"=\", t.memberExpression(objId, prop.key, prop.computed || t.isLiteral(prop.key)), prop.value)));\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction spec(node, body, objId, initProps, file) {\n  // add a simple assignment for all Symbol member expressions due to symbol polyfill limitations\n  // otherwise use Object.defineProperty\n\n  var _arr2 = node.properties;\n  for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n    var prop = _arr2[_i2];\n    // this wont work with Object.defineProperty\n    if (t.isLiteral(t.toComputedKey(prop), { value: \"__proto__\" })) {\n      initProps.push(prop);\n      continue;\n    }\n\n    var key = prop.key;\n    if (t.isIdentifier(key) && !prop.computed) {\n      key = t.literal(key.name);\n    }\n\n    var bodyNode = t.callExpression(file.addHelper(\"define-property\"), [objId, key, prop.value]);\n\n    body.push(t.expressionStatement(bodyNode));\n  }\n\n  // only one node and it's a Object.defineProperty that returns the object\n\n  if (body.length === 1) {\n    var first = body[0].expression;\n\n    if (t.isCallExpression(first)) {\n      first.arguments[0] = t.objectExpression(initProps);\n      return first;\n    }\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  ObjectExpression: {\n    exit: function exit(node, parent, scope, file) {\n      var hasComputed = false;\n\n      var _arr3 = node.properties;\n      for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n        var prop = _arr3[_i3];\n        hasComputed = t.isProperty(prop, { computed: true, kind: \"init\" });\n        if (hasComputed) break;\n      }\n\n      if (!hasComputed) return;\n\n      // put all getters/setters into the first object expression as well as all initialisers up\n      // to the first computed property\n\n      var initProps = [];\n      var stopInits = false;\n\n      node.properties = node.properties.filter(function (prop) {\n        if (prop.computed) {\n          stopInits = true;\n        }\n\n        if (prop.kind !== \"init\" || !stopInits) {\n          initProps.push(prop);\n          return false;\n        } else {\n          return true;\n        }\n      });\n\n      //\n\n      var objId = scope.generateUidIdentifierBasedOnNode(parent);\n\n      //\n\n      var body = [];\n\n      //\n\n      var callback = spec;\n      if (file.isLoose(\"es6.properties.computed\")) callback = loose;\n\n      var result = callback(node, body, objId, initProps, file);\n      if (result) return result;\n\n      //\n\n      body.unshift(t.variableDeclaration(\"var\", [t.variableDeclarator(objId, t.objectExpression(initProps))]));\n\n      body.push(t.expressionStatement(objId));\n\n      return body;\n    }\n  }\n};\nexports.visitor = visitor;","\n\nexports.__esModule = true;\n\nvar _es6ForOf = require(\"../es6/for-of\");\n\nvar metadata = {\n  optional: true\n};\n\nexports.metadata = metadata;\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  ForOfStatement: function ForOfStatement(node, parent, scope, file) {\n    if (this.get(\"right\").isGenericType(\"Array\")) {\n      return _es6ForOf._ForOfStatementArray.call(this, node, scope, file);\n    }\n  }\n};\nexports.visitor = visitor;","\n\nexports.__esModule = true;\nexports._ForOfStatementArray = _ForOfStatementArray;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _messages = require(\"../../../messages\");\n\nvar messages = _interopRequireWildcard(_messages);\n\nvar _util = require(\"../../../util\");\n\nvar util = _interopRequireWildcard(_util);\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  ForOfStatement: function ForOfStatement(node, parent, scope, file) {\n    if (this.get(\"right\").isArrayExpression()) {\n      return _ForOfStatementArray.call(this, node, scope, file);\n    }\n\n    var callback = spec;\n    if (file.isLoose(\"es6.forOf\")) callback = loose;\n\n    var build = callback(node, parent, scope, file);\n    var declar = build.declar;\n    var loop = build.loop;\n    var block = loop.body;\n\n    // ensure that it's a block so we can take all its statements\n    this.ensureBlock();\n\n    // add the value declaration to the new loop body\n    if (declar) {\n      block.body.push(declar);\n    }\n\n    // push the rest of the original loop body onto our new body\n    block.body = block.body.concat(node.body.body);\n\n    t.inherits(loop, node);\n    t.inherits(loop.body, node.body);\n\n    if (build.replaceParent) {\n      this.parentPath.replaceWithMultiple(build.node);\n      this.dangerouslyRemove();\n    } else {\n      return build.node;\n    }\n  }\n};\n\nexports.visitor = visitor;\n/**\n * [Please add a description.]\n */\n\nfunction _ForOfStatementArray(node, scope) {\n  var nodes = [];\n  var right = node.right;\n\n  if (!t.isIdentifier(right) || !scope.hasBinding(right.name)) {\n    var uid = scope.generateUidIdentifier(\"arr\");\n    nodes.push(t.variableDeclaration(\"var\", [t.variableDeclarator(uid, right)]));\n    right = uid;\n  }\n\n  var iterationKey = scope.generateUidIdentifier(\"i\");\n\n  var loop = util.template(\"for-of-array\", {\n    BODY: node.body,\n    KEY: iterationKey,\n    ARR: right\n  });\n\n  t.inherits(loop, node);\n  t.ensureBlock(loop);\n\n  var iterationValue = t.memberExpression(right, iterationKey, true);\n\n  var left = node.left;\n  if (t.isVariableDeclaration(left)) {\n    left.declarations[0].init = iterationValue;\n    loop.body.body.unshift(left);\n  } else {\n    loop.body.body.unshift(t.expressionStatement(t.assignmentExpression(\"=\", left, iterationValue)));\n  }\n\n  if (this.parentPath.isLabeledStatement()) {\n    loop = t.labeledStatement(this.parentPath.node.label, loop);\n  }\n\n  nodes.push(loop);\n\n  return nodes;\n}\n\n/**\n * [Please add a description.]\n */\n\nvar loose = function loose(node, parent, scope, file) {\n  var left = node.left;\n  var declar, id;\n\n  if (t.isIdentifier(left) || t.isPattern(left) || t.isMemberExpression(left)) {\n    // for (i of test), for ({ i } of test)\n    id = left;\n  } else if (t.isVariableDeclaration(left)) {\n    // for (var i of test)\n    id = scope.generateUidIdentifier(\"ref\");\n    declar = t.variableDeclaration(left.kind, [t.variableDeclarator(left.declarations[0].id, id)]);\n  } else {\n    throw file.errorWithNode(left, messages.get(\"unknownForHead\", left.type));\n  }\n\n  var iteratorKey = scope.generateUidIdentifier(\"iterator\");\n  var isArrayKey = scope.generateUidIdentifier(\"isArray\");\n\n  var loop = util.template(\"for-of-loose\", {\n    LOOP_OBJECT: iteratorKey,\n    IS_ARRAY: isArrayKey,\n    OBJECT: node.right,\n    INDEX: scope.generateUidIdentifier(\"i\"),\n    ID: id\n  });\n\n  if (!declar) {\n    // no declaration so we need to remove the variable declaration at the top of\n    // the for-of-loose template\n    loop.body.body.shift();\n  }\n\n  //\n\n  return {\n    declar: declar,\n    node: loop,\n    loop: loop\n  };\n};\n\n/**\n * [Please add a description.]\n */\n\nvar spec = function spec(node, parent, scope, file) {\n  var left = node.left;\n  var declar;\n\n  var stepKey = scope.generateUidIdentifier(\"step\");\n  var stepValue = t.memberExpression(stepKey, t.identifier(\"value\"));\n\n  if (t.isIdentifier(left) || t.isPattern(left) || t.isMemberExpression(left)) {\n    // for (i of test), for ({ i } of test)\n    declar = t.expressionStatement(t.assignmentExpression(\"=\", left, stepValue));\n  } else if (t.isVariableDeclaration(left)) {\n    // for (var i of test)\n    declar = t.variableDeclaration(left.kind, [t.variableDeclarator(left.declarations[0].id, stepValue)]);\n  } else {\n    throw file.errorWithNode(left, messages.get(\"unknownForHead\", left.type));\n  }\n\n  //\n\n  var iteratorKey = scope.generateUidIdentifier(\"iterator\");\n\n  var template = util.template(\"for-of\", {\n    ITERATOR_HAD_ERROR_KEY: scope.generateUidIdentifier(\"didIteratorError\"),\n    ITERATOR_COMPLETION: scope.generateUidIdentifier(\"iteratorNormalCompletion\"),\n    ITERATOR_ERROR_KEY: scope.generateUidIdentifier(\"iteratorError\"),\n    ITERATOR_KEY: iteratorKey,\n    STEP_KEY: stepKey,\n    OBJECT: node.right,\n    BODY: null\n  });\n\n  var isLabeledParent = t.isLabeledStatement(parent);\n\n  var tryBody = template[3].block.body;\n  var loop = tryBody[0];\n\n  if (isLabeledParent) {\n    tryBody[0] = t.labeledStatement(parent.label, loop);\n  }\n\n  //\n\n  return {\n    replaceParent: isLabeledParent,\n    declar: declar,\n    loop: loop,\n    node: template\n  };\n};","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _helpersRegex = require(\"../../helpers/regex\");\n\nvar regex = _interopRequireWildcard(_helpersRegex);\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  Literal: function Literal(node) {\n    if (!regex.is(node, \"y\")) return;\n    return t.newExpression(t.identifier(\"RegExp\"), [t.literal(node.regex.pattern), t.literal(node.regex.flags)]);\n  }\n};\nexports.visitor = visitor;","\n\nexports.__esModule = true;\nexports.is = is;\nexports.pullFlag = pullFlag;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _lodashArrayPull = require(\"lodash/array/pull\");\n\nvar _lodashArrayPull2 = _interopRequireDefault(_lodashArrayPull);\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nfunction is(node, flag) {\n  return t.isLiteral(node) && node.regex && node.regex.flags.indexOf(flag) >= 0;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction pullFlag(node, flag) {\n  var flags = node.regex.flags.split(\"\");\n  if (node.regex.flags.indexOf(flag) < 0) return;\n  _lodashArrayPull2[\"default\"](flags, flag);\n  node.regex.flags = flags.join(\"\");\n}","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _regexpuRewritePattern = require(\"regexpu/rewrite-pattern\");\n\nvar _regexpuRewritePattern2 = _interopRequireDefault(_regexpuRewritePattern);\n\nvar _helpersRegex = require(\"../../helpers/regex\");\n\nvar regex = _interopRequireWildcard(_helpersRegex);\n\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  Literal: function Literal(node) {\n    if (!regex.is(node, \"u\")) return;\n    node.regex.pattern = _regexpuRewritePattern2[\"default\"](node.regex.pattern, node.regex.flags);\n    regex.pullFlag(node, \"u\");\n  }\n};\nexports.visitor = visitor;","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _messages = require(\"../../../messages\");\n\nvar messages = _interopRequireWildcard(_messages);\n\n/**\n * Turn constants into variables.\n * Ensure there are no constant violations in any scope.\n *\n * @example\n *\n * **In**\n *\n * ```javascript\n * const MULTIPLIER = 5;\n * ```\n *\n * **Out**\n *\n * ```javascript\n * var MULTIPLIER = 5;\n * ```\n */\n\nvar visitor = {\n\n  /**\n   * Look for any constants (or modules) in scope.\n   * If they have any `constantViolations` throw an error.\n   */\n\n  Scope: function Scope(node, parent, scope) {\n    for (var name in scope.bindings) {\n      var binding = scope.bindings[name];\n\n      // not a constant\n      if (binding.kind !== \"const\" && binding.kind !== \"module\") continue;\n\n      var _arr = binding.constantViolations;\n      for (var _i = 0; _i < _arr.length; _i++) {\n        var violation = _arr[_i];\n        throw violation.errorWithNode(messages.get(\"readOnly\", name));\n      }\n    }\n  },\n\n  /**\n   * Look for constants.\n   * Turn them into `let` variables.\n   */\n\n  VariableDeclaration: function VariableDeclaration(node) {\n    if (node.kind === \"const\") node.kind = \"let\";\n  }\n};\nexports.visitor = visitor;","// https://github.com/leebyron/ecmascript-more-export-from\n\n\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\nvar metadata = {\n  stage: 1\n};\n\nexports.metadata = metadata;\n/**\n * [Please add a description.]\n */\n\nfunction build(node, nodes, scope) {\n  var first = node.specifiers[0];\n  if (!t.isExportNamespaceSpecifier(first) && !t.isExportDefaultSpecifier(first)) return;\n\n  var specifier = node.specifiers.shift();\n  var uid = scope.generateUidIdentifier(specifier.exported.name);\n\n  var newSpecifier;\n  if (t.isExportNamespaceSpecifier(specifier)) {\n    newSpecifier = t.importNamespaceSpecifier(uid);\n  } else {\n    newSpecifier = t.importDefaultSpecifier(uid);\n  }\n\n  nodes.push(t.importDeclaration([newSpecifier], node.source));\n  nodes.push(t.exportNamedDeclaration(null, [t.exportSpecifier(uid, specifier.exported)]));\n\n  build(node, nodes, scope);\n}\n\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  ExportNamedDeclaration: function ExportNamedDeclaration(node, parent, scope) {\n    var nodes = [];\n    build(node, nodes, scope);\n    if (!nodes.length) return;\n\n    if (node.specifiers.length >= 1) {\n      nodes.push(node);\n    }\n\n    return nodes;\n  }\n};\nexports.visitor = visitor;","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\nvar metadata = {\n  optional: true,\n  stage: 0\n};\n\nexports.metadata = metadata;\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  DoExpression: function DoExpression(node) {\n    var body = node.body.body;\n    if (body.length) {\n      return body;\n    } else {\n      return t.identifier(\"undefined\");\n    }\n  }\n};\nexports.visitor = visitor;","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\nvar metadata = {\n  optional: true\n};\n\nexports.metadata = metadata;\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  UnaryExpression: function UnaryExpression(node, parent, scope, file) {\n    if (node._ignoreSpecSymbols) return;\n\n    if (this.parentPath.isBinaryExpression() && t.EQUALITY_BINARY_OPERATORS.indexOf(parent.operator) >= 0) {\n      // optimise `typeof foo === \"string\"` since we can determine that they'll never need to handle symbols\n      var opposite = this.getOpposite();\n      if (opposite.isLiteral() && opposite.node.value !== \"symbol\" && opposite.node.value !== \"object\") return;\n    }\n\n    if (node.operator === \"typeof\") {\n      var call = t.callExpression(file.addHelper(\"typeof\"), [node.argument]);\n      if (this.get(\"argument\").isIdentifier()) {\n        var undefLiteral = t.literal(\"undefined\");\n        var unary = t.unaryExpression(\"typeof\", node.argument);\n        unary._ignoreSpecSymbols = true;\n        return t.conditionalExpression(t.binaryExpression(\"===\", unary, undefLiteral), undefLiteral, call);\n      } else {\n        return call;\n      }\n    }\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  BinaryExpression: function BinaryExpression(node, parent, scope, file) {\n    if (node.operator === \"instanceof\") {\n      return t.callExpression(file.addHelper(\"instanceof\"), [node.left, node.right]);\n    }\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  \"VariableDeclaration|FunctionDeclaration\": function VariableDeclarationFunctionDeclaration(node) {\n    if (node._generated) this.skip();\n  }\n};\nexports.visitor = visitor;","// https://github.com/zenparsing/es-function-bind\n\n\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\nvar metadata = {\n  optional: true,\n  stage: 0\n};\n\nexports.metadata = metadata;\n/**\n * [Please add a description.]\n */\n\nfunction getTempId(scope) {\n  var id = scope.path.getData(\"functionBind\");\n  if (id) return id;\n\n  id = scope.generateDeclaredUidIdentifier(\"context\");\n  return scope.path.setData(\"functionBind\", id);\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction getStaticContext(bind, scope) {\n  var object = bind.object || bind.callee.object;\n  return scope.isStatic(object) && object;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction inferBindContext(bind, scope) {\n  var staticContext = getStaticContext(bind, scope);\n  if (staticContext) return staticContext;\n\n  var tempId = getTempId(scope);\n  if (bind.object) {\n    bind.callee = t.sequenceExpression([t.assignmentExpression(\"=\", tempId, bind.object), bind.callee]);\n  } else {\n    bind.callee.object = t.assignmentExpression(\"=\", tempId, bind.callee.object);\n  }\n  return tempId;\n}\n\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  CallExpression: function CallExpression(node, parent, scope) {\n    var bind = node.callee;\n    if (!t.isBindExpression(bind)) return;\n\n    var context = inferBindContext(bind, scope);\n    node.callee = t.memberExpression(bind.callee, t.identifier(\"call\"));\n    node.arguments.unshift(context);\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  BindExpression: function BindExpression(node, parent, scope) {\n    var context = inferBindContext(node, scope);\n    return t.callExpression(t.memberExpression(node.callee, t.identifier(\"bind\")), [context]);\n  }\n};\nexports.visitor = visitor;","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nfunction getSpreadLiteral(spread, scope) {\n  if (scope.hub.file.isLoose(\"es6.spread\") && !t.isIdentifier(spread.argument, { name: \"arguments\" })) {\n    return spread.argument;\n  } else {\n    return scope.toArray(spread.argument, true);\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction hasSpread(nodes) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (t.isSpreadElement(nodes[i])) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction build(props, scope) {\n  var nodes = [];\n\n  var _props = [];\n\n  var push = function push() {\n    if (!_props.length) return;\n    nodes.push(t.arrayExpression(_props));\n    _props = [];\n  };\n\n  for (var i = 0; i < props.length; i++) {\n    var prop = props[i];\n    if (t.isSpreadElement(prop)) {\n      push();\n      nodes.push(getSpreadLiteral(prop, scope));\n    } else {\n      _props.push(prop);\n    }\n  }\n\n  push();\n\n  return nodes;\n}\n\nvar metadata = {\n  group: \"builtin-advanced\"\n};\n\nexports.metadata = metadata;\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  ArrayExpression: function ArrayExpression(node, parent, scope) {\n    var elements = node.elements;\n    if (!hasSpread(elements)) return;\n\n    var nodes = build(elements, scope);\n    var first = nodes.shift();\n\n    if (!t.isArrayExpression(first)) {\n      nodes.unshift(first);\n      first = t.arrayExpression([]);\n    }\n\n    return t.callExpression(t.memberExpression(first, t.identifier(\"concat\")), nodes);\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  CallExpression: function CallExpression(node, parent, scope) {\n    var args = node.arguments;\n    if (!hasSpread(args)) return;\n\n    var contextLiteral = t.identifier(\"undefined\");\n\n    node.arguments = [];\n\n    var nodes;\n    if (args.length === 1 && args[0].argument.name === \"arguments\") {\n      nodes = [args[0].argument];\n    } else {\n      nodes = build(args, scope);\n    }\n\n    var first = nodes.shift();\n    if (nodes.length) {\n      node.arguments.push(t.callExpression(t.memberExpression(first, t.identifier(\"concat\")), nodes));\n    } else {\n      node.arguments.push(first);\n    }\n\n    var callee = node.callee;\n\n    if (this.get(\"callee\").isMemberExpression()) {\n      var temp = scope.maybeGenerateMemoised(callee.object);\n      if (temp) {\n        callee.object = t.assignmentExpression(\"=\", temp, callee.object);\n        contextLiteral = temp;\n      } else {\n        contextLiteral = callee.object;\n      }\n      t.appendToMemberExpression(callee, t.identifier(\"apply\"));\n    } else {\n      node.callee = t.memberExpression(node.callee, t.identifier(\"apply\"));\n    }\n\n    node.arguments.unshift(contextLiteral);\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  NewExpression: function NewExpression(node, parent, scope, file) {\n    var args = node.arguments;\n    if (!hasSpread(args)) return;\n\n    var nodes = build(args, scope);\n\n    var context = t.arrayExpression([t.literal(null)]);\n\n    args = t.callExpression(t.memberExpression(context, t.identifier(\"concat\")), nodes);\n\n    return t.newExpression(t.callExpression(t.memberExpression(file.addHelper(\"bind\"), t.identifier(\"apply\")), [node.callee, args]), []);\n  }\n};\nexports.visitor = visitor;","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _traversalVisitors = require(\"../../../../traversal/visitors\");\n\nvar visitors = _interopRequireWildcard(_traversalVisitors);\n\nvar _default = require(\"./default\");\n\nvar def = _interopRequireWildcard(_default);\n\nvar _rest = require(\"./rest\");\n\nvar rest = _interopRequireWildcard(_rest);\n\nvar metadata = {\n  group: \"builtin-advanced\"\n};\n\nexports.metadata = metadata;\n/**\n * [Please add a description.]\n */\n\nvar visitor = visitors.merge([rest.visitor, def.visitor]);\nexports.visitor = visitor;","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _helpersCallDelegate = require(\"../../../helpers/call-delegate\");\n\nvar _helpersCallDelegate2 = _interopRequireDefault(_helpersCallDelegate);\n\nvar _helpersGetFunctionArity = require(\"../../../helpers/get-function-arity\");\n\nvar _helpersGetFunctionArity2 = _interopRequireDefault(_helpersGetFunctionArity);\n\nvar _util = require(\"../../../../util\");\n\nvar util = _interopRequireWildcard(_util);\n\nvar _types = require(\"../../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nvar hasDefaults = function hasDefaults(node) {\n  for (var i = 0; i < node.params.length; i++) {\n    if (!t.isIdentifier(node.params[i])) return true;\n  }\n  return false;\n};\n\n/**\n * [Please add a description.]\n */\n\nvar iifeVisitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope, state) {\n    if (node.name !== \"eval\") {\n      if (!state.scope.hasOwnBinding(node.name)) return;\n      if (state.scope.bindingIdentifierEquals(node.name, node)) return;\n    }\n\n    state.iife = true;\n    this.stop();\n  }\n};\n\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  Function: function Function(node, parent, scope, file) {\n    if (!hasDefaults(node)) return;\n\n    // ensure it's a block, useful for arrow functions\n    this.ensureBlock();\n\n    var state = {\n      iife: false,\n      scope: scope\n    };\n\n    var body = [];\n\n    //\n    var argsIdentifier = t.identifier(\"arguments\");\n    argsIdentifier._shadowedFunctionLiteral = this;\n\n    // push a default parameter definition\n    function pushDefNode(left, right, i) {\n      var defNode;\n      if (exceedsLastNonDefault(i) || t.isPattern(left) || file.transformers[\"es6.spec.blockScoping\"].canTransform()) {\n        defNode = util.template(\"default-parameter\", {\n          VARIABLE_NAME: left,\n          DEFAULT_VALUE: right,\n          ARGUMENT_KEY: t.literal(i),\n          ARGUMENTS: argsIdentifier\n        }, true);\n      } else {\n        defNode = util.template(\"default-parameter-assign\", {\n          VARIABLE_NAME: left,\n          DEFAULT_VALUE: right\n        }, true);\n      }\n      defNode._blockHoist = node.params.length - i;\n      body.push(defNode);\n    }\n\n    // check if an index exceeds the functions arity\n    function exceedsLastNonDefault(i) {\n      return i + 1 > lastNonDefaultParam;\n    }\n\n    //\n    var lastNonDefaultParam = _helpersGetFunctionArity2[\"default\"](node);\n\n    //\n    var params = this.get(\"params\");\n    for (var i = 0; i < params.length; i++) {\n      var param = params[i];\n\n      if (!param.isAssignmentPattern()) {\n        if (!param.isIdentifier()) {\n          param.traverse(iifeVisitor, state);\n        }\n\n        if (file.transformers[\"es6.spec.blockScoping\"].canTransform() && param.isIdentifier()) {\n          pushDefNode(param.node, t.identifier(\"undefined\"), i);\n        }\n\n        continue;\n      }\n\n      var left = param.get(\"left\");\n      var right = param.get(\"right\");\n\n      if (exceedsLastNonDefault(i) || left.isPattern()) {\n        var placeholder = scope.generateUidIdentifier(\"x\");\n        placeholder._isDefaultPlaceholder = true;\n        node.params[i] = placeholder;\n      } else {\n        node.params[i] = left.node;\n      }\n\n      if (!state.iife) {\n        if (right.isIdentifier() && scope.hasOwnBinding(right.node.name)) {\n          state.iife = true;\n        } else {\n          right.traverse(iifeVisitor, state);\n        }\n      }\n\n      pushDefNode(left.node, right.node, i);\n    }\n\n    // we need to cut off all trailing default parameters\n    node.params = node.params.slice(0, lastNonDefaultParam);\n\n    if (state.iife) {\n      body.push(_helpersCallDelegate2[\"default\"](node, scope));\n      node.body = t.blockStatement(body);\n    } else {\n      node.body.body = body.concat(node.body.body);\n    }\n  }\n};\nexports.visitor = visitor;","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  enter: function enter(node, parent, scope, state) {\n    if (this.isThisExpression() || this.isReferencedIdentifier({ name: \"arguments\" })) {\n      state.found = true;\n      this.stop();\n    }\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  Function: function Function() {\n    this.skip();\n  }\n};\n\n/**\n * [Please add a description.]\n */\n\nexports[\"default\"] = function (node, scope) {\n  var container = t.functionExpression(null, [], node.body, node.generator, node.async);\n\n  var callee = container;\n  var args = [];\n\n  var state = { found: false };\n  scope.traverse(node, visitor, state);\n  if (state.found) {\n    callee = t.memberExpression(container, t.identifier(\"apply\"));\n    args = [t.thisExpression(), t.identifier(\"arguments\")];\n  }\n\n  var call = t.callExpression(callee, args);\n  if (node.generator) call = t.yieldExpression(call, true);\n\n  return t.returnStatement(call);\n};\n\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _util = require(\"../../../../util\");\n\nvar util = _interopRequireWildcard(_util);\n\nvar _types = require(\"../../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nvar memberExpressionOptimisationVisitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  Scope: function Scope(node, parent, scope, state) {\n    // check if this scope has a local binding that will shadow the rest parameter\n    if (!scope.bindingIdentifierEquals(state.name, state.outerBinding)) {\n      this.skip();\n    }\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  Flow: function Flow() {\n    // don't touch reference in type annotations\n    this.skip();\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  Function: function Function(node, parent, scope, state) {\n    // skip over functions as whatever `arguments` we reference inside will refer\n    // to the wrong function\n    var oldNoOptimise = state.noOptimise;\n    state.noOptimise = true;\n    this.traverse(memberExpressionOptimisationVisitor, state);\n    state.noOptimise = oldNoOptimise;\n    this.skip();\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope, state) {\n    // we can't guarantee the purity of arguments\n    if (node.name === \"arguments\") {\n      state.deopted = true;\n    }\n\n    // is this a referenced identifier and is it referencing the rest parameter?\n    if (node.name !== state.name) return;\n\n    if (state.noOptimise) {\n      state.deopted = true;\n    } else {\n      if (this.parentPath.isMemberExpression({ computed: true, object: node })) {\n        // if we know that this member expression is referencing a number then we can safely\n        // optimise it\n        var prop = this.parentPath.get(\"property\");\n        if (prop.isBaseType(\"number\")) {\n          state.candidates.push(this);\n          return;\n        }\n      }\n\n      // optimise single spread args in calls\n      if (this.parentPath.isSpreadElement() && state.offset === 0) {\n        var call = this.parentPath.parentPath;\n        if (call.isCallExpression() && call.node.arguments.length === 1) {\n          state.candidates.push(this);\n          return;\n        }\n      }\n\n      state.references.push(this);\n    }\n  },\n\n  /**\n   * Deopt on use of a binding identifier with the same name as our rest param.\n   *\n   * See https://github.com/babel/babel/issues/2091\n   */\n\n  BindingIdentifier: function BindingIdentifier(node, parent, scope, state) {\n    if (node.name === state.name) {\n      state.deopted = true;\n    }\n  }\n};\n\n/**\n * [Please add a description.]\n */\n\nfunction optimiseMemberExpression(parent, offset) {\n  if (offset === 0) return;\n\n  var newExpr;\n  var prop = parent.property;\n\n  if (t.isLiteral(prop)) {\n    prop.value += offset;\n    prop.raw = String(prop.value);\n  } else {\n    // // UnaryExpression, BinaryExpression\n    newExpr = t.binaryExpression(\"+\", prop, t.literal(offset));\n    parent.property = newExpr;\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction hasRest(node) {\n  return t.isRestElement(node.params[node.params.length - 1]);\n}\n\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  Function: function Function(node, parent, scope) {\n    if (!hasRest(node)) return;\n\n    var restParam = node.params.pop();\n    var rest = restParam.argument;\n\n    var argsId = t.identifier(\"arguments\");\n\n    // otherwise `arguments` will be remapped in arrow functions\n    argsId._shadowedFunctionLiteral = this;\n\n    // support patterns\n    if (t.isPattern(rest)) {\n      var pattern = rest;\n      rest = scope.generateUidIdentifier(\"ref\");\n\n      var declar = t.variableDeclaration(\"let\", pattern.elements.map(function (elem, index) {\n        var accessExpr = t.memberExpression(rest, t.literal(index), true);\n        return t.variableDeclarator(elem, accessExpr);\n      }));\n      node.body.body.unshift(declar);\n    }\n\n    // check and optimise for extremely common cases\n    var state = {\n      references: [],\n      offset: node.params.length,\n\n      argumentsNode: argsId,\n      outerBinding: scope.getBindingIdentifier(rest.name),\n\n      // candidate member expressions we could optimise if there are no other references\n      candidates: [],\n\n      // local rest binding name\n      name: rest.name,\n\n      // whether any references to the rest parameter were made in a function\n      deopted: false\n    };\n\n    this.traverse(memberExpressionOptimisationVisitor, state);\n\n    if (!state.deopted && !state.references.length) {\n      // we only have shorthands and there are no other references\n      if (state.candidates.length) {\n        var _arr = state.candidates;\n\n        for (var _i = 0; _i < _arr.length; _i++) {\n          var candidate = _arr[_i];\n          candidate.replaceWith(argsId);\n          if (candidate.parentPath.isMemberExpression()) {\n            optimiseMemberExpression(candidate.parent, state.offset);\n          }\n        }\n      }\n      return;\n    } else {\n      state.references = state.references.concat(state.candidates);\n    }\n\n    // deopt shadowed functions as transforms like regenerator may try touch the allocation loop\n    state.deopted = state.deopted || !!node.shadow;\n\n    //\n\n    var start = t.literal(node.params.length);\n    var key = scope.generateUidIdentifier(\"key\");\n    var len = scope.generateUidIdentifier(\"len\");\n\n    var arrKey = key;\n    var arrLen = len;\n    if (node.params.length) {\n      // this method has additional params, so we need to subtract\n      // the index of the current argument position from the\n      // position in the array that we want to populate\n      arrKey = t.binaryExpression(\"-\", key, start);\n\n      // we need to work out the size of the array that we're\n      // going to store all the rest parameters\n      //\n      // we need to add a check to avoid constructing the array\n      // with <0 if there are less arguments than params as it'll\n      // cause an error\n      arrLen = t.conditionalExpression(t.binaryExpression(\">\", len, start), t.binaryExpression(\"-\", len, start), t.literal(0));\n    }\n\n    var loop = util.template(\"rest\", {\n      ARRAY_TYPE: restParam.typeAnnotation,\n      ARGUMENTS: argsId,\n      ARRAY_KEY: arrKey,\n      ARRAY_LEN: arrLen,\n      START: start,\n      ARRAY: rest,\n      KEY: key,\n      LEN: len\n    });\n\n    if (state.deopted) {\n      loop._blockHoist = node.params.length + 1;\n      node.body.body.unshift(loop);\n    } else {\n      // perform allocation at the lowest common denominator of all references\n      loop._blockHoist = 1;\n\n      var target = this.getEarliestCommonAncestorFrom(state.references).getStatementParent();\n\n      // don't perform the allocation inside a loop\n      var highestLoop;\n      target.findParent(function (path) {\n        if (path.isLoop()) {\n          highestLoop = path;\n        } else if (path.isFunction()) {\n          // stop crawling up for functions\n          return true;\n        }\n      });\n      if (highestLoop) target = highestLoop;\n\n      target.insertBefore(loop);\n    }\n  }\n};\nexports.visitor = visitor;","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _messages = require(\"../../../messages\");\n\nvar messages = _interopRequireWildcard(_messages);\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\nvar metadata = {\n  group: \"builtin-advanced\"\n};\n\nexports.metadata = metadata;\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  ForXStatement: function ForXStatement(node, parent, scope, file) {\n    var left = node.left;\n\n    if (t.isPattern(left)) {\n      // for ({ length: k } in { abc: 3 });\n\n      var temp = scope.generateUidIdentifier(\"ref\");\n\n      node.left = t.variableDeclaration(\"var\", [t.variableDeclarator(temp)]);\n\n      this.ensureBlock();\n\n      node.body.body.unshift(t.variableDeclaration(\"var\", [t.variableDeclarator(left, temp)]));\n\n      return;\n    }\n\n    if (!t.isVariableDeclaration(left)) return;\n\n    var pattern = left.declarations[0].id;\n    if (!t.isPattern(pattern)) return;\n\n    var key = scope.generateUidIdentifier(\"ref\");\n    node.left = t.variableDeclaration(left.kind, [t.variableDeclarator(key, null)]);\n\n    var nodes = [];\n\n    var destructuring = new DestructuringTransformer({\n      kind: left.kind,\n      file: file,\n      scope: scope,\n      nodes: nodes\n    });\n\n    destructuring.init(pattern, key);\n\n    this.ensureBlock();\n\n    var block = node.body;\n    block.body = nodes.concat(block.body);\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  Function: function Function(node, parent, scope, file) {\n    var hasDestructuring = false;\n    var _arr = node.params;\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var pattern = _arr[_i];\n      if (t.isPattern(pattern)) {\n        hasDestructuring = true;\n        break;\n      }\n    }\n    if (!hasDestructuring) return;\n\n    var nodes = [];\n\n    for (var i = 0; i < node.params.length; i++) {\n      var pattern = node.params[i];\n      if (!t.isPattern(pattern)) continue;\n\n      var ref = scope.generateUidIdentifier(\"ref\");\n      if (t.isAssignmentPattern(pattern)) {\n        var _pattern = pattern;\n        pattern = pattern.left;\n        _pattern.left = ref;\n      } else {\n        node.params[i] = ref;\n      }\n\n      t.inherits(ref, pattern);\n\n      var destructuring = new DestructuringTransformer({\n        blockHoist: node.params.length - i,\n        nodes: nodes,\n        scope: scope,\n        file: file,\n        kind: \"let\"\n      });\n\n      destructuring.init(pattern, ref);\n    }\n\n    this.ensureBlock();\n\n    var block = node.body;\n    block.body = nodes.concat(block.body);\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  CatchClause: function CatchClause(node, parent, scope, file) {\n    var pattern = node.param;\n    if (!t.isPattern(pattern)) return;\n\n    var ref = scope.generateUidIdentifier(\"ref\");\n    node.param = ref;\n\n    var nodes = [];\n\n    var destructuring = new DestructuringTransformer({\n      kind: \"let\",\n      file: file,\n      scope: scope,\n      nodes: nodes\n    });\n    destructuring.init(pattern, ref);\n\n    node.body.body = nodes.concat(node.body.body);\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  AssignmentExpression: function AssignmentExpression(node, parent, scope, file) {\n    if (!t.isPattern(node.left)) return;\n\n    var nodes = [];\n\n    var destructuring = new DestructuringTransformer({\n      operator: node.operator,\n      file: file,\n      scope: scope,\n      nodes: nodes\n    });\n\n    var ref;\n    if (this.isCompletionRecord() || !this.parentPath.isExpressionStatement()) {\n      ref = scope.generateUidIdentifierBasedOnNode(node.right, \"ref\");\n\n      nodes.push(t.variableDeclaration(\"var\", [t.variableDeclarator(ref, node.right)]));\n\n      if (t.isArrayExpression(node.right)) {\n        destructuring.arrays[ref.name] = true;\n      }\n    }\n\n    destructuring.init(node.left, ref || node.right);\n\n    if (ref) {\n      nodes.push(t.expressionStatement(ref));\n    }\n\n    return nodes;\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  VariableDeclaration: function VariableDeclaration(node, parent, scope, file) {\n    if (t.isForXStatement(parent)) return;\n    if (!variableDeclarationHasPattern(node)) return;\n\n    var nodes = [];\n    var declar;\n\n    for (var i = 0; i < node.declarations.length; i++) {\n      declar = node.declarations[i];\n\n      var patternId = declar.init;\n      var pattern = declar.id;\n\n      var destructuring = new DestructuringTransformer({\n        nodes: nodes,\n        scope: scope,\n        kind: node.kind,\n        file: file\n      });\n\n      if (t.isPattern(pattern)) {\n        destructuring.init(pattern, patternId);\n\n        if (+i !== node.declarations.length - 1) {\n          // we aren't the last declarator so let's just make the\n          // last transformed node inherit from us\n          t.inherits(nodes[nodes.length - 1], declar);\n        }\n      } else {\n        nodes.push(t.inherits(destructuring.buildVariableAssignment(declar.id, declar.init), declar));\n      }\n    }\n\n    if (!t.isProgram(parent) && !t.isBlockStatement(parent)) {\n      // https://github.com/babel/babel/issues/113\n      // for (let [x] = [0]; false;) {}\n\n      declar = null;\n\n      for (i = 0; i < nodes.length; i++) {\n        node = nodes[i];\n        declar = declar || t.variableDeclaration(node.kind, []);\n\n        if (!t.isVariableDeclaration(node) && declar.kind !== node.kind) {\n          throw file.errorWithNode(node, messages.get(\"invalidParentForThisNode\"));\n        }\n\n        declar.declarations = declar.declarations.concat(node.declarations);\n      }\n\n      return declar;\n    }\n\n    return nodes;\n  }\n};\n\nexports.visitor = visitor;\n/**\n * Test if a VariableDeclaration's declarations contains any Patterns.\n */\n\nfunction variableDeclarationHasPattern(node) {\n  for (var i = 0; i < node.declarations.length; i++) {\n    if (t.isPattern(node.declarations[i].id)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Test if an ArrayPattern's elements contain any RestElements.\n */\n\nfunction hasRest(pattern) {\n  for (var i = 0; i < pattern.elements.length; i++) {\n    if (t.isRestElement(pattern.elements[i])) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * [Please add a description.]\n */\n\nvar arrayUnpackVisitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope, state) {\n    if (state.bindings[node.name]) {\n      state.deopt = true;\n      this.stop();\n    }\n  }\n};\n\n/**\n * [Please add a description.]\n */\n\nvar DestructuringTransformer = (function () {\n  function DestructuringTransformer(opts) {\n    _classCallCheck(this, DestructuringTransformer);\n\n    this.blockHoist = opts.blockHoist;\n    this.operator = opts.operator;\n    this.arrays = {};\n    this.nodes = opts.nodes || [];\n    this.scope = opts.scope;\n    this.file = opts.file;\n    this.kind = opts.kind;\n  }\n\n  /**\n   * [Please add a description.]\n   */\n\n  DestructuringTransformer.prototype.buildVariableAssignment = function buildVariableAssignment(id, init) {\n    var op = this.operator;\n    if (t.isMemberExpression(id)) op = \"=\";\n\n    var node;\n\n    if (op) {\n      node = t.expressionStatement(t.assignmentExpression(op, id, init));\n    } else {\n      node = t.variableDeclaration(this.kind, [t.variableDeclarator(id, init)]);\n    }\n\n    node._blockHoist = this.blockHoist;\n\n    return node;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  DestructuringTransformer.prototype.buildVariableDeclaration = function buildVariableDeclaration(id, init) {\n    var declar = t.variableDeclaration(\"var\", [t.variableDeclarator(id, init)]);\n    declar._blockHoist = this.blockHoist;\n    return declar;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  DestructuringTransformer.prototype.push = function push(id, init) {\n    if (t.isObjectPattern(id)) {\n      this.pushObjectPattern(id, init);\n    } else if (t.isArrayPattern(id)) {\n      this.pushArrayPattern(id, init);\n    } else if (t.isAssignmentPattern(id)) {\n      this.pushAssignmentPattern(id, init);\n    } else {\n      this.nodes.push(this.buildVariableAssignment(id, init));\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  DestructuringTransformer.prototype.toArray = function toArray(node, count) {\n    if (this.file.isLoose(\"es6.destructuring\") || t.isIdentifier(node) && this.arrays[node.name]) {\n      return node;\n    } else {\n      return this.scope.toArray(node, count);\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  DestructuringTransformer.prototype.pushAssignmentPattern = function pushAssignmentPattern(pattern, valueRef) {\n    // we need to assign the current value of the assignment to avoid evaluating\n    // it more than once\n\n    var tempValueRef = this.scope.generateUidIdentifierBasedOnNode(valueRef);\n\n    var declar = t.variableDeclaration(\"var\", [t.variableDeclarator(tempValueRef, valueRef)]);\n    declar._blockHoist = this.blockHoist;\n    this.nodes.push(declar);\n\n    //\n\n    var tempConditional = t.conditionalExpression(t.binaryExpression(\"===\", tempValueRef, t.identifier(\"undefined\")), pattern.right, tempValueRef);\n\n    var left = pattern.left;\n    if (t.isPattern(left)) {\n      var tempValueDefault = t.expressionStatement(t.assignmentExpression(\"=\", tempValueRef, tempConditional));\n      tempValueDefault._blockHoist = this.blockHoist;\n\n      this.nodes.push(tempValueDefault);\n      this.push(left, tempValueRef);\n    } else {\n      this.nodes.push(this.buildVariableAssignment(left, tempConditional));\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  DestructuringTransformer.prototype.pushObjectSpread = function pushObjectSpread(pattern, objRef, spreadProp, spreadPropIndex) {\n    // get all the keys that appear in this object before the current spread\n\n    var keys = [];\n\n    for (var i = 0; i < pattern.properties.length; i++) {\n      var prop = pattern.properties[i];\n\n      // we've exceeded the index of the spread property to all properties to the\n      // right need to be ignored\n      if (i >= spreadPropIndex) break;\n\n      // ignore other spread properties\n      if (t.isSpreadProperty(prop)) continue;\n\n      var key = prop.key;\n      if (t.isIdentifier(key) && !prop.computed) key = t.literal(prop.key.name);\n      keys.push(key);\n    }\n\n    keys = t.arrayExpression(keys);\n\n    //\n\n    var value = t.callExpression(this.file.addHelper(\"object-without-properties\"), [objRef, keys]);\n    this.nodes.push(this.buildVariableAssignment(spreadProp.argument, value));\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  DestructuringTransformer.prototype.pushObjectProperty = function pushObjectProperty(prop, propRef) {\n    if (t.isLiteral(prop.key)) prop.computed = true;\n\n    var pattern = prop.value;\n    var objRef = t.memberExpression(propRef, prop.key, prop.computed);\n\n    if (t.isPattern(pattern)) {\n      this.push(pattern, objRef);\n    } else {\n      this.nodes.push(this.buildVariableAssignment(pattern, objRef));\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  DestructuringTransformer.prototype.pushObjectPattern = function pushObjectPattern(pattern, objRef) {\n    // https://github.com/babel/babel/issues/681\n\n    if (!pattern.properties.length) {\n      this.nodes.push(t.expressionStatement(t.callExpression(this.file.addHelper(\"object-destructuring-empty\"), [objRef])));\n    }\n\n    // if we have more than one properties in this pattern and the objectRef is a\n    // member expression then we need to assign it to a temporary variable so it's\n    // only evaluated once\n\n    if (pattern.properties.length > 1 && !this.scope.isStatic(objRef)) {\n      var temp = this.scope.generateUidIdentifierBasedOnNode(objRef);\n      this.nodes.push(this.buildVariableDeclaration(temp, objRef));\n      objRef = temp;\n    }\n\n    //\n\n    for (var i = 0; i < pattern.properties.length; i++) {\n      var prop = pattern.properties[i];\n      if (t.isSpreadProperty(prop)) {\n        this.pushObjectSpread(pattern, objRef, prop, i);\n      } else {\n        this.pushObjectProperty(prop, objRef);\n      }\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  DestructuringTransformer.prototype.canUnpackArrayPattern = function canUnpackArrayPattern(pattern, arr) {\n    // not an array so there's no way we can deal with this\n    if (!t.isArrayExpression(arr)) return false;\n\n    // pattern has less elements than the array and doesn't have a rest so some\n    // elements wont be evaluated\n    if (pattern.elements.length > arr.elements.length) return;\n    if (pattern.elements.length < arr.elements.length && !hasRest(pattern)) return false;\n\n    var _arr2 = pattern.elements;\n    for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n      var elem = _arr2[_i2];\n      // deopt on holes\n      if (!elem) return false;\n\n      // deopt on member expressions as they may be included in the RHS\n      if (t.isMemberExpression(elem)) return false;\n    }\n\n    var _arr3 = arr.elements;\n    for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n      var elem = _arr3[_i3];\n      // deopt on spread elements\n      if (t.isSpreadElement(elem)) return false;\n    }\n\n    // deopt on reference to left side identifiers\n    var bindings = t.getBindingIdentifiers(pattern);\n    var state = { deopt: false, bindings: bindings };\n    this.scope.traverse(arr, arrayUnpackVisitor, state);\n    return !state.deopt;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  DestructuringTransformer.prototype.pushUnpackedArrayPattern = function pushUnpackedArrayPattern(pattern, arr) {\n    for (var i = 0; i < pattern.elements.length; i++) {\n      var elem = pattern.elements[i];\n      if (t.isRestElement(elem)) {\n        this.push(elem.argument, t.arrayExpression(arr.elements.slice(i)));\n      } else {\n        this.push(elem, arr.elements[i]);\n      }\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  DestructuringTransformer.prototype.pushArrayPattern = function pushArrayPattern(pattern, arrayRef) {\n    if (!pattern.elements) return;\n\n    // optimise basic array destructuring of an array expression\n    //\n    // we can't do this to a pattern of unequal size to it's right hand\n    // array expression as then there will be values that wont be evaluated\n    //\n    // eg: var [a, b] = [1, 2];\n\n    if (this.canUnpackArrayPattern(pattern, arrayRef)) {\n      return this.pushUnpackedArrayPattern(pattern, arrayRef);\n    }\n\n    // if we have a rest then we need all the elements so don't tell\n    // `scope.toArray` to only get a certain amount\n\n    var count = !hasRest(pattern) && pattern.elements.length;\n\n    // so we need to ensure that the `arrayRef` is an array, `scope.toArray` will\n    // return a locally bound identifier if it's been inferred to be an array,\n    // otherwise it'll be a call to a helper that will ensure it's one\n\n    var toArray = this.toArray(arrayRef, count);\n\n    if (t.isIdentifier(toArray)) {\n      // we've been given an identifier so it must have been inferred to be an\n      // array\n      arrayRef = toArray;\n    } else {\n      arrayRef = this.scope.generateUidIdentifierBasedOnNode(arrayRef);\n      this.arrays[arrayRef.name] = true;\n      this.nodes.push(this.buildVariableDeclaration(arrayRef, toArray));\n    }\n\n    //\n\n    for (var i = 0; i < pattern.elements.length; i++) {\n      var elem = pattern.elements[i];\n\n      // hole\n      if (!elem) continue;\n\n      var elemRef;\n\n      if (t.isRestElement(elem)) {\n        elemRef = this.toArray(arrayRef);\n\n        if (i > 0) {\n          elemRef = t.callExpression(t.memberExpression(elemRef, t.identifier(\"slice\")), [t.literal(i)]);\n        }\n\n        // set the element to the rest element argument since we've dealt with it\n        // being a rest already\n        elem = elem.argument;\n      } else {\n        elemRef = t.memberExpression(arrayRef, t.literal(i), true);\n      }\n\n      this.push(elem, elemRef);\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  DestructuringTransformer.prototype.init = function init(pattern, ref) {\n    // trying to destructure a value that we can't evaluate more than once so we\n    // need to save it to a variable\n\n    if (!t.isArrayExpression(ref) && !t.isMemberExpression(ref)) {\n      var memo = this.scope.maybeGenerateMemoised(ref, true);\n      if (memo) {\n        this.nodes.push(this.buildVariableDeclaration(memo, ref));\n        ref = memo;\n      }\n    }\n\n    //\n\n    this.push(pattern, ref);\n\n    return this.nodes;\n  };\n\n  return DestructuringTransformer;\n})();","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// istanbul ignore next\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _traversal = require(\"../../../traversal\");\n\nvar _traversal2 = _interopRequireDefault(_traversal);\n\nvar _helpersObject = require(\"../../../helpers/object\");\n\nvar _helpersObject2 = _interopRequireDefault(_helpersObject);\n\nvar _util = require(\"../../../util\");\n\nvar util = _interopRequireWildcard(_util);\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\nvar _lodashObjectValues = require(\"lodash/object/values\");\n\nvar _lodashObjectValues2 = _interopRequireDefault(_lodashObjectValues);\n\nvar _lodashObjectExtend = require(\"lodash/object/extend\");\n\nvar _lodashObjectExtend2 = _interopRequireDefault(_lodashObjectExtend);\n\n/**\n * [Please add a description.]\n */\n\nfunction isLet(node, parent) {\n  if (!t.isVariableDeclaration(node)) return false;\n  if (node._let) return true;\n  if (node.kind !== \"let\") return false;\n\n  // https://github.com/babel/babel/issues/255\n  if (isLetInitable(node, parent)) {\n    for (var i = 0; i < node.declarations.length; i++) {\n      var declar = node.declarations[i];\n      declar.init = declar.init || t.identifier(\"undefined\");\n    }\n  }\n\n  node._let = true;\n  node.kind = \"var\";\n  return true;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction isLetInitable(node, parent) {\n  return !t.isFor(parent) || !t.isFor(parent, { left: node });\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction isVar(node, parent) {\n  return t.isVariableDeclaration(node, { kind: \"var\" }) && !isLet(node, parent);\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction standardizeLets(declars) {\n  var _arr = declars;\n\n  for (var _i = 0; _i < _arr.length; _i++) {\n    var declar = _arr[_i];\n    delete declar._let;\n  }\n}\n\nvar metadata = {\n  group: \"builtin-advanced\"\n};\n\nexports.metadata = metadata;\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  VariableDeclaration: function VariableDeclaration(node, parent, scope, file) {\n    if (!isLet(node, parent)) return;\n\n    if (isLetInitable(node) && file.transformers[\"es6.spec.blockScoping\"].canTransform()) {\n      var nodes = [node];\n\n      for (var i = 0; i < node.declarations.length; i++) {\n        var decl = node.declarations[i];\n        if (decl.init) {\n          var assign = t.assignmentExpression(\"=\", decl.id, decl.init);\n          assign._ignoreBlockScopingTDZ = true;\n          nodes.push(t.expressionStatement(assign));\n        }\n        decl.init = file.addHelper(\"temporal-undefined\");\n      }\n\n      node._blockHoist = 2;\n\n      return nodes;\n    }\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  Loop: function Loop(node, parent, scope, file) {\n    var init = node.left || node.init;\n    if (isLet(init, node)) {\n      t.ensureBlock(node);\n      node.body._letDeclarators = [init];\n    }\n\n    var blockScoping = new BlockScoping(this, this.get(\"body\"), parent, scope, file);\n    return blockScoping.run();\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  \"BlockStatement|Program\": function BlockStatementProgram(block, parent, scope, file) {\n    if (!t.isLoop(parent)) {\n      var blockScoping = new BlockScoping(null, this, parent, scope, file);\n      blockScoping.run();\n    }\n  }\n};\n\nexports.visitor = visitor;\n/**\n * [Please add a description.]\n */\n\nfunction replace(node, parent, scope, remaps) {\n  var remap = remaps[node.name];\n  if (!remap) return;\n\n  var ownBinding = scope.getBindingIdentifier(node.name);\n  if (ownBinding === remap.binding) {\n    node.name = remap.uid;\n  } else {\n    // scope already has it's own binding that doesn't\n    // match the one we have a stored replacement for\n    if (this) this.skip();\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nvar replaceVisitor = {\n  ReferencedIdentifier: replace,\n\n  /**\n   * [Please add a description.]\n   */\n\n  AssignmentExpression: function AssignmentExpression(node, parent, scope, remaps) {\n    var ids = this.getBindingIdentifiers();\n    for (var name in ids) {\n      replace(ids[name], node, scope, remaps);\n    }\n  }\n};\n\n/**\n * [Please add a description.]\n */\n\nfunction traverseReplace(node, parent, scope, remaps) {\n  if (t.isIdentifier(node)) {\n    replace(node, parent, scope, remaps);\n  }\n\n  if (t.isAssignmentExpression(node)) {\n    var ids = t.getBindingIdentifiers(node);\n    for (var name in ids) {\n      replace(ids[name], parent, scope, remaps);\n    }\n  }\n\n  scope.traverse(node, replaceVisitor, remaps);\n}\n\n/**\n * [Please add a description.]\n */\n\nvar letReferenceBlockVisitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  Function: function Function(node, parent, scope, state) {\n    this.traverse(letReferenceFunctionVisitor, state);\n    return this.skip();\n  }\n};\n\n/**\n * [Please add a description.]\n */\n\nvar letReferenceFunctionVisitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope, state) {\n    var ref = state.letReferences[node.name];\n\n    // not a part of our scope\n    if (!ref) return;\n\n    // this scope has a variable with the same name so it couldn't belong\n    // to our let scope\n    var localBinding = scope.getBindingIdentifier(node.name);\n    if (localBinding && localBinding !== ref) return;\n\n    state.closurify = true;\n  }\n};\n\n/**\n * [Please add a description.]\n */\n\nvar hoistVarDeclarationsVisitor = {\n  enter: function enter(node, parent, scope, self) {\n    if (this.isForStatement()) {\n      if (isVar(node.init, node)) {\n        var nodes = self.pushDeclar(node.init);\n        if (nodes.length === 1) {\n          node.init = nodes[0];\n        } else {\n          node.init = t.sequenceExpression(nodes);\n        }\n      }\n    } else if (this.isFor()) {\n      if (isVar(node.left, node)) {\n        self.pushDeclar(node.left);\n        node.left = node.left.declarations[0].id;\n      }\n    } else if (isVar(node, parent)) {\n      return self.pushDeclar(node).map(t.expressionStatement);\n    } else if (this.isFunction()) {\n      return this.skip();\n    }\n  }\n};\n\n/**\n * [Please add a description.]\n */\n\nvar loopLabelVisitor = {\n  LabeledStatement: function LabeledStatement(node, parent, scope, state) {\n    state.innerLabels.push(node.label.name);\n  }\n};\n\n/**\n * [Please add a description.]\n */\n\nvar continuationVisitor = {\n  enter: function enter(node, parent, scope, state) {\n    if (this.isAssignmentExpression() || this.isUpdateExpression()) {\n      var bindings = this.getBindingIdentifiers();\n      for (var name in bindings) {\n        if (state.outsideReferences[name] !== scope.getBindingIdentifier(name)) continue;\n        state.reassignments[name] = true;\n      }\n    }\n  }\n};\n\n/**\n * [Please add a description.]\n */\n\nvar loopNodeTo = function loopNodeTo(node) {\n  if (t.isBreakStatement(node)) {\n    return \"break\";\n  } else if (t.isContinueStatement(node)) {\n    return \"continue\";\n  }\n};\n\n/**\n * [Please add a description.]\n */\n\nvar loopVisitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  Loop: function Loop(node, parent, scope, state) {\n    var oldIgnoreLabeless = state.ignoreLabeless;\n    state.ignoreLabeless = true;\n    this.traverse(loopVisitor, state);\n    state.ignoreLabeless = oldIgnoreLabeless;\n    this.skip();\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  Function: function Function() {\n    this.skip();\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  SwitchCase: function SwitchCase(node, parent, scope, state) {\n    var oldInSwitchCase = state.inSwitchCase;\n    state.inSwitchCase = true;\n    this.traverse(loopVisitor, state);\n    state.inSwitchCase = oldInSwitchCase;\n    this.skip();\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  enter: function enter(node, parent, scope, state) {\n    var replace;\n    var loopText = loopNodeTo(node);\n\n    if (loopText) {\n      if (node.label) {\n        // we shouldn't be transforming this because it exists somewhere inside\n        if (state.innerLabels.indexOf(node.label.name) >= 0) {\n          return;\n        }\n\n        loopText = loopText + \"|\" + node.label.name;\n      } else {\n        // we shouldn't be transforming these statements because\n        // they don't refer to the actual loop we're scopifying\n        if (state.ignoreLabeless) return;\n\n        //\n        if (state.inSwitchCase) return;\n\n        // break statements mean something different in this context\n        if (t.isBreakStatement(node) && t.isSwitchCase(parent)) return;\n      }\n\n      state.hasBreakContinue = true;\n      state.map[loopText] = node;\n      replace = t.literal(loopText);\n    }\n\n    if (this.isReturnStatement()) {\n      state.hasReturn = true;\n      replace = t.objectExpression([t.property(\"init\", t.identifier(\"v\"), node.argument || t.identifier(\"undefined\"))]);\n    }\n\n    if (replace) {\n      replace = t.returnStatement(replace);\n      this.skip();\n      return t.inherits(replace, node);\n    }\n  }\n};\n\n/**\n * [Please add a description.]\n */\n\nvar BlockScoping = (function () {\n  function BlockScoping(loopPath, blockPath, parent, scope, file) {\n    _classCallCheck(this, BlockScoping);\n\n    this.parent = parent;\n    this.scope = scope;\n    this.file = file;\n\n    this.blockPath = blockPath;\n    this.block = blockPath.node;\n\n    this.outsideLetReferences = _helpersObject2[\"default\"]();\n    this.hasLetReferences = false;\n    this.letReferences = this.block._letReferences = _helpersObject2[\"default\"]();\n    this.body = [];\n\n    if (loopPath) {\n      this.loopParent = loopPath.parent;\n      this.loopLabel = t.isLabeledStatement(this.loopParent) && this.loopParent.label;\n      this.loopPath = loopPath;\n      this.loop = loopPath.node;\n    }\n  }\n\n  /**\n   * Start the ball rolling.\n   */\n\n  BlockScoping.prototype.run = function run() {\n    var block = this.block;\n    if (block._letDone) return;\n    block._letDone = true;\n\n    var needsClosure = this.getLetReferences();\n\n    // this is a block within a `Function/Program` so we can safely leave it be\n    if (t.isFunction(this.parent) || t.isProgram(this.block)) return;\n\n    // we can skip everything\n    if (!this.hasLetReferences) return;\n\n    if (needsClosure) {\n      this.wrapClosure();\n    } else {\n      this.remap();\n    }\n\n    if (this.loopLabel && !t.isLabeledStatement(this.loopParent)) {\n      return t.labeledStatement(this.loopLabel, this.loop);\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  BlockScoping.prototype.remap = function remap() {\n    var hasRemaps = false;\n    var letRefs = this.letReferences;\n    var scope = this.scope;\n\n    // alright, so since we aren't wrapping this block in a closure\n    // we have to check if any of our let variables collide with\n    // those in upper scopes and then if they do, generate a uid\n    // for them and replace all references with it\n    var remaps = _helpersObject2[\"default\"]();\n\n    for (var key in letRefs) {\n      // just an Identifier node we collected in `getLetReferences`\n      // this is the defining identifier of a declaration\n      var ref = letRefs[key];\n\n      // todo: could skip this if the colliding binding is in another function\n      if (scope.parentHasBinding(key) || scope.hasGlobal(key)) {\n        var uid = scope.generateUidIdentifier(ref.name).name;\n        ref.name = uid;\n\n        hasRemaps = true;\n        remaps[key] = remaps[uid] = {\n          binding: ref,\n          uid: uid\n        };\n      }\n    }\n\n    if (!hasRemaps) return;\n\n    //\n\n    var loop = this.loop;\n    if (loop) {\n      traverseReplace(loop.right, loop, scope, remaps);\n      traverseReplace(loop.test, loop, scope, remaps);\n      traverseReplace(loop.update, loop, scope, remaps);\n    }\n\n    this.blockPath.traverse(replaceVisitor, remaps);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  BlockScoping.prototype.wrapClosure = function wrapClosure() {\n    var block = this.block;\n\n    var outsideRefs = this.outsideLetReferences;\n\n    // remap loop heads with colliding variables\n    if (this.loop) {\n      for (var name in outsideRefs) {\n        var id = outsideRefs[name];\n\n        if (this.scope.hasGlobal(id.name) || this.scope.parentHasBinding(id.name)) {\n          delete outsideRefs[id.name];\n          delete this.letReferences[id.name];\n\n          this.scope.rename(id.name);\n\n          this.letReferences[id.name] = id;\n          outsideRefs[id.name] = id;\n        }\n      }\n    }\n\n    // if we're inside of a for loop then we search to see if there are any\n    // `break`s, `continue`s, `return`s etc\n    this.has = this.checkLoop();\n\n    // hoist var references to retain scope\n    this.hoistVarDeclarations();\n\n    // turn outsideLetReferences into an array\n    var params = _lodashObjectValues2[\"default\"](outsideRefs);\n    var args = _lodashObjectValues2[\"default\"](outsideRefs);\n\n    // build the closure that we're going to wrap the block with\n    var fn = t.functionExpression(null, params, t.blockStatement(block.body));\n    fn.shadow = true;\n\n    // continuation\n    this.addContinuations(fn);\n\n    // replace the current block body with the one we're going to build\n    block.body = this.body;\n\n    var ref = fn;\n\n    if (this.loop) {\n      ref = this.scope.generateUidIdentifier(\"loop\");\n      this.loopPath.insertBefore(t.variableDeclaration(\"var\", [t.variableDeclarator(ref, fn)]));\n    }\n\n    // build a call and a unique id that we can assign the return value to\n    var call = t.callExpression(ref, args);\n    var ret = this.scope.generateUidIdentifier(\"ret\");\n\n    // handle generators\n    var hasYield = _traversal2[\"default\"].hasType(fn.body, this.scope, \"YieldExpression\", t.FUNCTION_TYPES);\n    if (hasYield) {\n      fn.generator = true;\n      call = t.yieldExpression(call, true);\n    }\n\n    // handlers async functions\n    var hasAsync = _traversal2[\"default\"].hasType(fn.body, this.scope, \"AwaitExpression\", t.FUNCTION_TYPES);\n    if (hasAsync) {\n      fn.async = true;\n      call = t.awaitExpression(call);\n    }\n\n    this.buildClosure(ret, call);\n  };\n\n  /**\n   * Push the closure to the body.\n   */\n\n  BlockScoping.prototype.buildClosure = function buildClosure(ret, call) {\n    var has = this.has;\n    if (has.hasReturn || has.hasBreakContinue) {\n      this.buildHas(ret, call);\n    } else {\n      this.body.push(t.expressionStatement(call));\n    }\n  };\n\n  /**\n   * If any of the outer let variables are reassigned then we need to rename them in\n   * the closure so we can get direct access to the outer variable to continue the\n   * iteration with bindings based on each iteration.\n   *\n   * Reference: https://github.com/babel/babel/issues/1078\n   */\n\n  BlockScoping.prototype.addContinuations = function addContinuations(fn) {\n    var state = {\n      reassignments: {},\n      outsideReferences: this.outsideLetReferences\n    };\n\n    this.scope.traverse(fn, continuationVisitor, state);\n\n    for (var i = 0; i < fn.params.length; i++) {\n      var param = fn.params[i];\n      if (!state.reassignments[param.name]) continue;\n\n      var newParam = this.scope.generateUidIdentifier(param.name);\n      fn.params[i] = newParam;\n\n      this.scope.rename(param.name, newParam.name, fn);\n\n      // assign outer reference as it's been modified internally and needs to be retained\n      fn.body.body.push(t.expressionStatement(t.assignmentExpression(\"=\", param, newParam)));\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  BlockScoping.prototype.getLetReferences = function getLetReferences() {\n    var block = this.block;\n\n    var declarators = block._letDeclarators || [];\n\n    //\n    for (var i = 0; i < declarators.length; i++) {\n      var declar = declarators[i];\n      _lodashObjectExtend2[\"default\"](this.outsideLetReferences, t.getBindingIdentifiers(declar));\n    }\n\n    //\n    if (block.body) {\n      for (var i = 0; i < block.body.length; i++) {\n        var declar = block.body[i];\n        if (isLet(declar, block)) {\n          declarators = declarators.concat(declar.declarations);\n        }\n      }\n    }\n\n    //\n    for (var i = 0; i < declarators.length; i++) {\n      var declar = declarators[i];\n      var keys = t.getBindingIdentifiers(declar);\n      _lodashObjectExtend2[\"default\"](this.letReferences, keys);\n      this.hasLetReferences = true;\n    }\n\n    // no let references so we can just quit\n    if (!this.hasLetReferences) return;\n\n    // set let references to plain var references\n    standardizeLets(declarators);\n\n    var state = {\n      letReferences: this.letReferences,\n      closurify: false\n    };\n\n    // traverse through this block, stopping on functions and checking if they\n    // contain any local let references\n    this.blockPath.traverse(letReferenceBlockVisitor, state);\n\n    return state.closurify;\n  };\n\n  /**\n   * If we're inside of a loop then traverse it and check if it has one of\n   * the following node types `ReturnStatement`, `BreakStatement`,\n   * `ContinueStatement` and replace it with a return value that we can track\n   * later on.\n   *\n   * @returns {Object}\n   */\n\n  BlockScoping.prototype.checkLoop = function checkLoop() {\n    var state = {\n      hasBreakContinue: false,\n      ignoreLabeless: false,\n      inSwitchCase: false,\n      innerLabels: [],\n      hasReturn: false,\n      isLoop: !!this.loop,\n      map: {}\n    };\n\n    this.blockPath.traverse(loopLabelVisitor, state);\n    this.blockPath.traverse(loopVisitor, state);\n\n    return state;\n  };\n\n  /**\n   * Hoist all var declarations in this block to before it so they retain scope\n   * once we wrap everything in a closure.\n   */\n\n  BlockScoping.prototype.hoistVarDeclarations = function hoistVarDeclarations() {\n    this.blockPath.traverse(hoistVarDeclarationsVisitor, this);\n  };\n\n  /**\n   * Turn a `VariableDeclaration` into an array of `AssignmentExpressions` with\n   * their declarations hoisted to before the closure wrapper.\n   */\n\n  BlockScoping.prototype.pushDeclar = function pushDeclar(node) {\n    var declars = [];\n    var names = t.getBindingIdentifiers(node);\n    for (var name in names) {\n      declars.push(t.variableDeclarator(names[name]));\n    }\n\n    this.body.push(t.variableDeclaration(node.kind, declars));\n\n    var replace = [];\n\n    for (var i = 0; i < node.declarations.length; i++) {\n      var declar = node.declarations[i];\n      if (!declar.init) continue;\n\n      var expr = t.assignmentExpression(\"=\", declar.id, declar.init);\n      replace.push(t.inherits(expr, declar));\n    }\n\n    return replace;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  BlockScoping.prototype.buildHas = function buildHas(ret, call) {\n    var body = this.body;\n\n    body.push(t.variableDeclaration(\"var\", [t.variableDeclarator(ret, call)]));\n\n    var retCheck;\n    var has = this.has;\n    var cases = [];\n\n    if (has.hasReturn) {\n      // typeof ret === \"object\"\n      retCheck = util.template(\"let-scoping-return\", {\n        RETURN: ret\n      });\n    }\n\n    if (has.hasBreakContinue) {\n      for (var key in has.map) {\n        cases.push(t.switchCase(t.literal(key), [has.map[key]]));\n      }\n\n      if (has.hasReturn) {\n        cases.push(t.switchCase(null, [retCheck]));\n      }\n\n      if (cases.length === 1) {\n        var single = cases[0];\n        body.push(this.file.attachAuxiliaryComment(t.ifStatement(t.binaryExpression(\"===\", ret, single.test), single.consequent[0])));\n      } else {\n        // https://github.com/babel/babel/issues/998\n        for (var i = 0; i < cases.length; i++) {\n          var caseConsequent = cases[i].consequent[0];\n          if (t.isBreakStatement(caseConsequent) && !caseConsequent.label) {\n            caseConsequent.label = this.loopLabel = this.loopLabel || this.file.scope.generateUidIdentifier(\"loop\");\n          }\n        }\n\n        body.push(this.file.attachAuxiliaryComment(t.switchStatement(ret, cases)));\n      }\n    } else {\n      if (has.hasReturn) {\n        body.push(this.file.attachAuxiliaryComment(retCheck));\n      }\n    }\n  };\n\n  return BlockScoping;\n})();","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nfunction buildAssert(node, file) {\n  return t.callExpression(file.addHelper(\"temporal-assert-defined\"), [node, t.literal(node.name), file.addHelper(\"temporal-undefined\")]);\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction references(node, scope, state) {\n  var declared = state.letRefs[node.name];\n  if (!declared) return false;\n\n  // declared node is different in this scope\n  return scope.getBindingIdentifier(node.name) === declared;\n}\n\n/**\n * [Please add a description.]\n */\n\nvar refVisitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope, state) {\n    if (t.isFor(parent) && parent.left === node) return;\n\n    if (!references(node, scope, state)) return;\n\n    var assert = buildAssert(node, state.file);\n\n    this.skip();\n\n    if (t.isUpdateExpression(parent)) {\n      if (parent._ignoreBlockScopingTDZ) return;\n      this.parentPath.replaceWith(t.sequenceExpression([assert, parent]));\n    } else {\n      return t.logicalExpression(\"&&\", assert, node);\n    }\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  AssignmentExpression: {\n    exit: function exit(node, parent, scope, state) {\n      if (node._ignoreBlockScopingTDZ) return;\n\n      var nodes = [];\n      var ids = this.getBindingIdentifiers();\n\n      for (var name in ids) {\n        var id = ids[name];\n\n        if (references(id, scope, state)) {\n          nodes.push(buildAssert(id, state.file));\n        }\n      }\n\n      if (nodes.length) {\n        node._ignoreBlockScopingTDZ = true;\n        nodes.push(node);\n        return nodes.map(t.expressionStatement);\n      }\n    }\n  }\n};\n\nvar metadata = {\n  optional: true,\n  group: \"builtin-advanced\"\n};\n\nexports.metadata = metadata;\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  \"Program|Loop|BlockStatement\": {\n    exit: function exit(node, parent, scope, file) {\n      var letRefs = node._letReferences;\n      if (!letRefs) return;\n\n      this.traverse(refVisitor, {\n        letRefs: letRefs,\n        file: file\n      });\n    }\n  }\n};\nexports.visitor = visitor;","\n\nexports.__esModule = true;\nexports.manipulateOptions = manipulateOptions;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _helpersReact = require(\"../../helpers/react\");\n\nvar react = _interopRequireWildcard(_helpersReact);\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nfunction manipulateOptions(opts) {\n  opts.blacklist.push(\"react\");\n}\n\nvar metadata = {\n  optional: true,\n  group: \"builtin-advanced\"\n};\n\nexports.metadata = metadata;\n/**\n * [Please add a description.]\n */\n\nvar visitor = require(\"../../helpers/build-react-transformer\")({\n\n  /**\n   * [Please add a description.]\n   */\n\n  pre: function pre(state) {\n    state.callee = state.tagExpr;\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  post: function post(state) {\n    if (react.isCompatTag(state.tagName)) {\n      state.call = t.callExpression(t.memberExpression(t.memberExpression(t.identifier(\"React\"), t.identifier(\"DOM\")), state.tagExpr, t.isLiteral(state.tagExpr)), state.args);\n    }\n  }\n});\nexports.visitor = visitor;","// Based upon the excellent jsx-transpiler by Ingvar Stepanyan (RReverser)\n// https://github.com/RReverser/jsx-transpiler\n\n// jsx\n\n\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _lodashLangIsString = require(\"lodash/lang/isString\");\n\nvar _lodashLangIsString2 = _interopRequireDefault(_lodashLangIsString);\n\nvar _messages = require(\"../../messages\");\n\nvar messages = _interopRequireWildcard(_messages);\n\nvar _esutils = require(\"esutils\");\n\nvar _esutils2 = _interopRequireDefault(_esutils);\n\nvar _react = require(\"./react\");\n\nvar react = _interopRequireWildcard(_react);\n\nvar _types = require(\"../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nexports[\"default\"] = function (opts) {\n  var visitor = {};\n\n  /**\n   * [Please add a description.]\n   */\n\n  visitor.JSXIdentifier = function (node) {\n    if (node.name === \"this\" && this.isReferenced()) {\n      return t.thisExpression();\n    } else if (_esutils2[\"default\"].keyword.isIdentifierNameES6(node.name)) {\n      node.type = \"Identifier\";\n    } else {\n      return t.literal(node.name);\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  visitor.JSXNamespacedName = function () {\n    throw this.errorWithNode(messages.get(\"JSXNamespacedTags\"));\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  visitor.JSXMemberExpression = {\n    exit: function exit(node) {\n      node.computed = t.isLiteral(node.property);\n      node.type = \"MemberExpression\";\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  visitor.JSXExpressionContainer = function (node) {\n    return node.expression;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  visitor.JSXAttribute = {\n    enter: function enter(node) {\n      var value = node.value;\n      if (t.isLiteral(value) && _lodashLangIsString2[\"default\"](value.value)) {\n        value.value = value.value.replace(/\\n\\s+/g, \" \");\n      }\n    },\n\n    exit: function exit(node) {\n      var value = node.value || t.literal(true);\n      return t.inherits(t.property(\"init\", node.name, value), node);\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  visitor.JSXOpeningElement = {\n    exit: function exit(node, parent, scope, file) {\n      parent.children = react.buildChildren(parent);\n\n      var tagExpr = node.name;\n      var args = [];\n\n      var tagName;\n      if (t.isIdentifier(tagExpr)) {\n        tagName = tagExpr.name;\n      } else if (t.isLiteral(tagExpr)) {\n        tagName = tagExpr.value;\n      }\n\n      var state = {\n        tagExpr: tagExpr,\n        tagName: tagName,\n        args: args\n      };\n\n      if (opts.pre) {\n        opts.pre(state, file);\n      }\n\n      var attribs = node.attributes;\n      if (attribs.length) {\n        attribs = buildJSXOpeningElementAttributes(attribs, file);\n      } else {\n        attribs = t.literal(null);\n      }\n\n      args.push(attribs);\n\n      if (opts.post) {\n        opts.post(state, file);\n      }\n\n      return state.call || t.callExpression(state.callee, args);\n    }\n  };\n\n  /**\n   * The logic for this is quite terse. It's because we need to\n   * support spread elements. We loop over all attributes,\n   * breaking on spreads, we then push a new object containg\n   * all prior attributes to an array for later processing.\n   */\n\n  var buildJSXOpeningElementAttributes = function buildJSXOpeningElementAttributes(attribs, file) {\n    var _props = [];\n    var objs = [];\n\n    var pushProps = function pushProps() {\n      if (!_props.length) return;\n\n      objs.push(t.objectExpression(_props));\n      _props = [];\n    };\n\n    while (attribs.length) {\n      var prop = attribs.shift();\n      if (t.isJSXSpreadAttribute(prop)) {\n        pushProps();\n        objs.push(prop.argument);\n      } else {\n        _props.push(prop);\n      }\n    }\n\n    pushProps();\n\n    if (objs.length === 1) {\n      // only one object\n      attribs = objs[0];\n    } else {\n      // looks like we have multiple objects\n      if (!t.isObjectExpression(objs[0])) {\n        objs.unshift(t.objectExpression([]));\n      }\n\n      // spread it\n      attribs = t.callExpression(file.addHelper(\"extends\"), objs);\n    }\n\n    return attribs;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  visitor.JSXElement = {\n    exit: function exit(node) {\n      var callExpr = node.openingElement;\n\n      callExpr.arguments = callExpr.arguments.concat(node.children);\n\n      if (callExpr.arguments.length >= 3) {\n        callExpr._prettyCall = true;\n      }\n\n      return t.inherits(callExpr, node);\n    }\n  };\n\n  return visitor;\n};\n\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _helpersReact = require(\"../../helpers/react\");\n\nvar react = _interopRequireWildcard(_helpersReact);\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nvar JSX_ANNOTATION_REGEX = /^\\*\\s*@jsx\\s+([^\\s]+)/;\n\nvar metadata = {\n  group: \"builtin-advanced\"\n};\n\nexports.metadata = metadata;\n/**\n * [Please add a description.]\n */\n\nvar visitor = require(\"../../helpers/build-react-transformer\")({\n\n  /**\n   * [Please add a description.]\n   */\n\n  pre: function pre(state) {\n    var tagName = state.tagName;\n    var args = state.args;\n    if (react.isCompatTag(tagName)) {\n      args.push(t.literal(tagName));\n    } else {\n      args.push(state.tagExpr);\n    }\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  post: function post(state, file) {\n    state.callee = file.get(\"jsxIdentifier\");\n  }\n});\n\nexports.visitor = visitor;\n/**\n * [Please add a description.]\n */\n\nvisitor.Program = function (node, parent, scope, file) {\n  var id = file.opts.jsxPragma;\n\n  for (var i = 0; i < file.ast.comments.length; i++) {\n    var comment = file.ast.comments[i];\n    var matches = JSX_ANNOTATION_REGEX.exec(comment.value);\n    if (matches) {\n      id = matches[1];\n      if (id === \"React.DOM\") {\n        throw file.errorWithNode(comment, \"The @jsx React.DOM pragma has been deprecated as of React 0.12\");\n      } else {\n        break;\n      }\n    }\n  }\n\n  file.set(\"jsxIdentifier\", id.split(\".\").map(t.identifier).reduce(function (object, property) {\n    return t.memberExpression(object, property);\n  }));\n};","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _regenerator = require(\"regenerator\");\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n// It's important to use the exact same NodePath constructor that\n// Regenerator uses, rather than require(\"ast-types\").NodePath, because\n// the version of ast-types that Babel knows about might be different from\n// the version that Regenerator depends on. See for example #1958.\nvar NodePath = _regenerator2[\"default\"].types.NodePath;\n\nvar metadata = {\n  group: \"builtin-advanced\"\n};\n\nexports.metadata = metadata;\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  Function: {\n    exit: function exit(node) {\n      if (node.async || node.generator) {\n        // Although this code transforms only the subtree rooted at the given\n        // Function node, that node might contain other generator functions\n        // that will also be transformed. It might help performance to ignore\n        // nested functions, and rely on the traversal to visit them later,\n        // but that's a small optimization. Starting here instead of at the\n        // root of the AST is the key optimization, since huge async/generator\n        // functions are relatively rare.\n        _regenerator2[\"default\"].transform(convertNodePath(this));\n      }\n    }\n  }\n};\n\nexports.visitor = visitor;\n// Given a Babel NodePath, return an ast-types NodePath that includes full\n// ancestry information (up to and including the Program node). This is\n// complicated by having to include intermediate objects like blockStatement.body\n// arrays, in addition to Node objects.\nfunction convertNodePath(path) {\n  var programNode;\n  var keysAlongPath = [];\n\n  while (path) {\n    var pp = path.parentPath;\n    var parentNode = pp && pp.node;\n    if (parentNode) {\n      keysAlongPath.push(path.key);\n\n      if (parentNode !== path.container) {\n        var found = Object.keys(parentNode).some(function (listKey) {\n          if (parentNode[listKey] === path.container) {\n            keysAlongPath.push(listKey);\n            return true;\n          }\n        });\n\n        if (!found) {\n          throw new Error(\"Failed to find container object in parent node\");\n        }\n      }\n\n      if (t.isProgram(parentNode)) {\n        programNode = parentNode;\n        break;\n      }\n    }\n\n    path = pp;\n  }\n\n  if (!programNode) {\n    throw new Error(\"Failed to find root Program node\");\n  }\n\n  var nodePath = new NodePath(programNode);\n\n  while (keysAlongPath.length > 0) {\n    nodePath = nodePath.get(keysAlongPath.pop());\n  }\n\n  return nodePath;\n}","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\nfunction keepBlockHoist(node, nodes) {\n  if (node._blockHoist) {\n    for (var i = 0; i < nodes.length; i++) {\n      nodes[i]._blockHoist = node._blockHoist;\n    }\n  }\n}\n\nvar metadata = {\n  group: \"builtin-modules\"\n};\n\nexports.metadata = metadata;\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  ImportDeclaration: function ImportDeclaration(node, parent, scope, file) {\n    // flow type\n    if (node.importKind === \"type\" || node.importKind === \"typeof\") return;\n\n    var nodes = [];\n\n    if (node.specifiers.length) {\n      var _arr = node.specifiers;\n\n      for (var _i = 0; _i < _arr.length; _i++) {\n        var specifier = _arr[_i];\n        file.moduleFormatter.importSpecifier(specifier, node, nodes, scope);\n      }\n    } else {\n      file.moduleFormatter.importDeclaration(node, nodes, scope);\n    }\n\n    if (nodes.length === 1) {\n      // inherit `_blockHoist` - this is for `_blockHoist` in File.prototype.addImport\n      nodes[0]._blockHoist = node._blockHoist;\n    }\n\n    return nodes;\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  ExportAllDeclaration: function ExportAllDeclaration(node, parent, scope, file) {\n    var nodes = [];\n    file.moduleFormatter.exportAllDeclaration(node, nodes, scope);\n    keepBlockHoist(node, nodes);\n    return nodes;\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  ExportDefaultDeclaration: function ExportDefaultDeclaration(node, parent, scope, file) {\n    var nodes = [];\n    file.moduleFormatter.exportDeclaration(node, nodes, scope);\n    keepBlockHoist(node, nodes);\n    return nodes;\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  ExportNamedDeclaration: function ExportNamedDeclaration(node, parent, scope, file) {\n    // flow type\n    if (this.get(\"declaration\").isTypeAlias()) return;\n\n    var nodes = [];\n\n    if (node.declaration) {\n      // make sure variable exports have an initializer\n      // this is done here to avoid duplicating it in the module formatters\n      if (t.isVariableDeclaration(node.declaration)) {\n        var declar = node.declaration.declarations[0];\n        declar.init = declar.init || t.identifier(\"undefined\");\n      }\n\n      file.moduleFormatter.exportDeclaration(node, nodes, scope);\n    } else if (node.specifiers) {\n      for (var i = 0; i < node.specifiers.length; i++) {\n        file.moduleFormatter.exportSpecifier(node.specifiers[i], node, nodes, scope);\n      }\n    }\n\n    keepBlockHoist(node, nodes);\n\n    return nodes;\n  }\n};\nexports.visitor = visitor;","\n\nexports.__esModule = true;\nvar metadata = {\n  group: \"builtin-modules\"\n};\n\nexports.metadata = metadata;\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  Program: {\n    exit: function exit(program, parent, scope, file) {\n      // ensure that these are at the top, just like normal imports\n      var _arr = file.dynamicImports;\n      for (var _i = 0; _i < _arr.length; _i++) {\n        var node = _arr[_i];\n        node._blockHoist = 3;\n      }\n\n      program.body = file.dynamicImports.concat(program.body);\n\n      if (!file.transformers[\"es6.modules\"].canTransform()) return;\n\n      if (file.moduleFormatter.transform) {\n        file.moduleFormatter.transform(program);\n      }\n    }\n  }\n};\nexports.visitor = visitor;","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// istanbul ignore next\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar _lodashCollectionReduceRight = require(\"lodash/collection/reduceRight\");\n\nvar _lodashCollectionReduceRight2 = _interopRequireDefault(_lodashCollectionReduceRight);\n\nvar _messages = require(\"../../../messages\");\n\nvar messages = _interopRequireWildcard(_messages);\n\nvar _lodashArrayFlatten = require(\"lodash/array/flatten\");\n\nvar _lodashArrayFlatten2 = _interopRequireDefault(_lodashArrayFlatten);\n\nvar _util = require(\"../../../util\");\n\nvar util = _interopRequireWildcard(_util);\n\nvar _lodashCollectionMap = require(\"lodash/collection/map\");\n\nvar _lodashCollectionMap2 = _interopRequireDefault(_lodashCollectionMap);\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\nvar metadata = {\n  group: \"builtin-trailing\"\n};\n\nexports.metadata = metadata;\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  Function: function Function(node, parent, scope, file) {\n    if (node.generator || node.async) return;\n    var tailCall = new TailCallTransformer(this, scope, file);\n    tailCall.run();\n  }\n};\n\nexports.visitor = visitor;\n/**\n * [Please add a description.]\n */\n\nfunction returnBlock(expr) {\n  return t.blockStatement([t.returnStatement(expr)]);\n}\n\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  enter: function enter(node, parent) {\n    if (t.isTryStatement(parent)) {\n      if (node === parent.block) {\n        this.skip();\n      } else if (parent.finalizer && node !== parent.finalizer) {\n        this.skip();\n      }\n    }\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  ReturnStatement: function ReturnStatement(node, parent, scope, state) {\n    return state.subTransform(node.argument);\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  Function: function Function() {\n    this.skip();\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  VariableDeclaration: function VariableDeclaration(node, parent, scope, state) {\n    state.vars.push(node);\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  ThisExpression: function ThisExpression(node, parent, scope, state) {\n    if (!state.isShadowed) {\n      state.needsThis = true;\n      state.thisPaths.push(this);\n    }\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  ReferencedIdentifier: function ReferencedIdentifier(node, parent, scope, state) {\n    if (node.name === \"arguments\" && (!state.isShadowed || node._shadowedFunctionLiteral)) {\n      state.needsArguments = true;\n      state.argumentsPaths.push(this);\n    }\n  }\n};\n\n/**\n * [Please add a description.]\n */\n\nvar TailCallTransformer = (function () {\n  function TailCallTransformer(path, scope, file) {\n    _classCallCheck(this, TailCallTransformer);\n\n    this.hasTailRecursion = false;\n\n    this.needsArguments = false;\n    this.argumentsPaths = [];\n    this.setsArguments = false;\n\n    this.needsThis = false;\n    this.thisPaths = [];\n\n    this.isShadowed = path.isArrowFunctionExpression() || path.is(\"shadow\");\n    this.ownerId = path.node.id;\n    this.vars = [];\n\n    this.scope = scope;\n    this.path = path;\n    this.file = file;\n    this.node = path.node;\n  }\n\n  /**\n   * [Please add a description.]\n   */\n\n  TailCallTransformer.prototype.getArgumentsId = function getArgumentsId() {\n    return this.argumentsId = this.argumentsId || this.scope.generateUidIdentifier(\"arguments\");\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  TailCallTransformer.prototype.getThisId = function getThisId() {\n    return this.thisId = this.thisId || this.scope.generateUidIdentifier(\"this\");\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  TailCallTransformer.prototype.getLeftId = function getLeftId() {\n    return this.leftId = this.leftId || this.scope.generateUidIdentifier(\"left\");\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  TailCallTransformer.prototype.getFunctionId = function getFunctionId() {\n    return this.functionId = this.functionId || this.scope.generateUidIdentifier(\"function\");\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  TailCallTransformer.prototype.getAgainId = function getAgainId() {\n    return this.againId = this.againId || this.scope.generateUidIdentifier(\"again\");\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  TailCallTransformer.prototype.getParams = function getParams() {\n    var params = this.params;\n\n    if (!params) {\n      params = this.node.params;\n      this.paramDecls = [];\n\n      for (var i = 0; i < params.length; i++) {\n        var param = params[i];\n        if (!param._isDefaultPlaceholder) {\n          this.paramDecls.push(t.variableDeclarator(param, params[i] = this.scope.generateUidIdentifier(\"x\")));\n        }\n      }\n    }\n\n    return this.params = params;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  TailCallTransformer.prototype.hasDeopt = function hasDeopt() {\n    // check if the ownerId has been reassigned, if it has then it's not safe to\n    // perform optimisations\n    var ownerIdInfo = this.scope.getBinding(this.ownerId.name);\n    return ownerIdInfo && !ownerIdInfo.constant;\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  TailCallTransformer.prototype.run = function run() {\n    var node = this.node;\n\n    // only tail recursion can be optimized as for now, so we can skip anonymous\n    // functions entirely\n    var ownerId = this.ownerId;\n    if (!ownerId) return;\n\n    // traverse the function and look for tail recursion\n    this.path.traverse(visitor, this);\n\n    // has no tail call recursion\n    if (!this.hasTailRecursion) return;\n\n    // the function binding isn't constant so we can't be sure that it's the same function :(\n    if (this.hasDeopt()) {\n      this.file.log.deopt(node, messages.get(\"tailCallReassignmentDeopt\"));\n      return;\n    }\n\n    //\n\n    var body = this.path.ensureBlock().body;\n\n    for (var i = 0; i < body.length; i++) {\n      var bodyNode = body[i];\n      if (!t.isFunctionDeclaration(bodyNode)) continue;\n\n      bodyNode = body[i] = t.variableDeclaration(\"var\", [t.variableDeclarator(bodyNode.id, t.toExpression(bodyNode))]);\n      bodyNode._blockHoist = 2;\n    }\n\n    var paramDecls = this.paramDecls;\n    if (paramDecls.length > 0) {\n      var paramDecl = t.variableDeclaration(\"var\", paramDecls);\n      paramDecl._blockHoist = Infinity;\n      body.unshift(paramDecl);\n    }\n\n    body.unshift(t.expressionStatement(t.assignmentExpression(\"=\", this.getAgainId(), t.literal(false))));\n\n    node.body = util.template(\"tail-call-body\", {\n      FUNCTION_ID: this.getFunctionId(),\n      AGAIN_ID: this.getAgainId(),\n      BLOCK: node.body\n    });\n\n    var topVars = [];\n\n    if (this.needsThis) {\n      var _arr = this.thisPaths;\n\n      for (var _i = 0; _i < _arr.length; _i++) {\n        var path = _arr[_i];\n        path.replaceWith(this.getThisId());\n      }\n\n      topVars.push(t.variableDeclarator(this.getThisId(), t.thisExpression()));\n    }\n\n    if (this.needsArguments || this.setsArguments) {\n      var _arr2 = this.argumentsPaths;\n\n      for (var _i2 = 0; _i2 < _arr2.length; _i2++) {\n        var _path = _arr2[_i2];\n        _path.replaceWith(this.argumentsId);\n      }\n\n      var decl = t.variableDeclarator(this.argumentsId);\n      if (this.argumentsId) {\n        decl.init = t.identifier(\"arguments\");\n        decl.init._shadowedFunctionLiteral = this.path;\n      }\n      topVars.push(decl);\n    }\n\n    var leftId = this.leftId;\n    if (leftId) {\n      topVars.push(t.variableDeclarator(leftId));\n    }\n\n    if (topVars.length > 0) {\n      node.body.body.unshift(t.variableDeclaration(\"var\", topVars));\n    }\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  TailCallTransformer.prototype.subTransform = function subTransform(node) {\n    if (!node) return;\n\n    var handler = this[\"subTransform\" + node.type];\n    if (handler) return handler.call(this, node);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  TailCallTransformer.prototype.subTransformConditionalExpression = function subTransformConditionalExpression(node) {\n    var callConsequent = this.subTransform(node.consequent);\n    var callAlternate = this.subTransform(node.alternate);\n    if (!callConsequent && !callAlternate) {\n      return;\n    }\n\n    // if ternary operator had tail recursion in value, convert to optimized if-statement\n    node.type = \"IfStatement\";\n    node.consequent = callConsequent ? t.toBlock(callConsequent) : returnBlock(node.consequent);\n\n    if (callAlternate) {\n      node.alternate = t.isIfStatement(callAlternate) ? callAlternate : t.toBlock(callAlternate);\n    } else {\n      node.alternate = returnBlock(node.alternate);\n    }\n\n    return [node];\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  TailCallTransformer.prototype.subTransformLogicalExpression = function subTransformLogicalExpression(node) {\n    // only call in right-value of can be optimized\n    var callRight = this.subTransform(node.right);\n    if (!callRight) return;\n\n    // cache left value as it might have side-effects\n    var leftId = this.getLeftId();\n    var testExpr = t.assignmentExpression(\"=\", leftId, node.left);\n\n    if (node.operator === \"&&\") {\n      testExpr = t.unaryExpression(\"!\", testExpr);\n    }\n\n    return [t.ifStatement(testExpr, returnBlock(leftId))].concat(callRight);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  TailCallTransformer.prototype.subTransformSequenceExpression = function subTransformSequenceExpression(node) {\n    var seq = node.expressions;\n\n    // only last element can be optimized\n    var lastCall = this.subTransform(seq[seq.length - 1]);\n    if (!lastCall) {\n      return;\n    }\n\n    // remove converted expression from sequence\n    // and convert to regular expression if needed\n    if (--seq.length === 1) {\n      node = seq[0];\n    }\n\n    return [t.expressionStatement(node)].concat(lastCall);\n  };\n\n  /**\n   * [Please add a description.]\n   */\n\n  TailCallTransformer.prototype.subTransformCallExpression = function subTransformCallExpression(node) {\n    var callee = node.callee;\n    var thisBinding, args;\n\n    if (t.isMemberExpression(callee, { computed: false }) && t.isIdentifier(callee.property)) {\n      switch (callee.property.name) {\n        case \"call\":\n          args = t.arrayExpression(node.arguments.slice(1));\n          break;\n\n        case \"apply\":\n          args = node.arguments[1] || t.identifier(\"undefined\");\n          this.needsArguments = true;\n          break;\n\n        default:\n          return;\n      }\n\n      thisBinding = node.arguments[0];\n      callee = callee.object;\n    }\n\n    // only tail recursion can be optimized as for now\n    if (!t.isIdentifier(callee) || !this.scope.bindingIdentifierEquals(callee.name, this.ownerId)) {\n      return;\n    }\n\n    this.hasTailRecursion = true;\n\n    if (this.hasDeopt()) return;\n\n    var body = [];\n\n    if (this.needsThis && !t.isThisExpression(thisBinding)) {\n      body.push(t.expressionStatement(t.assignmentExpression(\"=\", this.getThisId(), thisBinding || t.identifier(\"undefined\"))));\n    }\n\n    if (!args) {\n      args = t.arrayExpression(node.arguments);\n    }\n\n    var argumentsId = this.getArgumentsId();\n    var params = this.getParams();\n\n    if (this.needsArguments) {\n      body.push(t.expressionStatement(t.assignmentExpression(\"=\", argumentsId, args)));\n    }\n\n    if (t.isArrayExpression(args)) {\n      var elems = args.elements;\n\n      // pad out the args so all the function args are reset - https://github.com/babel/babel/issues/1938\n      while (elems.length < params.length) {\n        elems.push(t.identifier(\"undefined\"));\n      }\n\n      for (var i = 0; i < elems.length; i++) {\n        var param = params[i];\n        var elem = elems[i];\n\n        if (param && !param._isDefaultPlaceholder) {\n          elems[i] = t.assignmentExpression(\"=\", param, elem);\n        } else {\n          // exceeds parameters but push it anyway to ensure correct execution\n        }\n      }\n\n      if (!this.needsArguments) {\n        var _arr3 = elems;\n\n        for (var _i3 = 0; _i3 < _arr3.length; _i3++) {\n          var elem = _arr3[_i3];\n          // only push expressions that we really need, this will skip pure arguments that exceed the\n          // parameter length of the current function\n          if (!this.scope.isPure(elem)) {\n            body.push(t.expressionStatement(elem));\n          }\n        }\n      }\n    } else {\n      this.setsArguments = true;\n      for (var i = 0; i < params.length; i++) {\n        var param = params[i];\n        if (!param._isDefaultPlaceholder) {\n          body.push(t.expressionStatement(t.assignmentExpression(\"=\", param, t.memberExpression(argumentsId, t.literal(i), true))));\n        }\n      }\n    }\n\n    body.push(t.expressionStatement(t.assignmentExpression(\"=\", this.getAgainId(), t.literal(true))));\n\n    if (this.vars.length > 0) {\n      var declarations = _lodashArrayFlatten2[\"default\"](_lodashCollectionMap2[\"default\"](this.vars, function (decl) {\n        return decl.declarations;\n      }));\n\n      var assignment = _lodashCollectionReduceRight2[\"default\"](declarations, function (expr, decl) {\n        return t.assignmentExpression(\"=\", decl.id, expr);\n      }, t.identifier(\"undefined\"));\n\n      var statement = t.expressionStatement(assignment);\n      body.push(statement);\n    }\n\n    body.push(t.continueStatement(this.getFunctionId()));\n\n    return body;\n  };\n\n  return TailCallTransformer;\n})();","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\nvar metadata = {\n  group: \"builtin-trailing\"\n};\n\nexports.metadata = metadata;\nfunction shouldShadow(path, shadowPath) {\n  if (path.is(\"_forceShadow\")) {\n    return true;\n  } else {\n    return shadowPath && !shadowPath.isArrowFunctionExpression();\n  }\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction remap(path, key, create) {\n  // ensure that we're shadowed\n  var shadowPath = path.inShadow(key);\n  if (!shouldShadow(path, shadowPath)) return;\n\n  var shadowFunction = path.node._shadowedFunctionLiteral;\n  var currentFunction;\n\n  var fnPath = path.findParent(function (path) {\n    if (path.isProgram() || path.isFunction()) {\n      // catch current function in case this is the shadowed one and we can ignore it\n      currentFunction = currentFunction || path;\n    }\n\n    if (path.isProgram()) {\n      return true;\n    } else if (path.isFunction()) {\n      if (shadowFunction) {\n        return path === shadowFunction || path.node === shadowFunction.node;\n      } else {\n        return !path.is(\"shadow\");\n      }\n    }\n\n    return false;\n  });\n\n  // no point in realiasing if we're in this function\n  if (fnPath === currentFunction) return;\n\n  var cached = fnPath.getData(key);\n  if (cached) return cached;\n\n  var init = create();\n  var id = path.scope.generateUidIdentifier(key);\n\n  fnPath.setData(key, id);\n  fnPath.scope.push({ id: id, init: init });\n\n  return id;\n}\n\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  ThisExpression: function ThisExpression() {\n    return remap(this, \"this\", function () {\n      return t.thisExpression();\n    });\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  ReferencedIdentifier: function ReferencedIdentifier(node) {\n    if (node.name === \"arguments\") {\n      return remap(this, \"arguments\", function () {\n        return t.identifier(\"arguments\");\n      });\n    }\n  }\n};\nexports.visitor = visitor;","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\nvar metadata = {\n  group: \"builtin-trailing\"\n};\n\nexports.metadata = metadata;\n/**\n * Turn reserved word properties into literals.\n *\n * **In**\n *\n * ```javascript\n * var foo = {\n *   catch: function () {}\n * };\n * ```\n *\n * **Out**\n *\n * ```javascript\n * var foo = {\n *   \"catch\": function () {}\n * };\n * ```\n */\n\nvar visitor = {\n\n  /**\n   * Look for non-computed keys with names that are not valid identifiers.\n   * Turn them into literals.\n   */\n\n  Property: {\n    exit: function exit(node) {\n      var key = node.key;\n      if (!node.computed && t.isIdentifier(key) && !t.isValidIdentifier(key.name)) {\n        // default: \"bar\" -> \"default\": \"bar\"\n        node.key = t.literal(key.name);\n      }\n    }\n  }\n};\nexports.visitor = visitor;","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\nvar metadata = {\n  group: \"builtin-trailing\"\n};\n\nexports.metadata = metadata;\n/**\n * Turn member expression reserved word properties into literals.\n *\n * @example\n *\n * **In**\n *\n * ```javascript\n * foo.catch;\n * ```\n *\n * **Out**\n *\n * ```javascript\n * foo[\"catch\"];\n * ```\n */\n\nvar visitor = {\n\n  /**\n   * Look for non-computed properties with names that are not valid identifiers.\n   * Turn them into computed properties with literal names.\n   */\n\n  MemberExpression: {\n    exit: function exit(node) {\n      var prop = node.property;\n      if (!node.computed && t.isIdentifier(prop) && !t.isValidIdentifier(prop.name)) {\n        // foo.default -> foo[\"default\"]\n        node.property = t.literal(prop.name);\n        node.computed = true;\n      }\n    }\n  }\n};\nexports.visitor = visitor;","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _lodashCollectionSortBy = require(\"lodash/collection/sortBy\");\n\nvar _lodashCollectionSortBy2 = _interopRequireDefault(_lodashCollectionSortBy);\n\nvar metadata = {\n  group: \"builtin-trailing\"\n};\n\nexports.metadata = metadata;\n/**\n * [Please add a description.]\n *\n * Priority:\n *\n *  - 0 We want this to be at the **very** bottom\n *  - 1 Default node position\n *  - 2 Priority over normal nodes\n *  - 3 We want this to be at the **very** top\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  Block: {\n    exit: function exit(node) {\n      var hasChange = false;\n      for (var i = 0; i < node.body.length; i++) {\n        var bodyNode = node.body[i];\n        if (bodyNode && bodyNode._blockHoist != null) {\n          hasChange = true;\n          break;\n        }\n      }\n      if (!hasChange) return;\n\n      node.body = _lodashCollectionSortBy2[\"default\"](node.body, function (bodyNode) {\n        var priority = bodyNode && bodyNode._blockHoist;\n        if (priority == null) priority = 1;\n        if (priority === true) priority = 2;\n\n        // Higher priorities should move toward the top.\n        return -1 * priority;\n      });\n    }\n  }\n};\nexports.visitor = visitor;","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\nvar metadata = {\n  group: \"builtin-trailing\"\n};\n\nexports.metadata = metadata;\nvar FLOW_DIRECTIVE = \"@flow\";\n\n/**\n * [Please add a description.]\n */\n\nvar visitor = {\n\n  /**\n   * [Please add a description.]\n   */\n\n  Program: function Program(node, parent, scope, file) {\n    var _arr = file.ast.comments;\n\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var comment = _arr[_i];\n      if (comment.value.indexOf(FLOW_DIRECTIVE) >= 0) {\n        // remove flow directive\n        comment.value = comment.value.replace(FLOW_DIRECTIVE, \"\");\n\n        // remove the comment completely if it only consists of whitespace and/or stars\n        if (!comment.value.replace(/\\*/g, \"\").trim()) comment._displayed = true;\n      }\n    }\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  Flow: function Flow() {\n    this.dangerouslyRemove();\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  ClassProperty: function ClassProperty(node) {\n    node.typeAnnotation = null;\n    if (!node.value) this.dangerouslyRemove();\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  Class: function Class(node) {\n    node[\"implements\"] = null;\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  Function: function Function(node) {\n    for (var i = 0; i < node.params.length; i++) {\n      var param = node.params[i];\n      param.optional = false;\n    }\n  },\n\n  /**\n   * [Please add a description.]\n   */\n\n  TypeCastExpression: function TypeCastExpression(node) {\n    do {\n      node = node.expression;\n    } while (t.isTypeCastExpression(node));\n    return node;\n  }\n};\nexports.visitor = visitor;","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\nvar _types = require(\"../../../types\");\n\nvar t = _interopRequireWildcard(_types);\n\nvar metadata = {\n  optional: true,\n  group: \"builtin-trailing\"\n};\n\nexports.metadata = metadata;\nvar visitor = {\n  Program: function Program(node, parent, scope, file) {\n    if (file.moduleFormatter._setters) {\n      scope.traverse(file.moduleFormatter._setters, optimizeSettersVisitor, {\n        exportFunctionIdentifier: file.moduleFormatter.exportIdentifier\n      });\n    }\n  }\n};\n\nexports.visitor = visitor;\n/**\n * Setters are optimized to avoid slow export behavior in modules that rely on deep hierarchies\n * of export-from declarations.\n * More info in https://github.com/babel/babel/pull/1722 and\n * https://github.com/ModuleLoader/es6-module-loader/issues/386.\n *\n * TODO: Ideally this would be optimized during construction of the setters, but the current\n * architecture of the module formatters make that difficult.\n */\nvar optimizeSettersVisitor = {\n  FunctionExpression: {\n    enter: function enter(node, parent, scope, state) {\n      state.hasExports = false;\n      state.exportObjectIdentifier = scope.generateUidIdentifier(\"exportObj\");\n    },\n    exit: function exit(node, parent, scope, state) {\n      if (!state.hasExports) return;\n\n      node.body.body.unshift(t.variableDeclaration(\"var\", [t.variableDeclarator(t.cloneDeep(state.exportObjectIdentifier), t.objectExpression([]))]));\n      node.body.body.push(t.expressionStatement(t.callExpression(t.cloneDeep(state.exportFunctionIdentifier), [t.cloneDeep(state.exportObjectIdentifier)])));\n    }\n  },\n  CallExpression: function CallExpression(node, parent, scope, state) {\n    if (!t.isIdentifier(node.callee, { name: state.exportFunctionIdentifier.name })) return;\n\n    state.hasExports = true;\n    var memberNode = t.memberExpression(t.cloneDeep(state.exportObjectIdentifier), node.arguments[0], true);\n    return t.assignmentExpression(\"=\", memberNode, node.arguments[1]);\n  }\n};","\n\nexports.__esModule = true;\nexports.internal = internal;\nexports.blacklist = blacklist;\nexports.whitelist = whitelist;\nexports.stage = stage;\nexports.optional = optional;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _lodashCollectionIncludes = require(\"lodash/collection/includes\");\n\nvar _lodashCollectionIncludes2 = _interopRequireDefault(_lodashCollectionIncludes);\n\n/**\n * [Please add a description.]\n */\n\nfunction internal(transformer) {\n  if (transformer.key[0] === \"_\") return true;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction blacklist(transformer, opts) {\n  var blacklist = opts.blacklist;\n  if (blacklist.length && _lodashCollectionIncludes2[\"default\"](blacklist, transformer.key)) return false;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction whitelist(transformer, opts) {\n  var whitelist = opts.whitelist;\n  if (whitelist) return _lodashCollectionIncludes2[\"default\"](whitelist, transformer.key);\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction stage(transformer, opts) {\n  var stage = transformer.metadata.stage;\n  if (stage != null && stage >= opts.stage) return true;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction optional(transformer, opts) {\n  if (transformer.metadata.optional && !_lodashCollectionIncludes2[\"default\"](opts.optional, transformer.key)) return false;\n}","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _generation = require(\"../generation\");\n\nvar _generation2 = _interopRequireDefault(_generation);\n\nvar _messages = require(\"../messages\");\n\nvar messages = _interopRequireWildcard(_messages);\n\nvar _util = require(\"../util\");\n\nvar util = _interopRequireWildcard(_util);\n\nvar _transformationFile = require(\"../transformation/file\");\n\nvar _transformationFile2 = _interopRequireDefault(_transformationFile);\n\nvar _lodashCollectionEach = require(\"lodash/collection/each\");\n\nvar _lodashCollectionEach2 = _interopRequireDefault(_lodashCollectionEach);\n\nvar _types = require(\"../types\");\n\nvar t = _interopRequireWildcard(_types);\n\n/**\n * [Please add a description.]\n */\n\nfunction buildGlobal(namespace, builder) {\n  var body = [];\n  var container = t.functionExpression(null, [t.identifier(\"global\")], t.blockStatement(body));\n  var tree = t.program([t.expressionStatement(t.callExpression(container, [util.template(\"helper-self-global\")]))]);\n\n  body.push(t.variableDeclaration(\"var\", [t.variableDeclarator(namespace, t.assignmentExpression(\"=\", t.memberExpression(t.identifier(\"global\"), namespace), t.objectExpression([])))]));\n\n  builder(body);\n\n  return tree;\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction buildUmd(namespace, builder) {\n  var body = [];\n  body.push(t.variableDeclaration(\"var\", [t.variableDeclarator(namespace, t.identifier(\"global\"))]));\n\n  builder(body);\n\n  var container = util.template(\"umd-commonjs-strict\", {\n    FACTORY_PARAMETERS: t.identifier(\"global\"),\n    BROWSER_ARGUMENTS: t.assignmentExpression(\"=\", t.memberExpression(t.identifier(\"root\"), namespace), t.objectExpression({})),\n    COMMON_ARGUMENTS: t.identifier(\"exports\"),\n    AMD_ARGUMENTS: t.arrayExpression([t.literal(\"exports\")]),\n    FACTORY_BODY: body,\n    UMD_ROOT: t.identifier(\"this\")\n  });\n  return t.program([container]);\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction buildVar(namespace, builder) {\n  var body = [];\n  body.push(t.variableDeclaration(\"var\", [t.variableDeclarator(namespace, t.objectExpression({}))]));\n  builder(body);\n  return t.program(body);\n}\n\n/**\n * [Please add a description.]\n */\n\nfunction buildHelpers(body, namespace, whitelist) {\n  _lodashCollectionEach2[\"default\"](_transformationFile2[\"default\"].helpers, function (name) {\n    if (whitelist && whitelist.indexOf(name) === -1) return;\n\n    var key = t.identifier(t.toIdentifier(name));\n    body.push(t.expressionStatement(t.assignmentExpression(\"=\", t.memberExpression(namespace, key), util.template(\"helper-\" + name))));\n  });\n}\n\n/**\n * [Please add a description.]\n */\n\nexports[\"default\"] = function (whitelist) {\n  var outputType = arguments.length <= 1 || arguments[1] === undefined ? \"global\" : arguments[1];\n\n  var namespace = t.identifier(\"babelHelpers\");\n\n  var builder = function builder(body) {\n    return buildHelpers(body, namespace, whitelist);\n  };\n\n  var tree;\n\n  var build = ({\n    global: buildGlobal,\n    umd: buildUmd,\n    \"var\": buildVar\n  })[outputType];\n\n  if (build) {\n    tree = build(namespace, builder);\n  } else {\n    throw new Error(messages.get(\"unsupportedOutputType\", outputType));\n  }\n\n  return _generation2[\"default\"](tree).code;\n};\n\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequire(obj) { return obj && obj.__esModule ? obj[\"default\"] : obj; }\n\nrequire(\"../../polyfill\");\n\nvar _node = require(\"./node\");\n\nexports[\"default\"] = _interopRequire(_node);\nmodule.exports = exports[\"default\"];","\n\nrequire(\"core-js/shim\");\n\nrequire(\"regenerator/runtime\");\n\nif (global._babelPolyfill) {\n  throw new Error(\"only one instance of babel/polyfill is allowed\");\n}\nglobal._babelPolyfill = true;","\n\nexports.__esModule = true;\n// istanbul ignore next\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj[\"default\"] = obj; return newObj; } }\n\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _sourceMapSupport = require(\"source-map-support\");\n\nvar _sourceMapSupport2 = _interopRequireDefault(_sourceMapSupport);\n\nvar _cache = require(\"./cache\");\n\nvar registerCache = _interopRequireWildcard(_cache);\n\nvar _transformationFileOptionsOptionManager = require(\"../../transformation/file/options/option-manager\");\n\nvar _transformationFileOptionsOptionManager2 = _interopRequireDefault(_transformationFileOptionsOptionManager);\n\nvar _lodashObjectExtend = require(\"lodash/object/extend\");\n\nvar _lodashObjectExtend2 = _interopRequireDefault(_lodashObjectExtend);\n\nvar _node = require(\"../node\");\n\nvar babel = _interopRequireWildcard(_node);\n\nvar _lodashCollectionEach = require(\"lodash/collection/each\");\n\nvar _lodashCollectionEach2 = _interopRequireDefault(_lodashCollectionEach);\n\nvar _util = require(\"../../util\");\n\nvar util = _interopRequireWildcard(_util);\n\nvar _fs = require(\"fs\");\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _path = require(\"path\");\n\nvar _path2 = _interopRequireDefault(_path);\n\n/**\n * Install sourcemaps into node.\n */\n\n_sourceMapSupport2[\"default\"].install({\n  handleUncaughtExceptions: false,\n  retrieveSourceMap: function retrieveSourceMap(source) {\n    var map = maps && maps[source];\n    if (map) {\n      return {\n        url: null,\n        map: map\n      };\n    } else {\n      return null;\n    }\n  }\n});\n\n/**\n * Load and setup cache.\n */\n\nregisterCache.load();\nvar cache = registerCache.get();\n\n/**\n * Store options.\n */\n\nvar transformOpts = {};\n\nvar ignore;\nvar only;\n\nvar oldHandlers = {};\nvar maps = {};\n\nvar cwd = process.cwd();\n\n/**\n * Get path from `filename` relative to the current working directory.\n */\n\nvar getRelativePath = function getRelativePath(filename) {\n  return _path2[\"default\"].relative(cwd, filename);\n};\n\n/**\n * Get last modified time for a `filename`.\n */\n\nvar mtime = function mtime(filename) {\n  return +_fs2[\"default\"].statSync(filename).mtime;\n};\n\n/**\n * Compile a `filename` with optional `opts`.\n */\n\nvar compile = function compile(filename) {\n  var opts = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n  var result;\n\n  opts.filename = filename;\n\n  var optsManager = new _transformationFileOptionsOptionManager2[\"default\"]();\n  optsManager.mergeOptions(transformOpts);\n  opts = optsManager.init(opts);\n\n  var cacheKey = JSON.stringify(opts) + \":\" + babel.version;\n\n  var env = process.env.BABEL_ENV || process.env.NODE_ENV;\n  if (env) cacheKey += \":\" + env;\n\n  if (cache) {\n    var cached = cache[cacheKey];\n    if (cached && cached.mtime === mtime(filename)) {\n      result = cached;\n    }\n  }\n\n  if (!result) {\n    result = babel.transformFileSync(filename, _lodashObjectExtend2[\"default\"](opts, {\n      sourceMap: \"both\",\n      ast: false\n    }));\n  }\n\n  if (cache) {\n    result.mtime = mtime(filename);\n    cache[cacheKey] = result;\n  }\n\n  maps[filename] = result.map;\n\n  return result.code;\n};\n\n/**\n * Test if a `filename` should be ignored by Babel.\n */\n\nvar shouldIgnore = function shouldIgnore(filename) {\n  if (!ignore && !only) {\n    return getRelativePath(filename).split(_path2[\"default\"].sep).indexOf(\"node_modules\") >= 0;\n  } else {\n    return util.shouldIgnore(filename, ignore || [], only);\n  }\n};\n\n/**\n * Monkey patch istanbul if it is running so that it works properly.\n */\n\nvar istanbulMonkey = {};\n\nif (process.env.running_under_istanbul) {\n  // we need to monkey patch fs.readFileSync so we can hook into\n  // what istanbul gets, it's extremely dirty but it's the only way\n  var _readFileSync = _fs2[\"default\"].readFileSync;\n\n  _fs2[\"default\"].readFileSync = function (filename) {\n    if (istanbulMonkey[filename]) {\n      delete istanbulMonkey[filename];\n      var code = compile(filename, {\n        auxiliaryCommentBefore: \"istanbul ignore next\"\n      });\n      istanbulMonkey[filename] = true;\n      return code;\n    } else {\n      return _readFileSync.apply(this, arguments);\n    }\n  };\n}\n\n/**\n * Replacement for the loader for istanbul.\n */\n\nvar istanbulLoader = function istanbulLoader(m, filename, old) {\n  istanbulMonkey[filename] = true;\n  old(m, filename);\n};\n\n/**\n * Default loader.\n */\n\nvar normalLoader = function normalLoader(m, filename) {\n  m._compile(compile(filename), filename);\n};\n\n/**\n * Register a loader for an extension.\n */\n\nvar registerExtension = function registerExtension(ext) {\n  var old = oldHandlers[ext] || oldHandlers[\".js\"] || require.extensions[\".js\"];\n\n  var loader = normalLoader;\n  if (process.env.running_under_istanbul) loader = istanbulLoader;\n\n  require.extensions[ext] = function (m, filename) {\n    if (shouldIgnore(filename)) {\n      old(m, filename);\n    } else {\n      loader(m, filename, old);\n    }\n  };\n};\n\n/**\n * Register loader for given extensions.\n */\n\nvar hookExtensions = function hookExtensions(_exts) {\n  _lodashCollectionEach2[\"default\"](oldHandlers, function (old, ext) {\n    if (old === undefined) {\n      delete require.extensions[ext];\n    } else {\n      require.extensions[ext] = old;\n    }\n  });\n\n  oldHandlers = {};\n\n  _lodashCollectionEach2[\"default\"](_exts, function (ext) {\n    oldHandlers[ext] = require.extensions[ext];\n    registerExtension(ext);\n  });\n};\n\n/**\n * Register loader for default extensions.\n */\n\nhookExtensions(util.canCompile.EXTENSIONS);\n\n/**\n * Update options at runtime.\n */\n\nexports[\"default\"] = function () {\n  var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n  if (opts.only != null) only = util.arrayify(opts.only, util.regexify);\n  if (opts.ignore != null) ignore = util.arrayify(opts.ignore, util.regexify);\n\n  if (opts.extensions) hookExtensions(util.arrayify(opts.extensions));\n\n  if (opts.cache === false) cache = null;\n\n  delete opts.extensions;\n  delete opts.ignore;\n  delete opts.cache;\n  delete opts.only;\n\n  _lodashObjectExtend2[\"default\"](transformOpts, opts);\n};\n\nmodule.exports = exports[\"default\"];","\n\nexports.__esModule = true;\nexports.save = save;\nexports.load = load;\nexports.get = get;\n// istanbul ignore next\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _path = require(\"path\");\n\nvar _path2 = _interopRequireDefault(_path);\n\nvar _fs = require(\"fs\");\n\nvar _fs2 = _interopRequireDefault(_fs);\n\nvar _homeOrTmp = require(\"home-or-tmp\");\n\nvar _homeOrTmp2 = _interopRequireDefault(_homeOrTmp);\n\nvar _pathExists = require(\"path-exists\");\n\nvar _pathExists2 = _interopRequireDefault(_pathExists);\n\nvar FILENAME = process.env.BABEL_CACHE_PATH || _path2[\"default\"].join(_homeOrTmp2[\"default\"], \".babel.json\");\nvar data = {};\n\n/**\n * Write stringified cache to disk.\n */\n\nfunction save() {\n  _fs2[\"default\"].writeFileSync(FILENAME, JSON.stringify(data, null, \"  \"));\n}\n\n/**\n * Load cache from disk and parse.\n */\n\nfunction load() {\n  if (process.env.BABEL_DISABLE_CACHE) return;\n\n  process.on(\"exit\", save);\n  process.nextTick(save);\n\n  if (!_pathExists2[\"default\"].sync(FILENAME)) return;\n\n  try {\n    data = JSON.parse(_fs2[\"default\"].readFileSync(FILENAME));\n  } catch (err) {\n    return;\n  }\n}\n\n/**\n * Retrieve data from cache.\n */\n\nfunction get() {\n  return data;\n}"]}