{"version":3,"sources":["stringmap.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["// stringmap.js\n// MIT licensed, see LICENSE file\n// Copyright (c) 2013 Olov Lassus <olov.lassus@gmail.com>\n\nvar StringMap = (function() {\n    \n\n    // to save us a few characters\n    var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n    var create = (function() {\n        function hasOwnEnumerableProps(obj) {\n            for (var prop in obj) {\n                if (hasOwnProperty.call(obj, prop)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        // FF <= 3.6:\n        // o = {}; o.hasOwnProperty(\"__proto__\" or \"__count__\" or \"__parent__\") => true\n        // o = {\"__proto__\": null}; Object.prototype.hasOwnProperty.call(o, \"__proto__\" or \"__count__\" or \"__parent__\") => false\n        function hasOwnPollutedProps(obj) {\n            return hasOwnProperty.call(obj, \"__count__\") || hasOwnProperty.call(obj, \"__parent__\");\n        }\n\n        var useObjectCreate = false;\n        if (typeof Object.create === \"function\") {\n            if (!hasOwnEnumerableProps(Object.create(null))) {\n                useObjectCreate = true;\n            }\n        }\n        if (useObjectCreate === false) {\n            if (hasOwnEnumerableProps({})) {\n                throw new Error(\"StringMap environment error 0, please file a bug at https://github.com/olov/stringmap/issues\");\n            }\n        }\n        // no throw yet means we can create objects without own enumerable props (safe-guard against VMs and shims)\n\n        var o = (useObjectCreate ? Object.create(null) : {});\n        var useProtoClear = false;\n        if (hasOwnPollutedProps(o)) {\n            o.__proto__ = null;\n            if (hasOwnEnumerableProps(o) || hasOwnPollutedProps(o)) {\n                throw new Error(\"StringMap environment error 1, please file a bug at https://github.com/olov/stringmap/issues\");\n            }\n            useProtoClear = true;\n        }\n        // no throw yet means we can create objects without own polluted props (safe-guard against VMs and shims)\n\n        return function() {\n            var o = (useObjectCreate ? Object.create(null) : {});\n            if (useProtoClear) {\n                o.__proto__ = null;\n            }\n            return o;\n        };\n    })();\n\n    // stringmap ctor\n    function stringmap(optional_object) {\n        // use with or without new\n        if (!(this instanceof stringmap)) {\n            return new stringmap(optional_object);\n        }\n        this.obj = create();\n        this.hasProto = false; // false (no __proto__ key) or true (has __proto__ key)\n        this.proto = undefined; // value for __proto__ key when hasProto is true, undefined otherwise\n\n        if (optional_object) {\n            this.setMany(optional_object);\n        }\n    };\n\n    // primitive methods that deals with data representation\n    stringmap.prototype.has = function(key) {\n        // The type-check of key in has, get, set and delete is important because otherwise an object\n        // {toString: function() { return \"__proto__\"; }} can avoid the key === \"__proto__\" test.\n        // The alternative to type-checking would be to force string conversion, i.e. key = String(key);\n        if (typeof key !== \"string\") {\n            throw new Error(\"StringMap expected string key\");\n        }\n        return (key === \"__proto__\" ?\n            this.hasProto :\n            hasOwnProperty.call(this.obj, key));\n    };\n\n    stringmap.prototype.get = function(key) {\n        if (typeof key !== \"string\") {\n            throw new Error(\"StringMap expected string key\");\n        }\n        return (key === \"__proto__\" ?\n            this.proto :\n            (hasOwnProperty.call(this.obj, key) ? this.obj[key] : undefined));\n    };\n\n    stringmap.prototype.set = function(key, value) {\n        if (typeof key !== \"string\") {\n            throw new Error(\"StringMap expected string key\");\n        }\n        if (key === \"__proto__\") {\n            this.hasProto = true;\n            this.proto = value;\n        } else {\n            this.obj[key] = value;\n        }\n    };\n\n    stringmap.prototype.remove = function(key) {\n        if (typeof key !== \"string\") {\n            throw new Error(\"StringMap expected string key\");\n        }\n        var didExist = this.has(key);\n        if (key === \"__proto__\") {\n            this.hasProto = false;\n            this.proto = undefined;\n        } else {\n            delete this.obj[key];\n        }\n        return didExist;\n    };\n\n    // alias remove to delete but beware:\n    // sm.delete(\"key\"); // OK in ES5 and later\n    // sm['delete'](\"key\"); // OK in all ES versions\n    // sm.remove(\"key\"); // OK in all ES versions\n    stringmap.prototype['delete'] = stringmap.prototype.remove;\n\n    stringmap.prototype.isEmpty = function() {\n        for (var key in this.obj) {\n            if (hasOwnProperty.call(this.obj, key)) {\n                return false;\n            }\n        }\n        return !this.hasProto;\n    };\n\n    stringmap.prototype.size = function() {\n        var len = 0;\n        for (var key in this.obj) {\n            if (hasOwnProperty.call(this.obj, key)) {\n                ++len;\n            }\n        }\n        return (this.hasProto ? len + 1 : len);\n    };\n\n    stringmap.prototype.keys = function() {\n        var keys = [];\n        for (var key in this.obj) {\n            if (hasOwnProperty.call(this.obj, key)) {\n                keys.push(key);\n            }\n        }\n        if (this.hasProto) {\n            keys.push(\"__proto__\");\n        }\n        return keys;\n    };\n\n    stringmap.prototype.values = function() {\n        var values = [];\n        for (var key in this.obj) {\n            if (hasOwnProperty.call(this.obj, key)) {\n                values.push(this.obj[key]);\n            }\n        }\n        if (this.hasProto) {\n            values.push(this.proto);\n        }\n        return values;\n    };\n\n    stringmap.prototype.items = function() {\n        var items = [];\n        for (var key in this.obj) {\n            if (hasOwnProperty.call(this.obj, key)) {\n                items.push([key, this.obj[key]]);\n            }\n        }\n        if (this.hasProto) {\n            items.push([\"__proto__\", this.proto]);\n        }\n        return items;\n    };\n\n\n    // methods that rely on the above primitives\n    stringmap.prototype.setMany = function(object) {\n        if (object === null || (typeof object !== \"object\" && typeof object !== \"function\")) {\n            throw new Error(\"StringMap expected Object\");\n        }\n        for (var key in object) {\n            if (hasOwnProperty.call(object, key)) {\n                this.set(key, object[key]);\n            }\n        }\n        return this;\n    };\n\n    stringmap.prototype.merge = function(other) {\n        var keys = other.keys();\n        for (var i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            this.set(key, other.get(key));\n        }\n        return this;\n    };\n\n    stringmap.prototype.map = function(fn) {\n        var keys = this.keys();\n        for (var i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            keys[i] = fn(this.get(key), key); // re-use keys array for results\n        }\n        return keys;\n    };\n\n    stringmap.prototype.forEach = function(fn) {\n        var keys = this.keys();\n        for (var i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            fn(this.get(key), key);\n        }\n    };\n\n    stringmap.prototype.clone = function() {\n        var other = stringmap();\n        return other.merge(this);\n    };\n\n    stringmap.prototype.toString = function() {\n        var self = this;\n        return \"{\" + this.keys().map(function(key) {\n            return JSON.stringify(key) + \":\" + JSON.stringify(self.get(key));\n        }).join(\",\") + \"}\";\n    };\n\n    return stringmap;\n})();\n\nif (typeof module !== \"undefined\" && typeof module.exports !== \"undefined\") {\n    module.exports = StringMap;\n}\n"]}