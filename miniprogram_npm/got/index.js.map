{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nvar http = require('http');\nvar https = require('https');\nvar urlLib = require('url');\nvar util = require('util');\nvar zlib = require('zlib');\nvar querystring = require('querystring');\nvar objectAssign = require('object-assign');\nvar infinityAgent = require('infinity-agent');\nvar duplexify = require('duplexify');\nvar isStream = require('is-stream');\nvar readAllStream = require('read-all-stream');\nvar timedOut = require('timed-out');\nvar prependHttp = require('prepend-http');\nvar lowercaseKeys = require('lowercase-keys');\nvar isRedirect = require('is-redirect');\nvar NestedErrorStacks = require('nested-error-stacks');\n\nfunction GotError(message, nested) {\n\tNestedErrorStacks.call(this, message, nested);\n\tobjectAssign(this, nested, {nested: this.nested});\n}\n\nutil.inherits(GotError, NestedErrorStacks);\nGotError.prototype.name = 'GotError';\n\nfunction got(url, opts, cb) {\n\tif (typeof url !== 'string' && typeof url !== 'object') {\n\t\tthrow new GotError('Parameter `url` must be a string or object, not ' + typeof url);\n\t}\n\n\tif (typeof opts === 'function') {\n\t\tcb = opts;\n\t\topts = {};\n\t}\n\n\topts = objectAssign(\n\t\t{\n\t\t\tprotocol: 'http:'\n\t\t},\n\t\ttypeof url === 'string' ? urlLib.parse(prependHttp(url)) : url,\n\t\topts\n\t);\n\n\topts.headers = objectAssign({\n\t\t'user-agent': 'https://github.com/sindresorhus/got',\n\t\t'accept-encoding': 'gzip,deflate'\n\t}, lowercaseKeys(opts.headers));\n\n\tif (opts.pathname) {\n\t\topts.path = opts.pathname;\n\t}\n\n\tif (opts.query) {\n\t\tif (typeof opts.query !== 'string') {\n\t\t\topts.query = querystring.stringify(opts.query);\n\t\t}\n\n\t\topts.path = opts.pathname + '?' + opts.query;\n\t\tdelete opts.query;\n\t}\n\n\tvar encoding = opts.encoding;\n\tvar body = opts.body;\n\tvar json = opts.json;\n\tvar timeout = opts.timeout;\n\tvar proxy;\n\tvar redirectCount = 0;\n\n\tdelete opts.encoding;\n\tdelete opts.body;\n\tdelete opts.json;\n\tdelete opts.timeout;\n\n\tif (json) {\n\t\topts.headers.accept = opts.headers.accept || 'application/json';\n\t}\n\n\tif (body) {\n\t\tif (typeof body !== 'string' && !Buffer.isBuffer(body) && !isStream.readable(body)) {\n\t\t\tthrow new GotError('options.body must be a ReadableStream, string or Buffer');\n\t\t}\n\n\t\topts.method = opts.method || 'POST';\n\n\t\tif (!opts.headers['content-length'] && !opts.headers['transfer-encoding'] && !isStream.readable(body)) {\n\t\t\tvar length = typeof body === 'string' ? Buffer.byteLength(body) : body.length;\n\t\t\topts.headers['content-length'] = length;\n\t\t}\n\t}\n\n\topts.method = opts.method || 'GET';\n\n\t// returns a proxy stream to the response\n\t// if no callback has been provided\n\tif (!cb) {\n\t\tproxy = duplexify();\n\n\t\t// forward errors on the stream\n\t\tcb = function (err, data, response) {\n\t\t\tproxy.emit('error', err, data, response);\n\t\t};\n\t}\n\n\tif (proxy && json) {\n\t\tthrow new GotError('got can not be used as stream when options.json is used');\n\t}\n\n\tfunction get(opts, cb) {\n\t\tvar fn = opts.protocol === 'https:' ? https : http;\n\t\tvar url = urlLib.format(opts);\n\n\t\tif (opts.agent === undefined) {\n\t\t\topts.agent = infinityAgent[fn === https ? 'https' : 'http'].globalAgent;\n\n\t\t\tif (process.version.indexOf('v0.10') === 0 && fn === https && (\n\t\t\t\ttypeof opts.ca !== 'undefined' ||\n\t\t\t\ttypeof opts.cert !== 'undefined' ||\n\t\t\t\ttypeof opts.ciphers !== 'undefined' ||\n\t\t\t\ttypeof opts.key !== 'undefined' ||\n\t\t\t\ttypeof opts.passphrase !== 'undefined' ||\n\t\t\t\ttypeof opts.pfx !== 'undefined' ||\n\t\t\t\ttypeof opts.rejectUnauthorized !== 'undefined')) {\n\t\t\t\topts.agent = new infinityAgent.https.Agent({\n\t\t\t\t\tca: opts.ca,\n\t\t\t\t\tcert: opts.cert,\n\t\t\t\t\tciphers: opts.ciphers,\n\t\t\t\t\tkey: opts.key,\n\t\t\t\t\tpassphrase: opts.passphrase,\n\t\t\t\t\tpfx: opts.pfx,\n\t\t\t\t\trejectUnauthorized: opts.rejectUnauthorized\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tvar req = fn.request(opts, function (response) {\n\t\t\tvar statusCode = response.statusCode;\n\t\t\tvar res = response;\n\n\t\t\t// auto-redirect only for GET and HEAD methods\n\t\t\tif (isRedirect(statusCode) && 'location' in res.headers && (opts.method === 'GET' || opts.method === 'HEAD')) {\n\t\t\t\t// discard response\n\t\t\t\tres.resume();\n\n\t\t\t\tif (++redirectCount > 10) {\n\t\t\t\t\tcb(new GotError('Redirected 10 times. Aborting.'), undefined, res);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar redirectUrl = urlLib.resolve(url, res.headers.location);\n\t\t\t\tvar redirectOpts = objectAssign({}, opts, urlLib.parse(redirectUrl));\n\n\t\t\t\tif (opts.agent === infinityAgent.http.globalAgent && redirectOpts.protocol === 'https:' && opts.protocol === 'http:') {\n\t\t\t\t\tredirectOpts.agent = undefined;\n\t\t\t\t}\n\n\t\t\t\tif (proxy) {\n\t\t\t\t\tproxy.emit('redirect', res, redirectOpts);\n\t\t\t\t}\n\n\t\t\t\tget(redirectOpts, cb);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (proxy) {\n\t\t\t\tproxy.emit('response', res);\n\t\t\t}\n\n\t\t\tif (['gzip', 'deflate'].indexOf(res.headers['content-encoding']) !== -1) {\n\t\t\t\tres = res.pipe(zlib.createUnzip());\n\t\t\t}\n\n\t\t\tif (statusCode < 200 || statusCode > 299) {\n\t\t\t\treadAllStream(res, encoding, function (err, data) {\n\t\t\t\t\terr = new GotError(opts.method + ' ' + url + ' response code is ' + statusCode + ' (' + http.STATUS_CODES[statusCode] + ')', err);\n\t\t\t\t\terr.code = statusCode;\n\n\t\t\t\t\tif (data && json) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tdata = JSON.parse(data);\n\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\terr = new GotError('Parsing ' + url + ' response failed', new GotError(e.message, err));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tcb(err, data, response);\n\t\t\t\t});\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// pipe the response to the proxy if in proxy mode\n\t\t\tif (proxy) {\n\t\t\t\tproxy.setReadable(res);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treadAllStream(res, encoding, function (err, data) {\n\t\t\t\tif (err) {\n\t\t\t\t\terr = new GotError('Reading ' + url + ' response failed', err);\n\t\t\t\t} else if (json && statusCode !== 204) {\n\t\t\t\t\t// only parse json if the option is enabled, and the response\n\t\t\t\t\t// is not a 204 (empty reponse)\n\t\t\t\t\ttry {\n\t\t\t\t\t\tdata = JSON.parse(data);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\terr = new GotError('Parsing ' + url + ' response failed', e);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tcb(err, data, response);\n\t\t\t});\n\t\t}).once('error', function (err) {\n\t\t\tcb(new GotError('Request to ' + url + ' failed', err));\n\t\t});\n\n\t\tif (timeout) {\n\t\t\ttimedOut(req, timeout);\n\t\t}\n\n\t\tif (!proxy) {\n\t\t\tif (isStream.readable(body)) {\n\t\t\t\tbody.pipe(req);\n\t\t\t} else {\n\t\t\t\treq.end(body);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (body) {\n\t\t\tproxy.write = function () {\n\t\t\t\tthrow new Error('got\\'s stream is not writable when options.body is used');\n\t\t\t};\n\n\t\t\tif (isStream.readable(body)) {\n\t\t\t\tbody.pipe(req);\n\t\t\t} else {\n\t\t\t\treq.end(body);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tif (opts.method === 'POST' || opts.method === 'PUT' || opts.method === 'PATCH') {\n\t\t\tproxy.setWritable(req);\n\t\t\treturn;\n\t\t}\n\n\t\treq.end();\n\t}\n\n\tget(opts, cb);\n\n\treturn proxy;\n}\n\n[\n\t'get',\n\t'post',\n\t'put',\n\t'patch',\n\t'head',\n\t'delete'\n].forEach(function (el) {\n\tgot[el] = function (url, opts, cb) {\n\t\tif (typeof opts === 'function') {\n\t\t\tcb = opts;\n\t\t\topts = {};\n\t\t}\n\n\t\treturn got(url, objectAssign({}, opts, {method: el.toUpperCase()}), cb);\n\t};\n});\n\nmodule.exports = got;\n"]}